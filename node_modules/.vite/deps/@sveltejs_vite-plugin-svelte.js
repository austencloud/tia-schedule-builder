import {
  isCSSRequest
} from "./chunk-2R3WYWHR.js";
import {
  createFilter,
  loadEnv,
  normalizePath$3,
  preprocessCSS,
  require_node_crypto,
  resolveConfig,
  transformWithEsbuild
} from "./chunk-SACH2NAO.js";
import "./chunk-2VIVBLDH.js";
import {
  require_node_fs,
  require_node_perf_hooks,
  require_node_process,
  require_promises
} from "./chunk-U6KSZ22X.js";
import "./chunk-RGID6XIU.js";
import "./chunk-4FU3HMBD.js";
import {
  require_node_module,
  require_node_url
} from "./chunk-YEY65PCL.js";
import {
  require_node_path
} from "./chunk-7P42VZFR.js";
import "./chunk-QR7N5PKG.js";
import "./chunk-5K3J3U72.js";
import "./chunk-I2FQUVGJ.js";
import {
  escape_html
} from "./chunk-O53T737B.js";
import {
  cannot_be_set_statically,
  hash,
  is_boolean_attribute,
  is_capture_event,
  is_content_editable_binding,
  is_delegated,
  is_dom_property,
  is_load_error_element,
  is_mathml,
  is_passive_event,
  is_reserved,
  is_rune,
  is_state_creation_rune,
  is_svg,
  is_void,
  normalize_attribute,
  sanitize_location
} from "./chunk-NEQ7BCPY.js";
import {
  EACH_INDEX_REACTIVE,
  EACH_IS_ANIMATED,
  EACH_IS_CONTROLLED,
  EACH_ITEM_IMMUTABLE,
  EACH_ITEM_REACTIVE,
  ELEMENT_IS_NAMESPACED,
  ELEMENT_PRESERVE_ATTRIBUTE_CASE,
  HYDRATION_END,
  HYDRATION_START,
  HYDRATION_START_ELSE,
  IGNORABLE_RUNTIME_WARNINGS,
  NAMESPACE_MATHML,
  NAMESPACE_SVG,
  PROPS_IS_BINDABLE,
  PROPS_IS_IMMUTABLE,
  PROPS_IS_LAZY_INITIAL,
  PROPS_IS_RUNES,
  PROPS_IS_UPDATED,
  TEMPLATE_FRAGMENT,
  TEMPLATE_USE_IMPORT_NODE,
  TEMPLATE_USE_MATHML,
  TEMPLATE_USE_SVG,
  TRANSITION_GLOBAL,
  TRANSITION_IN,
  TRANSITION_OUT
} from "./chunk-P2HHOFO7.js";
import {
  VERSION
} from "./chunk-HRSPTUBA.js";
import {
  __commonJS,
  __export,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField,
  __require,
  __toESM
} from "./chunk-6LNZPZHA.js";

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w2 = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse6(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse6(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n2 = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n2 * y;
        case "weeks":
        case "week":
        case "w":
          return n2 * w2;
        case "days":
        case "day":
        case "d":
          return n2 * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n2 * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n2 * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n2 * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n2;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n2, name) {
      var isPlural = msAbs >= n2 * 1.5;
      return Math.round(ms / n2) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key2) => {
        createDebug[key2] = env[key2];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug3(...args) {
          if (!debug3.enabled) {
            return;
          }
          const self2 = debug3;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug3.namespace = namespace;
        debug3.useColors = createDebug.useColors();
        debug3.color = createDebug.selectColor(namespace);
        debug3.extend = extend2;
        debug3.destroy = createDebug.destroy;
        Object.defineProperty(debug3, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug3);
        }
        return debug3;
      }
      function extend2(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template2) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template2.length && (template2[templateIndex] === search[searchIndex] || template2[templateIndex] === "*")) {
            if (template2[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template2.length && template2[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template2.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned3 = false;
      return () => {
        if (!warned3) {
          warned3 = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c2);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/aria-query/lib/util/iteratorProxy.js
var require_iteratorProxy = __commonJS({
  "node_modules/aria-query/lib/util/iteratorProxy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function iteratorProxy() {
      var values = this;
      var index = 0;
      var iter = {
        "@@iterator": function iterator() {
          return iter;
        },
        next: function next2() {
          if (index < values.length) {
            var value = values[index];
            index = index + 1;
            return {
              done: false,
              value
            };
          } else {
            return {
              done: true
            };
          }
        }
      };
      return iter;
    }
    var _default = exports.default = iteratorProxy;
  }
});

// node_modules/aria-query/lib/util/iterationDecorator.js
var require_iterationDecorator = __commonJS({
  "node_modules/aria-query/lib/util/iterationDecorator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = iterationDecorator;
    var _iteratorProxy = _interopRequireDefault(require_iteratorProxy());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function iterationDecorator(collection, entries) {
      if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
        Object.defineProperty(collection, Symbol.iterator, {
          value: _iteratorProxy.default.bind(entries)
        });
      }
      return collection;
    }
  }
});

// node_modules/aria-query/lib/ariaPropsMap.js
var require_ariaPropsMap = __commonJS({
  "node_modules/aria-query/lib/ariaPropsMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _slicedToArray(r, e2) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e2) || _unsupportedIterableToArray(r, e2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e2 = 0, n2 = Array(a); e2 < a; e2++) n2[e2] = r[e2];
      return n2;
    }
    function _iterableToArrayLimit(r, l2) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e2, n2, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l2) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e2 = i.call(t)).done) && (a.push(e2.value), a.length !== l2); f = true) ;
        } catch (r2) {
          o = true, n2 = r2;
        } finally {
          try {
            if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n2;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    var properties = [["aria-activedescendant", {
      "type": "id"
    }], ["aria-atomic", {
      "type": "boolean"
    }], ["aria-autocomplete", {
      "type": "token",
      "values": ["inline", "list", "both", "none"]
    }], ["aria-braillelabel", {
      "type": "string"
    }], ["aria-brailleroledescription", {
      "type": "string"
    }], ["aria-busy", {
      "type": "boolean"
    }], ["aria-checked", {
      "type": "tristate"
    }], ["aria-colcount", {
      type: "integer"
    }], ["aria-colindex", {
      type: "integer"
    }], ["aria-colspan", {
      type: "integer"
    }], ["aria-controls", {
      "type": "idlist"
    }], ["aria-current", {
      type: "token",
      values: ["page", "step", "location", "date", "time", true, false]
    }], ["aria-describedby", {
      "type": "idlist"
    }], ["aria-description", {
      "type": "string"
    }], ["aria-details", {
      "type": "id"
    }], ["aria-disabled", {
      "type": "boolean"
    }], ["aria-dropeffect", {
      "type": "tokenlist",
      "values": ["copy", "execute", "link", "move", "none", "popup"]
    }], ["aria-errormessage", {
      "type": "id"
    }], ["aria-expanded", {
      "type": "boolean",
      "allowundefined": true
    }], ["aria-flowto", {
      "type": "idlist"
    }], ["aria-grabbed", {
      "type": "boolean",
      "allowundefined": true
    }], ["aria-haspopup", {
      "type": "token",
      "values": [false, true, "menu", "listbox", "tree", "grid", "dialog"]
    }], ["aria-hidden", {
      "type": "boolean",
      "allowundefined": true
    }], ["aria-invalid", {
      "type": "token",
      "values": ["grammar", false, "spelling", true]
    }], ["aria-keyshortcuts", {
      type: "string"
    }], ["aria-label", {
      "type": "string"
    }], ["aria-labelledby", {
      "type": "idlist"
    }], ["aria-level", {
      "type": "integer"
    }], ["aria-live", {
      "type": "token",
      "values": ["assertive", "off", "polite"]
    }], ["aria-modal", {
      type: "boolean"
    }], ["aria-multiline", {
      "type": "boolean"
    }], ["aria-multiselectable", {
      "type": "boolean"
    }], ["aria-orientation", {
      "type": "token",
      "values": ["vertical", "undefined", "horizontal"]
    }], ["aria-owns", {
      "type": "idlist"
    }], ["aria-placeholder", {
      type: "string"
    }], ["aria-posinset", {
      "type": "integer"
    }], ["aria-pressed", {
      "type": "tristate"
    }], ["aria-readonly", {
      "type": "boolean"
    }], ["aria-relevant", {
      "type": "tokenlist",
      "values": ["additions", "all", "removals", "text"]
    }], ["aria-required", {
      "type": "boolean"
    }], ["aria-roledescription", {
      type: "string"
    }], ["aria-rowcount", {
      type: "integer"
    }], ["aria-rowindex", {
      type: "integer"
    }], ["aria-rowspan", {
      type: "integer"
    }], ["aria-selected", {
      "type": "boolean",
      "allowundefined": true
    }], ["aria-setsize", {
      "type": "integer"
    }], ["aria-sort", {
      "type": "token",
      "values": ["ascending", "descending", "none", "other"]
    }], ["aria-valuemax", {
      "type": "number"
    }], ["aria-valuemin", {
      "type": "number"
    }], ["aria-valuenow", {
      "type": "number"
    }], ["aria-valuetext", {
      "type": "string"
    }]];
    var ariaPropsMap = {
      entries: function entries() {
        return properties;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i = 0, _properties = properties; _i < _properties.length; _i++) {
          var _properties$_i = _slicedToArray(_properties[_i], 2), key2 = _properties$_i[0], values = _properties$_i[1];
          fn.call(thisArg, values, key2, properties);
        }
      },
      get: function get2(key2) {
        var item = properties.filter(function(tuple) {
          return tuple[0] === key2 ? true : false;
        })[0];
        return item && item[1];
      },
      has: function has(key2) {
        return !!ariaPropsMap.get(key2);
      },
      keys: function keys() {
        return properties.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return properties.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = exports.default = (0, _iterationDecorator.default)(ariaPropsMap, ariaPropsMap.entries());
  }
});

// node_modules/aria-query/lib/domMap.js
var require_domMap = __commonJS({
  "node_modules/aria-query/lib/domMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _slicedToArray(r, e2) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e2) || _unsupportedIterableToArray(r, e2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e2 = 0, n2 = Array(a); e2 < a; e2++) n2[e2] = r[e2];
      return n2;
    }
    function _iterableToArrayLimit(r, l2) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e2, n2, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l2) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e2 = i.call(t)).done) && (a.push(e2.value), a.length !== l2); f = true) ;
        } catch (r2) {
          o = true, n2 = r2;
        } finally {
          try {
            if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n2;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    var dom = [["a", {
      reserved: false
    }], ["abbr", {
      reserved: false
    }], ["acronym", {
      reserved: false
    }], ["address", {
      reserved: false
    }], ["applet", {
      reserved: false
    }], ["area", {
      reserved: false
    }], ["article", {
      reserved: false
    }], ["aside", {
      reserved: false
    }], ["audio", {
      reserved: false
    }], ["b", {
      reserved: false
    }], ["base", {
      reserved: true
    }], ["bdi", {
      reserved: false
    }], ["bdo", {
      reserved: false
    }], ["big", {
      reserved: false
    }], ["blink", {
      reserved: false
    }], ["blockquote", {
      reserved: false
    }], ["body", {
      reserved: false
    }], ["br", {
      reserved: false
    }], ["button", {
      reserved: false
    }], ["canvas", {
      reserved: false
    }], ["caption", {
      reserved: false
    }], ["center", {
      reserved: false
    }], ["cite", {
      reserved: false
    }], ["code", {
      reserved: false
    }], ["col", {
      reserved: true
    }], ["colgroup", {
      reserved: true
    }], ["content", {
      reserved: false
    }], ["data", {
      reserved: false
    }], ["datalist", {
      reserved: false
    }], ["dd", {
      reserved: false
    }], ["del", {
      reserved: false
    }], ["details", {
      reserved: false
    }], ["dfn", {
      reserved: false
    }], ["dialog", {
      reserved: false
    }], ["dir", {
      reserved: false
    }], ["div", {
      reserved: false
    }], ["dl", {
      reserved: false
    }], ["dt", {
      reserved: false
    }], ["em", {
      reserved: false
    }], ["embed", {
      reserved: false
    }], ["fieldset", {
      reserved: false
    }], ["figcaption", {
      reserved: false
    }], ["figure", {
      reserved: false
    }], ["font", {
      reserved: false
    }], ["footer", {
      reserved: false
    }], ["form", {
      reserved: false
    }], ["frame", {
      reserved: false
    }], ["frameset", {
      reserved: false
    }], ["h1", {
      reserved: false
    }], ["h2", {
      reserved: false
    }], ["h3", {
      reserved: false
    }], ["h4", {
      reserved: false
    }], ["h5", {
      reserved: false
    }], ["h6", {
      reserved: false
    }], ["head", {
      reserved: true
    }], ["header", {
      reserved: false
    }], ["hgroup", {
      reserved: false
    }], ["hr", {
      reserved: false
    }], ["html", {
      reserved: true
    }], ["i", {
      reserved: false
    }], ["iframe", {
      reserved: false
    }], ["img", {
      reserved: false
    }], ["input", {
      reserved: false
    }], ["ins", {
      reserved: false
    }], ["kbd", {
      reserved: false
    }], ["keygen", {
      reserved: false
    }], ["label", {
      reserved: false
    }], ["legend", {
      reserved: false
    }], ["li", {
      reserved: false
    }], ["link", {
      reserved: true
    }], ["main", {
      reserved: false
    }], ["map", {
      reserved: false
    }], ["mark", {
      reserved: false
    }], ["marquee", {
      reserved: false
    }], ["menu", {
      reserved: false
    }], ["menuitem", {
      reserved: false
    }], ["meta", {
      reserved: true
    }], ["meter", {
      reserved: false
    }], ["nav", {
      reserved: false
    }], ["noembed", {
      reserved: true
    }], ["noscript", {
      reserved: true
    }], ["object", {
      reserved: false
    }], ["ol", {
      reserved: false
    }], ["optgroup", {
      reserved: false
    }], ["option", {
      reserved: false
    }], ["output", {
      reserved: false
    }], ["p", {
      reserved: false
    }], ["param", {
      reserved: true
    }], ["picture", {
      reserved: true
    }], ["pre", {
      reserved: false
    }], ["progress", {
      reserved: false
    }], ["q", {
      reserved: false
    }], ["rp", {
      reserved: false
    }], ["rt", {
      reserved: false
    }], ["rtc", {
      reserved: false
    }], ["ruby", {
      reserved: false
    }], ["s", {
      reserved: false
    }], ["samp", {
      reserved: false
    }], ["script", {
      reserved: true
    }], ["section", {
      reserved: false
    }], ["select", {
      reserved: false
    }], ["small", {
      reserved: false
    }], ["source", {
      reserved: true
    }], ["spacer", {
      reserved: false
    }], ["span", {
      reserved: false
    }], ["strike", {
      reserved: false
    }], ["strong", {
      reserved: false
    }], ["style", {
      reserved: true
    }], ["sub", {
      reserved: false
    }], ["summary", {
      reserved: false
    }], ["sup", {
      reserved: false
    }], ["table", {
      reserved: false
    }], ["tbody", {
      reserved: false
    }], ["td", {
      reserved: false
    }], ["textarea", {
      reserved: false
    }], ["tfoot", {
      reserved: false
    }], ["th", {
      reserved: false
    }], ["thead", {
      reserved: false
    }], ["time", {
      reserved: false
    }], ["title", {
      reserved: true
    }], ["tr", {
      reserved: false
    }], ["track", {
      reserved: true
    }], ["tt", {
      reserved: false
    }], ["u", {
      reserved: false
    }], ["ul", {
      reserved: false
    }], ["var", {
      reserved: false
    }], ["video", {
      reserved: false
    }], ["wbr", {
      reserved: false
    }], ["xmp", {
      reserved: false
    }]];
    var domMap = {
      entries: function entries() {
        return dom;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i = 0, _dom = dom; _i < _dom.length; _i++) {
          var _dom$_i = _slicedToArray(_dom[_i], 2), key2 = _dom$_i[0], values = _dom$_i[1];
          fn.call(thisArg, values, key2, dom);
        }
      },
      get: function get2(key2) {
        var item = dom.filter(function(tuple) {
          return tuple[0] === key2 ? true : false;
        })[0];
        return item && item[1];
      },
      has: function has(key2) {
        return !!domMap.get(key2);
      },
      keys: function keys() {
        return dom.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return dom.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = exports.default = (0, _iterationDecorator.default)(domMap, domMap.entries());
  }
});

// node_modules/aria-query/lib/etc/roles/abstract/commandRole.js
var require_commandRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/abstract/commandRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var commandRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    var _default = exports.default = commandRole;
  }
});

// node_modules/aria-query/lib/etc/roles/abstract/compositeRole.js
var require_compositeRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/abstract/compositeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var compositeRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    var _default = exports.default = compositeRole;
  }
});

// node_modules/aria-query/lib/etc/roles/abstract/inputRole.js
var require_inputRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/abstract/inputRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var inputRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null
      },
      relatedConcepts: [{
        concept: {
          name: "input"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    var _default = exports.default = inputRole;
  }
});

// node_modules/aria-query/lib/etc/roles/abstract/landmarkRole.js
var require_landmarkRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/abstract/landmarkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var landmarkRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = landmarkRole;
  }
});

// node_modules/aria-query/lib/etc/roles/abstract/rangeRole.js
var require_rangeRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/abstract/rangeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rangeRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuemax": null,
        "aria-valuemin": null,
        "aria-valuenow": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = rangeRole;
  }
});

// node_modules/aria-query/lib/etc/roles/abstract/roletypeRole.js
var require_roletypeRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/abstract/roletypeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var roletypeRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {
        "aria-atomic": null,
        "aria-busy": null,
        "aria-controls": null,
        "aria-current": null,
        "aria-describedby": null,
        "aria-details": null,
        "aria-dropeffect": null,
        "aria-flowto": null,
        "aria-grabbed": null,
        "aria-hidden": null,
        "aria-keyshortcuts": null,
        "aria-label": null,
        "aria-labelledby": null,
        "aria-live": null,
        "aria-owns": null,
        "aria-relevant": null,
        "aria-roledescription": null
      },
      relatedConcepts: [{
        concept: {
          name: "role"
        },
        module: "XHTML"
      }, {
        concept: {
          name: "type"
        },
        module: "Dublin Core"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: []
    };
    var _default = exports.default = roletypeRole;
  }
});

// node_modules/aria-query/lib/etc/roles/abstract/sectionRole.js
var require_sectionRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/abstract/sectionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var sectionRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "frontmatter"
        },
        module: "DTB"
      }, {
        concept: {
          name: "level"
        },
        module: "DTB"
      }, {
        concept: {
          name: "level"
        },
        module: "SMIL"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = sectionRole;
  }
});

// node_modules/aria-query/lib/etc/roles/abstract/sectionheadRole.js
var require_sectionheadRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/abstract/sectionheadRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var sectionheadRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = sectionheadRole;
  }
});

// node_modules/aria-query/lib/etc/roles/abstract/selectRole.js
var require_selectRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/abstract/selectRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var selectRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "group"]]
    };
    var _default = exports.default = selectRole;
  }
});

// node_modules/aria-query/lib/etc/roles/abstract/structureRole.js
var require_structureRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/abstract/structureRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var structureRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    var _default = exports.default = structureRole;
  }
});

// node_modules/aria-query/lib/etc/roles/abstract/widgetRole.js
var require_widgetRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/abstract/widgetRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var widgetRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    var _default = exports.default = widgetRole;
  }
});

// node_modules/aria-query/lib/etc/roles/abstract/windowRole.js
var require_windowRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/abstract/windowRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var windowRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-modal": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    var _default = exports.default = windowRole;
  }
});

// node_modules/aria-query/lib/etc/roles/ariaAbstractRoles.js
var require_ariaAbstractRoles = __commonJS({
  "node_modules/aria-query/lib/etc/roles/ariaAbstractRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _commandRole = _interopRequireDefault(require_commandRole());
    var _compositeRole = _interopRequireDefault(require_compositeRole());
    var _inputRole = _interopRequireDefault(require_inputRole());
    var _landmarkRole = _interopRequireDefault(require_landmarkRole());
    var _rangeRole = _interopRequireDefault(require_rangeRole());
    var _roletypeRole = _interopRequireDefault(require_roletypeRole());
    var _sectionRole = _interopRequireDefault(require_sectionRole());
    var _sectionheadRole = _interopRequireDefault(require_sectionheadRole());
    var _selectRole = _interopRequireDefault(require_selectRole());
    var _structureRole = _interopRequireDefault(require_structureRole());
    var _widgetRole = _interopRequireDefault(require_widgetRole());
    var _windowRole = _interopRequireDefault(require_windowRole());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var ariaAbstractRoles = [["command", _commandRole.default], ["composite", _compositeRole.default], ["input", _inputRole.default], ["landmark", _landmarkRole.default], ["range", _rangeRole.default], ["roletype", _roletypeRole.default], ["section", _sectionRole.default], ["sectionhead", _sectionheadRole.default], ["select", _selectRole.default], ["structure", _structureRole.default], ["widget", _widgetRole.default], ["window", _windowRole.default]];
    var _default = exports.default = ariaAbstractRoles;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/alertRole.js
var require_alertRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/alertRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var alertRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-atomic": "true",
        "aria-live": "assertive"
      },
      relatedConcepts: [{
        concept: {
          name: "alert"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = alertRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/alertdialogRole.js
var require_alertdialogRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/alertdialogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var alertdialogRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "alert"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "alert"], ["roletype", "window", "dialog"]]
    };
    var _default = exports.default = alertdialogRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/applicationRole.js
var require_applicationRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/applicationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var applicationRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "Device Independence Delivery Unit"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = applicationRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/articleRole.js
var require_articleRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/articleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var articleRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "article"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "document"]]
    };
    var _default = exports.default = articleRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/bannerRole.js
var require_bannerRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/bannerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var bannerRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element"],
          name: "header"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = bannerRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/blockquoteRole.js
var require_blockquoteRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/blockquoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var blockquoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "blockquote"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = blockquoteRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/buttonRole.js
var require_buttonRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/buttonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var buttonRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-pressed": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "button"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "image"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "reset"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "submit"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "button"
        },
        module: "HTML"
      }, {
        concept: {
          name: "trigger"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    var _default = exports.default = buttonRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/captionRole.js
var require_captionRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/captionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var captionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "caption"
        },
        module: "HTML"
      }],
      requireContextRole: ["figure", "grid", "table"],
      requiredContextRole: ["figure", "grid", "table"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = captionRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/cellRole.js
var require_cellRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/cellRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var cellRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-colindex": null,
        "aria-colspan": null,
        "aria-rowindex": null,
        "aria-rowspan": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["ancestor table element has table role"],
          name: "td"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = cellRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/checkboxRole.js
var require_checkboxRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/checkboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var checkboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "checkbox"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "option"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = exports.default = checkboxRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/codeRole.js
var require_codeRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/codeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var codeRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "code"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = codeRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/columnheaderRole.js
var require_columnheaderRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/columnheaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var columnheaderRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-sort": null
      },
      relatedConcepts: [{
        concept: {
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "col"
          }],
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "colgroup"
          }],
          name: "th"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
    };
    var _default = exports.default = columnheaderRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/comboboxRole.js
var require_comboboxRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/comboboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var comboboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-autocomplete": null,
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-expanded": "false",
        "aria-haspopup": "listbox"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "email"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "search"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "tel"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "text"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "multiple"
          }, {
            constraints: ["undefined"],
            name: "size"
          }],
          constraints: ["the multiple attribute is not set and the size attribute does not have a value greater than 1"],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-controls": null,
        "aria-expanded": "false"
      },
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = exports.default = comboboxRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/complementaryRole.js
var require_complementaryRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/complementaryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var complementaryRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element", "scoped to the main element"],
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "aside"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = complementaryRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/contentinfoRole.js
var require_contentinfoRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/contentinfoRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var contentinfoRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element"],
          name: "footer"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = contentinfoRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/definitionRole.js
var require_definitionRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/definitionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var definitionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dd"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = definitionRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/deletionRole.js
var require_deletionRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/deletionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var deletionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "del"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = deletionRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/dialogRole.js
var require_dialogRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/dialogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var dialogRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dialog"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "window"]]
    };
    var _default = exports.default = dialogRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/directoryRole.js
var require_directoryRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/directoryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var directoryRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        module: "DAISY Guide"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "list"]]
    };
    var _default = exports.default = directoryRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/documentRole.js
var require_documentRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/documentRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var documentRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "Device Independence Delivery Unit"
        }
      }, {
        concept: {
          name: "html"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = documentRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/emphasisRole.js
var require_emphasisRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/emphasisRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var emphasisRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "em"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = emphasisRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/feedRole.js
var require_feedRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/feedRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var feedRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["article"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "list"]]
    };
    var _default = exports.default = feedRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/figureRole.js
var require_figureRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/figureRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var figureRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "figure"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = figureRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/formRole.js
var require_formRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/formRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var formRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          name: "form"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          name: "form"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "name"
          }],
          name: "form"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = formRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/genericRole.js
var require_genericRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/genericRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var genericRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "a"
        },
        module: "HTML"
      }, {
        concept: {
          name: "area"
        },
        module: "HTML"
      }, {
        concept: {
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          name: "b"
        },
        module: "HTML"
      }, {
        concept: {
          name: "bdo"
        },
        module: "HTML"
      }, {
        concept: {
          name: "body"
        },
        module: "HTML"
      }, {
        concept: {
          name: "data"
        },
        module: "HTML"
      }, {
        concept: {
          name: "div"
        },
        module: "HTML"
      }, {
        concept: {
          constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "footer"
        },
        module: "HTML"
      }, {
        concept: {
          constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "header"
        },
        module: "HTML"
      }, {
        concept: {
          name: "hgroup"
        },
        module: "HTML"
      }, {
        concept: {
          name: "i"
        },
        module: "HTML"
      }, {
        concept: {
          name: "pre"
        },
        module: "HTML"
      }, {
        concept: {
          name: "q"
        },
        module: "HTML"
      }, {
        concept: {
          name: "samp"
        },
        module: "HTML"
      }, {
        concept: {
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          name: "small"
        },
        module: "HTML"
      }, {
        concept: {
          name: "span"
        },
        module: "HTML"
      }, {
        concept: {
          name: "u"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = genericRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/gridRole.js
var require_gridRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/gridRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var gridRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-multiselectable": null,
        "aria-readonly": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "table"]]
    };
    var _default = exports.default = gridRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/gridcellRole.js
var require_gridcellRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/gridcellRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var gridcellRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-selected": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["ancestor table element has grid role", "ancestor table element has treegrid role"],
          name: "td"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "widget"]]
    };
    var _default = exports.default = gridcellRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/groupRole.js
var require_groupRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/groupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var groupRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null
      },
      relatedConcepts: [{
        concept: {
          name: "details"
        },
        module: "HTML"
      }, {
        concept: {
          name: "fieldset"
        },
        module: "HTML"
      }, {
        concept: {
          name: "optgroup"
        },
        module: "HTML"
      }, {
        concept: {
          name: "address"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = groupRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/headingRole.js
var require_headingRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/headingRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var headingRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-level": "2"
      },
      relatedConcepts: [{
        concept: {
          name: "h1"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h2"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h3"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h4"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h5"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h6"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-level": "2"
      },
      superClass: [["roletype", "structure", "sectionhead"]]
    };
    var _default = exports.default = headingRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/imgRole.js
var require_imgRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/imgRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var imgRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "alt"
          }],
          name: "img"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "alt"
          }],
          name: "img"
        },
        module: "HTML"
      }, {
        concept: {
          name: "imggroup"
        },
        module: "DTB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = imgRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/insertionRole.js
var require_insertionRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/insertionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var insertionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "ins"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = insertionRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/linkRole.js
var require_linkRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/linkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var linkRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "href"
          }],
          name: "a"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "href"
          }],
          name: "area"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    var _default = exports.default = linkRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/listRole.js
var require_listRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/listRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var listRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menu"
        },
        module: "HTML"
      }, {
        concept: {
          name: "ol"
        },
        module: "HTML"
      }, {
        concept: {
          name: "ul"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["listitem"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = listRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/listboxRole.js
var require_listboxRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/listboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var listboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-invalid": null,
        "aria-multiselectable": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-orientation": "vertical"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: [">1"],
            name: "size"
          }],
          constraints: ["the size attribute value is greater than 1"],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "multiple"
          }],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          name: "datalist"
        },
        module: "HTML"
      }, {
        concept: {
          name: "list"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["option", "group"], ["option"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    var _default = exports.default = listboxRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/listitemRole.js
var require_listitemRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/listitemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var listitemRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-level": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["direct descendant of ol", "direct descendant of ul", "direct descendant of menu"],
          name: "li"
        },
        module: "HTML"
      }, {
        concept: {
          name: "item"
        },
        module: "XForms"
      }],
      requireContextRole: ["directory", "list"],
      requiredContextRole: ["directory", "list"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = listitemRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/logRole.js
var require_logRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/logRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var logRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-live": "polite"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = logRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/mainRole.js
var require_mainRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/mainRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var mainRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "main"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = mainRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/markRole.js
var require_markRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/markRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var markRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null
      },
      relatedConcepts: [{
        concept: {
          name: "mark"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = markRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/marqueeRole.js
var require_marqueeRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/marqueeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var marqueeRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = marqueeRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/mathRole.js
var require_mathRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/mathRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var mathRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "math"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = mathRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/menuRole.js
var require_menuRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/menuRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "vertical"
      },
      relatedConcepts: [{
        concept: {
          name: "MENU"
        },
        module: "JAPI"
      }, {
        concept: {
          name: "list"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }, {
        concept: {
          name: "sidebar"
        },
        module: "DTB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    var _default = exports.default = menuRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/menubarRole.js
var require_menubarRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/menubarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menubarRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        concept: {
          name: "toolbar"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select", "menu"], ["roletype", "structure", "section", "group", "select", "menu"]]
    };
    var _default = exports.default = menubarRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/menuitemRole.js
var require_menuitemRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/menuitemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuitemRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "MENU_ITEM"
        },
        module: "JAPI"
      }, {
        concept: {
          name: "listitem"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "option"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    var _default = exports.default = menuitemRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/menuitemcheckboxRole.js
var require_menuitemcheckboxRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/menuitemcheckboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuitemcheckboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menuitem"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox"], ["roletype", "widget", "command", "menuitem"]]
    };
    var _default = exports.default = menuitemcheckboxRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/menuitemradioRole.js
var require_menuitemradioRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/menuitemradioRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuitemradioRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menuitem"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox", "menuitemcheckbox"], ["roletype", "widget", "command", "menuitem", "menuitemcheckbox"], ["roletype", "widget", "input", "radio"]]
    };
    var _default = exports.default = menuitemradioRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/meterRole.js
var require_meterRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/meterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var meterRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuetext": null,
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [{
        concept: {
          name: "meter"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-valuenow": null
      },
      superClass: [["roletype", "structure", "range"]]
    };
    var _default = exports.default = meterRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/navigationRole.js
var require_navigationRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/navigationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var navigationRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "nav"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = navigationRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/noneRole.js
var require_noneRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/noneRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var noneRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: []
    };
    var _default = exports.default = noneRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/noteRole.js
var require_noteRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/noteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var noteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = noteRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/optionRole.js
var require_optionRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/optionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var optionRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-posinset": null,
        "aria-setsize": null,
        "aria-selected": "false"
      },
      relatedConcepts: [{
        concept: {
          name: "item"
        },
        module: "XForms"
      }, {
        concept: {
          name: "listitem"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "option"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-selected": "false"
      },
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = exports.default = optionRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/paragraphRole.js
var require_paragraphRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/paragraphRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var paragraphRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "p"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = paragraphRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/presentationRole.js
var require_presentationRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/presentationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var presentationRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "alt",
            value: ""
          }],
          name: "img"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = presentationRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/progressbarRole.js
var require_progressbarRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/progressbarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var progressbarRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuetext": null
      },
      relatedConcepts: [{
        concept: {
          name: "progress"
        },
        module: "HTML"
      }, {
        concept: {
          name: "status"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
    };
    var _default = exports.default = progressbarRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/radioRole.js
var require_radioRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/radioRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var radioRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "radio"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = exports.default = radioRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/radiogroupRole.js
var require_radiogroupRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/radiogroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var radiogroupRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          name: "list"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["radio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    var _default = exports.default = radiogroupRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/regionRole.js
var require_regionRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/regionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var regionRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          name: "Device Independence Glossart perceivable unit"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = regionRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/rowRole.js
var require_rowRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/rowRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rowRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-colindex": null,
        "aria-expanded": null,
        "aria-level": null,
        "aria-posinset": null,
        "aria-rowindex": null,
        "aria-selected": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "tr"
        },
        module: "HTML"
      }],
      requireContextRole: ["grid", "rowgroup", "table", "treegrid"],
      requiredContextRole: ["grid", "rowgroup", "table", "treegrid"],
      requiredOwnedElements: [["cell"], ["columnheader"], ["gridcell"], ["rowheader"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"], ["roletype", "widget"]]
    };
    var _default = exports.default = rowRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/rowgroupRole.js
var require_rowgroupRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/rowgroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rowgroupRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "tbody"
        },
        module: "HTML"
      }, {
        concept: {
          name: "tfoot"
        },
        module: "HTML"
      }, {
        concept: {
          name: "thead"
        },
        module: "HTML"
      }],
      requireContextRole: ["grid", "table", "treegrid"],
      requiredContextRole: ["grid", "table", "treegrid"],
      requiredOwnedElements: [["row"]],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = rowgroupRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/rowheaderRole.js
var require_rowheaderRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/rowheaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rowheaderRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-sort": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "scope",
            value: "row"
          }],
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "rowgroup"
          }],
          name: "th"
        },
        module: "HTML"
      }],
      requireContextRole: ["row", "rowgroup"],
      requiredContextRole: ["row", "rowgroup"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
    };
    var _default = exports.default = rowheaderRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/scrollbarRole.js
var require_scrollbarRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/scrollbarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var scrollbarRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-valuetext": null,
        "aria-orientation": "vertical",
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-controls": null,
        "aria-valuenow": null
      },
      superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
    };
    var _default = exports.default = scrollbarRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/searchRole.js
var require_searchRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/searchRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var searchRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = searchRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/searchboxRole.js
var require_searchboxRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/searchboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var searchboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "search"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "input", "textbox"]]
    };
    var _default = exports.default = searchboxRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/separatorRole.js
var require_separatorRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/separatorRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var separatorRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-orientation": "horizontal",
        "aria-valuemax": "100",
        "aria-valuemin": "0",
        "aria-valuenow": null,
        "aria-valuetext": null
      },
      relatedConcepts: [{
        concept: {
          name: "hr"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = separatorRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/sliderRole.js
var require_sliderRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/sliderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var sliderRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-valuetext": null,
        "aria-orientation": "horizontal",
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "range"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-valuenow": null
      },
      superClass: [["roletype", "widget", "input"], ["roletype", "structure", "range"]]
    };
    var _default = exports.default = sliderRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/spinbuttonRole.js
var require_spinbuttonRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/spinbuttonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var spinbuttonRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-valuetext": null,
        "aria-valuenow": "0"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "number"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "widget", "input"], ["roletype", "structure", "range"]]
    };
    var _default = exports.default = spinbuttonRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/statusRole.js
var require_statusRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/statusRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var statusRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-atomic": "true",
        "aria-live": "polite"
      },
      relatedConcepts: [{
        concept: {
          name: "output"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = statusRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/strongRole.js
var require_strongRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/strongRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var strongRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "strong"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = strongRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/subscriptRole.js
var require_subscriptRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/subscriptRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var subscriptRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "sub"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = subscriptRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/superscriptRole.js
var require_superscriptRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/superscriptRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var superscriptRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "sup"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = superscriptRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/switchRole.js
var require_switchRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/switchRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var switchRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "button"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox"]]
    };
    var _default = exports.default = switchRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/tabRole.js
var require_tabRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/tabRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tabRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-posinset": null,
        "aria-setsize": null,
        "aria-selected": "false"
      },
      relatedConcepts: [],
      requireContextRole: ["tablist"],
      requiredContextRole: ["tablist"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "sectionhead"], ["roletype", "widget"]]
    };
    var _default = exports.default = tabRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/tableRole.js
var require_tableRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/tableRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tableRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-colcount": null,
        "aria-rowcount": null
      },
      relatedConcepts: [{
        concept: {
          name: "table"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = tableRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/tablistRole.js
var require_tablistRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/tablistRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tablistRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-level": null,
        "aria-multiselectable": null,
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        module: "DAISY",
        concept: {
          name: "guide"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["tab"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"]]
    };
    var _default = exports.default = tablistRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/tabpanelRole.js
var require_tabpanelRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/tabpanelRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tabpanelRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = tabpanelRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/termRole.js
var require_termRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/termRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var termRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dfn"
        },
        module: "HTML"
      }, {
        concept: {
          name: "dt"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = termRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/textboxRole.js
var require_textboxRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/textboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var textboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-autocomplete": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-multiline": null,
        "aria-placeholder": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "type"
          }, {
            constraints: ["undefined"],
            name: "list"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "email"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "tel"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "text"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "input"
        },
        module: "XForms"
      }, {
        concept: {
          name: "textarea"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = exports.default = textboxRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/timeRole.js
var require_timeRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/timeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var timeRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "time"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = timeRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/timerRole.js
var require_timerRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/timerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var timerRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "status"]]
    };
    var _default = exports.default = timerRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/toolbarRole.js
var require_toolbarRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/toolbarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var toolbarRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        concept: {
          name: "menubar"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"]]
    };
    var _default = exports.default = toolbarRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/tooltipRole.js
var require_tooltipRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/tooltipRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tooltipRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = tooltipRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/treeRole.js
var require_treeRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/treeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var treeRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-multiselectable": null,
        "aria-required": null,
        "aria-orientation": "vertical"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["treeitem", "group"], ["treeitem"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    var _default = exports.default = treeRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/treegridRole.js
var require_treegridRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/treegridRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var treegridRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "grid"], ["roletype", "structure", "section", "table", "grid"], ["roletype", "widget", "composite", "select", "tree"], ["roletype", "structure", "section", "group", "select", "tree"]]
    };
    var _default = exports.default = treegridRole;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/treeitemRole.js
var require_treeitemRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/treeitemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var treeitemRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-expanded": null,
        "aria-haspopup": null
      },
      relatedConcepts: [],
      requireContextRole: ["group", "tree"],
      requiredContextRole: ["group", "tree"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-selected": null
      },
      superClass: [["roletype", "structure", "section", "listitem"], ["roletype", "widget", "input", "option"]]
    };
    var _default = exports.default = treeitemRole;
  }
});

// node_modules/aria-query/lib/etc/roles/ariaLiteralRoles.js
var require_ariaLiteralRoles = __commonJS({
  "node_modules/aria-query/lib/etc/roles/ariaLiteralRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _alertRole = _interopRequireDefault(require_alertRole());
    var _alertdialogRole = _interopRequireDefault(require_alertdialogRole());
    var _applicationRole = _interopRequireDefault(require_applicationRole());
    var _articleRole = _interopRequireDefault(require_articleRole());
    var _bannerRole = _interopRequireDefault(require_bannerRole());
    var _blockquoteRole = _interopRequireDefault(require_blockquoteRole());
    var _buttonRole = _interopRequireDefault(require_buttonRole());
    var _captionRole = _interopRequireDefault(require_captionRole());
    var _cellRole = _interopRequireDefault(require_cellRole());
    var _checkboxRole = _interopRequireDefault(require_checkboxRole());
    var _codeRole = _interopRequireDefault(require_codeRole());
    var _columnheaderRole = _interopRequireDefault(require_columnheaderRole());
    var _comboboxRole = _interopRequireDefault(require_comboboxRole());
    var _complementaryRole = _interopRequireDefault(require_complementaryRole());
    var _contentinfoRole = _interopRequireDefault(require_contentinfoRole());
    var _definitionRole = _interopRequireDefault(require_definitionRole());
    var _deletionRole = _interopRequireDefault(require_deletionRole());
    var _dialogRole = _interopRequireDefault(require_dialogRole());
    var _directoryRole = _interopRequireDefault(require_directoryRole());
    var _documentRole = _interopRequireDefault(require_documentRole());
    var _emphasisRole = _interopRequireDefault(require_emphasisRole());
    var _feedRole = _interopRequireDefault(require_feedRole());
    var _figureRole = _interopRequireDefault(require_figureRole());
    var _formRole = _interopRequireDefault(require_formRole());
    var _genericRole = _interopRequireDefault(require_genericRole());
    var _gridRole = _interopRequireDefault(require_gridRole());
    var _gridcellRole = _interopRequireDefault(require_gridcellRole());
    var _groupRole = _interopRequireDefault(require_groupRole());
    var _headingRole = _interopRequireDefault(require_headingRole());
    var _imgRole = _interopRequireDefault(require_imgRole());
    var _insertionRole = _interopRequireDefault(require_insertionRole());
    var _linkRole = _interopRequireDefault(require_linkRole());
    var _listRole = _interopRequireDefault(require_listRole());
    var _listboxRole = _interopRequireDefault(require_listboxRole());
    var _listitemRole = _interopRequireDefault(require_listitemRole());
    var _logRole = _interopRequireDefault(require_logRole());
    var _mainRole = _interopRequireDefault(require_mainRole());
    var _markRole = _interopRequireDefault(require_markRole());
    var _marqueeRole = _interopRequireDefault(require_marqueeRole());
    var _mathRole = _interopRequireDefault(require_mathRole());
    var _menuRole = _interopRequireDefault(require_menuRole());
    var _menubarRole = _interopRequireDefault(require_menubarRole());
    var _menuitemRole = _interopRequireDefault(require_menuitemRole());
    var _menuitemcheckboxRole = _interopRequireDefault(require_menuitemcheckboxRole());
    var _menuitemradioRole = _interopRequireDefault(require_menuitemradioRole());
    var _meterRole = _interopRequireDefault(require_meterRole());
    var _navigationRole = _interopRequireDefault(require_navigationRole());
    var _noneRole = _interopRequireDefault(require_noneRole());
    var _noteRole = _interopRequireDefault(require_noteRole());
    var _optionRole = _interopRequireDefault(require_optionRole());
    var _paragraphRole = _interopRequireDefault(require_paragraphRole());
    var _presentationRole = _interopRequireDefault(require_presentationRole());
    var _progressbarRole = _interopRequireDefault(require_progressbarRole());
    var _radioRole = _interopRequireDefault(require_radioRole());
    var _radiogroupRole = _interopRequireDefault(require_radiogroupRole());
    var _regionRole = _interopRequireDefault(require_regionRole());
    var _rowRole = _interopRequireDefault(require_rowRole());
    var _rowgroupRole = _interopRequireDefault(require_rowgroupRole());
    var _rowheaderRole = _interopRequireDefault(require_rowheaderRole());
    var _scrollbarRole = _interopRequireDefault(require_scrollbarRole());
    var _searchRole = _interopRequireDefault(require_searchRole());
    var _searchboxRole = _interopRequireDefault(require_searchboxRole());
    var _separatorRole = _interopRequireDefault(require_separatorRole());
    var _sliderRole = _interopRequireDefault(require_sliderRole());
    var _spinbuttonRole = _interopRequireDefault(require_spinbuttonRole());
    var _statusRole = _interopRequireDefault(require_statusRole());
    var _strongRole = _interopRequireDefault(require_strongRole());
    var _subscriptRole = _interopRequireDefault(require_subscriptRole());
    var _superscriptRole = _interopRequireDefault(require_superscriptRole());
    var _switchRole = _interopRequireDefault(require_switchRole());
    var _tabRole = _interopRequireDefault(require_tabRole());
    var _tableRole = _interopRequireDefault(require_tableRole());
    var _tablistRole = _interopRequireDefault(require_tablistRole());
    var _tabpanelRole = _interopRequireDefault(require_tabpanelRole());
    var _termRole = _interopRequireDefault(require_termRole());
    var _textboxRole = _interopRequireDefault(require_textboxRole());
    var _timeRole = _interopRequireDefault(require_timeRole());
    var _timerRole = _interopRequireDefault(require_timerRole());
    var _toolbarRole = _interopRequireDefault(require_toolbarRole());
    var _tooltipRole = _interopRequireDefault(require_tooltipRole());
    var _treeRole = _interopRequireDefault(require_treeRole());
    var _treegridRole = _interopRequireDefault(require_treegridRole());
    var _treeitemRole = _interopRequireDefault(require_treeitemRole());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var ariaLiteralRoles = [["alert", _alertRole.default], ["alertdialog", _alertdialogRole.default], ["application", _applicationRole.default], ["article", _articleRole.default], ["banner", _bannerRole.default], ["blockquote", _blockquoteRole.default], ["button", _buttonRole.default], ["caption", _captionRole.default], ["cell", _cellRole.default], ["checkbox", _checkboxRole.default], ["code", _codeRole.default], ["columnheader", _columnheaderRole.default], ["combobox", _comboboxRole.default], ["complementary", _complementaryRole.default], ["contentinfo", _contentinfoRole.default], ["definition", _definitionRole.default], ["deletion", _deletionRole.default], ["dialog", _dialogRole.default], ["directory", _directoryRole.default], ["document", _documentRole.default], ["emphasis", _emphasisRole.default], ["feed", _feedRole.default], ["figure", _figureRole.default], ["form", _formRole.default], ["generic", _genericRole.default], ["grid", _gridRole.default], ["gridcell", _gridcellRole.default], ["group", _groupRole.default], ["heading", _headingRole.default], ["img", _imgRole.default], ["insertion", _insertionRole.default], ["link", _linkRole.default], ["list", _listRole.default], ["listbox", _listboxRole.default], ["listitem", _listitemRole.default], ["log", _logRole.default], ["main", _mainRole.default], ["mark", _markRole.default], ["marquee", _marqueeRole.default], ["math", _mathRole.default], ["menu", _menuRole.default], ["menubar", _menubarRole.default], ["menuitem", _menuitemRole.default], ["menuitemcheckbox", _menuitemcheckboxRole.default], ["menuitemradio", _menuitemradioRole.default], ["meter", _meterRole.default], ["navigation", _navigationRole.default], ["none", _noneRole.default], ["note", _noteRole.default], ["option", _optionRole.default], ["paragraph", _paragraphRole.default], ["presentation", _presentationRole.default], ["progressbar", _progressbarRole.default], ["radio", _radioRole.default], ["radiogroup", _radiogroupRole.default], ["region", _regionRole.default], ["row", _rowRole.default], ["rowgroup", _rowgroupRole.default], ["rowheader", _rowheaderRole.default], ["scrollbar", _scrollbarRole.default], ["search", _searchRole.default], ["searchbox", _searchboxRole.default], ["separator", _separatorRole.default], ["slider", _sliderRole.default], ["spinbutton", _spinbuttonRole.default], ["status", _statusRole.default], ["strong", _strongRole.default], ["subscript", _subscriptRole.default], ["superscript", _superscriptRole.default], ["switch", _switchRole.default], ["tab", _tabRole.default], ["table", _tableRole.default], ["tablist", _tablistRole.default], ["tabpanel", _tabpanelRole.default], ["term", _termRole.default], ["textbox", _textboxRole.default], ["time", _timeRole.default], ["timer", _timerRole.default], ["toolbar", _toolbarRole.default], ["tooltip", _tooltipRole.default], ["tree", _treeRole.default], ["treegrid", _treegridRole.default], ["treeitem", _treeitemRole.default]];
    var _default = exports.default = ariaLiteralRoles;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docAbstractRole.js
var require_docAbstractRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docAbstractRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAbstractRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "abstract [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docAbstractRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docAcknowledgmentsRole.js
var require_docAcknowledgmentsRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docAcknowledgmentsRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAcknowledgmentsRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "acknowledgments [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docAcknowledgmentsRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docAfterwordRole.js
var require_docAfterwordRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docAfterwordRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAfterwordRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "afterword [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docAfterwordRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docAppendixRole.js
var require_docAppendixRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docAppendixRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAppendixRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "appendix [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docAppendixRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docBacklinkRole.js
var require_docBacklinkRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docBacklinkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBacklinkRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "referrer [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    var _default = exports.default = docBacklinkRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docBiblioentryRole.js
var require_docBiblioentryRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docBiblioentryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBiblioentryRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "EPUB biblioentry [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: ["doc-bibliography"],
      requiredContextRole: ["doc-bibliography"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "listitem"]]
    };
    var _default = exports.default = docBiblioentryRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docBibliographyRole.js
var require_docBibliographyRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docBibliographyRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBibliographyRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "bibliography [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["doc-biblioentry"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docBibliographyRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docBibliorefRole.js
var require_docBibliorefRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docBibliorefRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBibliorefRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "biblioref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    var _default = exports.default = docBibliorefRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docChapterRole.js
var require_docChapterRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docChapterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docChapterRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "chapter [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docChapterRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docColophonRole.js
var require_docColophonRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docColophonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docColophonRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "colophon [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docColophonRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docConclusionRole.js
var require_docConclusionRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docConclusionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docConclusionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "conclusion [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docConclusionRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docCoverRole.js
var require_docCoverRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docCoverRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docCoverRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "cover [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "img"]]
    };
    var _default = exports.default = docCoverRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docCreditRole.js
var require_docCreditRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docCreditRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docCreditRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "credit [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docCreditRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docCreditsRole.js
var require_docCreditsRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docCreditsRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docCreditsRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "credits [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docCreditsRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docDedicationRole.js
var require_docDedicationRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docDedicationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docDedicationRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "dedication [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docDedicationRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docEndnoteRole.js
var require_docEndnoteRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docEndnoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEndnoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "rearnote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: ["doc-endnotes"],
      requiredContextRole: ["doc-endnotes"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "listitem"]]
    };
    var _default = exports.default = docEndnoteRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docEndnotesRole.js
var require_docEndnotesRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docEndnotesRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEndnotesRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "rearnotes [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["doc-endnote"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docEndnotesRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docEpigraphRole.js
var require_docEpigraphRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docEpigraphRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEpigraphRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "epigraph [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docEpigraphRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docEpilogueRole.js
var require_docEpilogueRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docEpilogueRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEpilogueRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "epilogue [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docEpilogueRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docErrataRole.js
var require_docErrataRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docErrataRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docErrataRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "errata [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docErrataRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docExampleRole.js
var require_docExampleRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docExampleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docExampleRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docExampleRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docFootnoteRole.js
var require_docFootnoteRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docFootnoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docFootnoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "footnote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docFootnoteRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docForewordRole.js
var require_docForewordRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docForewordRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docForewordRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "foreword [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docForewordRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docGlossaryRole.js
var require_docGlossaryRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docGlossaryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docGlossaryRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "glossary [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["definition"], ["term"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docGlossaryRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docGlossrefRole.js
var require_docGlossrefRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docGlossrefRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docGlossrefRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "glossref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    var _default = exports.default = docGlossrefRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docIndexRole.js
var require_docIndexRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docIndexRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docIndexRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "index [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    var _default = exports.default = docIndexRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docIntroductionRole.js
var require_docIntroductionRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docIntroductionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docIntroductionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "introduction [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docIntroductionRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docNoterefRole.js
var require_docNoterefRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docNoterefRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docNoterefRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "noteref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    var _default = exports.default = docNoterefRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docNoticeRole.js
var require_docNoticeRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docNoticeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docNoticeRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "notice [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "note"]]
    };
    var _default = exports.default = docNoticeRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docPagebreakRole.js
var require_docPagebreakRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docPagebreakRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPagebreakRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "pagebreak [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "separator"]]
    };
    var _default = exports.default = docPagebreakRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docPagefooterRole.js
var require_docPagefooterRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docPagefooterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPagefooterRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docPagefooterRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docPageheaderRole.js
var require_docPageheaderRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docPageheaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPageheaderRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docPageheaderRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docPagelistRole.js
var require_docPagelistRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docPagelistRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPagelistRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "page-list [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    var _default = exports.default = docPagelistRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docPartRole.js
var require_docPartRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docPartRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPartRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "part [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docPartRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docPrefaceRole.js
var require_docPrefaceRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docPrefaceRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPrefaceRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "preface [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docPrefaceRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docPrologueRole.js
var require_docPrologueRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docPrologueRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPrologueRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "prologue [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docPrologueRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docPullquoteRole.js
var require_docPullquoteRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docPullquoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPullquoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "pullquote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["none"]]
    };
    var _default = exports.default = docPullquoteRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docQnaRole.js
var require_docQnaRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docQnaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docQnaRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "qna [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docQnaRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docSubtitleRole.js
var require_docSubtitleRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docSubtitleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docSubtitleRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "subtitle [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "sectionhead"]]
    };
    var _default = exports.default = docSubtitleRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docTipRole.js
var require_docTipRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docTipRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docTipRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "help [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "note"]]
    };
    var _default = exports.default = docTipRole;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docTocRole.js
var require_docTocRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docTocRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docTocRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "toc [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    var _default = exports.default = docTocRole;
  }
});

// node_modules/aria-query/lib/etc/roles/ariaDpubRoles.js
var require_ariaDpubRoles = __commonJS({
  "node_modules/aria-query/lib/etc/roles/ariaDpubRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _docAbstractRole = _interopRequireDefault(require_docAbstractRole());
    var _docAcknowledgmentsRole = _interopRequireDefault(require_docAcknowledgmentsRole());
    var _docAfterwordRole = _interopRequireDefault(require_docAfterwordRole());
    var _docAppendixRole = _interopRequireDefault(require_docAppendixRole());
    var _docBacklinkRole = _interopRequireDefault(require_docBacklinkRole());
    var _docBiblioentryRole = _interopRequireDefault(require_docBiblioentryRole());
    var _docBibliographyRole = _interopRequireDefault(require_docBibliographyRole());
    var _docBibliorefRole = _interopRequireDefault(require_docBibliorefRole());
    var _docChapterRole = _interopRequireDefault(require_docChapterRole());
    var _docColophonRole = _interopRequireDefault(require_docColophonRole());
    var _docConclusionRole = _interopRequireDefault(require_docConclusionRole());
    var _docCoverRole = _interopRequireDefault(require_docCoverRole());
    var _docCreditRole = _interopRequireDefault(require_docCreditRole());
    var _docCreditsRole = _interopRequireDefault(require_docCreditsRole());
    var _docDedicationRole = _interopRequireDefault(require_docDedicationRole());
    var _docEndnoteRole = _interopRequireDefault(require_docEndnoteRole());
    var _docEndnotesRole = _interopRequireDefault(require_docEndnotesRole());
    var _docEpigraphRole = _interopRequireDefault(require_docEpigraphRole());
    var _docEpilogueRole = _interopRequireDefault(require_docEpilogueRole());
    var _docErrataRole = _interopRequireDefault(require_docErrataRole());
    var _docExampleRole = _interopRequireDefault(require_docExampleRole());
    var _docFootnoteRole = _interopRequireDefault(require_docFootnoteRole());
    var _docForewordRole = _interopRequireDefault(require_docForewordRole());
    var _docGlossaryRole = _interopRequireDefault(require_docGlossaryRole());
    var _docGlossrefRole = _interopRequireDefault(require_docGlossrefRole());
    var _docIndexRole = _interopRequireDefault(require_docIndexRole());
    var _docIntroductionRole = _interopRequireDefault(require_docIntroductionRole());
    var _docNoterefRole = _interopRequireDefault(require_docNoterefRole());
    var _docNoticeRole = _interopRequireDefault(require_docNoticeRole());
    var _docPagebreakRole = _interopRequireDefault(require_docPagebreakRole());
    var _docPagefooterRole = _interopRequireDefault(require_docPagefooterRole());
    var _docPageheaderRole = _interopRequireDefault(require_docPageheaderRole());
    var _docPagelistRole = _interopRequireDefault(require_docPagelistRole());
    var _docPartRole = _interopRequireDefault(require_docPartRole());
    var _docPrefaceRole = _interopRequireDefault(require_docPrefaceRole());
    var _docPrologueRole = _interopRequireDefault(require_docPrologueRole());
    var _docPullquoteRole = _interopRequireDefault(require_docPullquoteRole());
    var _docQnaRole = _interopRequireDefault(require_docQnaRole());
    var _docSubtitleRole = _interopRequireDefault(require_docSubtitleRole());
    var _docTipRole = _interopRequireDefault(require_docTipRole());
    var _docTocRole = _interopRequireDefault(require_docTocRole());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var ariaDpubRoles = [["doc-abstract", _docAbstractRole.default], ["doc-acknowledgments", _docAcknowledgmentsRole.default], ["doc-afterword", _docAfterwordRole.default], ["doc-appendix", _docAppendixRole.default], ["doc-backlink", _docBacklinkRole.default], ["doc-biblioentry", _docBiblioentryRole.default], ["doc-bibliography", _docBibliographyRole.default], ["doc-biblioref", _docBibliorefRole.default], ["doc-chapter", _docChapterRole.default], ["doc-colophon", _docColophonRole.default], ["doc-conclusion", _docConclusionRole.default], ["doc-cover", _docCoverRole.default], ["doc-credit", _docCreditRole.default], ["doc-credits", _docCreditsRole.default], ["doc-dedication", _docDedicationRole.default], ["doc-endnote", _docEndnoteRole.default], ["doc-endnotes", _docEndnotesRole.default], ["doc-epigraph", _docEpigraphRole.default], ["doc-epilogue", _docEpilogueRole.default], ["doc-errata", _docErrataRole.default], ["doc-example", _docExampleRole.default], ["doc-footnote", _docFootnoteRole.default], ["doc-foreword", _docForewordRole.default], ["doc-glossary", _docGlossaryRole.default], ["doc-glossref", _docGlossrefRole.default], ["doc-index", _docIndexRole.default], ["doc-introduction", _docIntroductionRole.default], ["doc-noteref", _docNoterefRole.default], ["doc-notice", _docNoticeRole.default], ["doc-pagebreak", _docPagebreakRole.default], ["doc-pagefooter", _docPagefooterRole.default], ["doc-pageheader", _docPageheaderRole.default], ["doc-pagelist", _docPagelistRole.default], ["doc-part", _docPartRole.default], ["doc-preface", _docPrefaceRole.default], ["doc-prologue", _docPrologueRole.default], ["doc-pullquote", _docPullquoteRole.default], ["doc-qna", _docQnaRole.default], ["doc-subtitle", _docSubtitleRole.default], ["doc-tip", _docTipRole.default], ["doc-toc", _docTocRole.default]];
    var _default = exports.default = ariaDpubRoles;
  }
});

// node_modules/aria-query/lib/etc/roles/graphics/graphicsDocumentRole.js
var require_graphicsDocumentRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/graphics/graphicsDocumentRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var graphicsDocumentRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        module: "GRAPHICS",
        concept: {
          name: "graphics-object"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "article"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "document"]]
    };
    var _default = exports.default = graphicsDocumentRole;
  }
});

// node_modules/aria-query/lib/etc/roles/graphics/graphicsObjectRole.js
var require_graphicsObjectRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/graphics/graphicsObjectRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var graphicsObjectRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        module: "GRAPHICS",
        concept: {
          name: "graphics-document"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "group"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "GRAPHICS",
        concept: {
          name: "graphics-symbol"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"]]
    };
    var _default = exports.default = graphicsObjectRole;
  }
});

// node_modules/aria-query/lib/etc/roles/graphics/graphicsSymbolRole.js
var require_graphicsSymbolRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/graphics/graphicsSymbolRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var graphicsSymbolRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "img"]]
    };
    var _default = exports.default = graphicsSymbolRole;
  }
});

// node_modules/aria-query/lib/etc/roles/ariaGraphicsRoles.js
var require_ariaGraphicsRoles = __commonJS({
  "node_modules/aria-query/lib/etc/roles/ariaGraphicsRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _graphicsDocumentRole = _interopRequireDefault(require_graphicsDocumentRole());
    var _graphicsObjectRole = _interopRequireDefault(require_graphicsObjectRole());
    var _graphicsSymbolRole = _interopRequireDefault(require_graphicsSymbolRole());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var ariaGraphicsRoles = [["graphics-document", _graphicsDocumentRole.default], ["graphics-object", _graphicsObjectRole.default], ["graphics-symbol", _graphicsSymbolRole.default]];
    var _default = exports.default = ariaGraphicsRoles;
  }
});

// node_modules/aria-query/lib/rolesMap.js
var require_rolesMap = __commonJS({
  "node_modules/aria-query/lib/rolesMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _ariaAbstractRoles = _interopRequireDefault(require_ariaAbstractRoles());
    var _ariaLiteralRoles = _interopRequireDefault(require_ariaLiteralRoles());
    var _ariaDpubRoles = _interopRequireDefault(require_ariaDpubRoles());
    var _ariaGraphicsRoles = _interopRequireDefault(require_ariaGraphicsRoles());
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _createForOfIteratorHelper(r, e2) {
      var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (!t) {
        if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e2 && r && "number" == typeof r.length) {
          t && (r = t);
          var _n = 0, F = function F2() {
          };
          return { s: F, n: function n2() {
            return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
          }, e: function e3(r2) {
            throw r2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var o, a = true, u = false;
      return { s: function s() {
        t = t.call(r);
      }, n: function n2() {
        var r2 = t.next();
        return a = r2.done, r2;
      }, e: function e3(r2) {
        u = true, o = r2;
      }, f: function f() {
        try {
          a || null == t.return || t.return();
        } finally {
          if (u) throw o;
        }
      } };
    }
    function _slicedToArray(r, e2) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e2) || _unsupportedIterableToArray(r, e2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e2 = 0, n2 = Array(a); e2 < a; e2++) n2[e2] = r[e2];
      return n2;
    }
    function _iterableToArrayLimit(r, l2) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e2, n2, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l2) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e2 = i.call(t)).done) && (a.push(e2.value), a.length !== l2); f = true) ;
        } catch (r2) {
          o = true, n2 = r2;
        } finally {
          try {
            if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n2;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    var roles = [].concat(_ariaAbstractRoles.default, _ariaLiteralRoles.default, _ariaDpubRoles.default, _ariaGraphicsRoles.default);
    roles.forEach(function(_ref) {
      var _ref2 = _slicedToArray(_ref, 2), roleDefinition = _ref2[1];
      var _iterator = _createForOfIteratorHelper(roleDefinition.superClass), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var superClassIter = _step.value;
          var _iterator2 = _createForOfIteratorHelper(superClassIter), _step2;
          try {
            var _loop = function _loop2() {
              var superClassName = _step2.value;
              var superClassRoleTuple = roles.filter(function(_ref3) {
                var _ref4 = _slicedToArray(_ref3, 1), name = _ref4[0];
                return name === superClassName;
              })[0];
              if (superClassRoleTuple) {
                var superClassDefinition = superClassRoleTuple[1];
                for (var _i = 0, _Object$keys = Object.keys(superClassDefinition.props); _i < _Object$keys.length; _i++) {
                  var prop2 = _Object$keys[_i];
                  if (
                    // $FlowIssue Accessing the hasOwnProperty on the Object prototype is fine.
                    !Object.prototype.hasOwnProperty.call(roleDefinition.props, prop2)
                  ) {
                    roleDefinition.props[prop2] = superClassDefinition.props[prop2];
                  }
                }
              }
            };
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              _loop();
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    });
    var rolesMap = {
      entries: function entries() {
        return roles;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator3 = _createForOfIteratorHelper(roles), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var _step3$value = _slicedToArray(_step3.value, 2), key2 = _step3$value[0], values = _step3$value[1];
            fn.call(thisArg, values, key2, roles);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      },
      get: function get2(key2) {
        var item = roles.filter(function(tuple) {
          return tuple[0] === key2 ? true : false;
        })[0];
        return item && item[1];
      },
      has: function has(key2) {
        return !!rolesMap.get(key2);
      },
      keys: function keys() {
        return roles.map(function(_ref5) {
          var _ref6 = _slicedToArray(_ref5, 1), key2 = _ref6[0];
          return key2;
        });
      },
      values: function values() {
        return roles.map(function(_ref7) {
          var _ref8 = _slicedToArray(_ref7, 2), values2 = _ref8[1];
          return values2;
        });
      }
    };
    var _default = exports.default = (0, _iterationDecorator.default)(rolesMap, rolesMap.entries());
  }
});

// node_modules/aria-query/lib/elementRoleMap.js
var require_elementRoleMap = __commonJS({
  "node_modules/aria-query/lib/elementRoleMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    var _rolesMap = _interopRequireDefault(require_rolesMap());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _slicedToArray(r, e2) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e2) || _unsupportedIterableToArray(r, e2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e2 = 0, n2 = Array(a); e2 < a; e2++) n2[e2] = r[e2];
      return n2;
    }
    function _iterableToArrayLimit(r, l2) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e2, n2, i2, u, a = [], f = true, o = false;
        try {
          if (i2 = (t = t.call(r)).next, 0 === l2) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e2 = i2.call(t)).done) && (a.push(e2.value), a.length !== l2); f = true) ;
        } catch (r2) {
          o = true, n2 = r2;
        } finally {
          try {
            if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n2;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    var elementRoles2 = [];
    var keys = _rolesMap.default.keys();
    for (i = 0; i < keys.length; i++) {
      key2 = keys[i];
      role = _rolesMap.default.get(key2);
      if (role) {
        concepts = [].concat(role.baseConcepts, role.relatedConcepts);
        _loop = function _loop2() {
          var relation = concepts[k];
          if (relation.module === "HTML") {
            var concept = relation.concept;
            if (concept) {
              var elementRoleRelation = elementRoles2.filter(function(relation2) {
                return ariaRoleRelationConceptEquals(relation2[0], concept);
              })[0];
              var roles;
              if (elementRoleRelation) {
                roles = elementRoleRelation[1];
              } else {
                roles = [];
              }
              var isUnique = true;
              for (var _i = 0; _i < roles.length; _i++) {
                if (roles[_i] === key2) {
                  isUnique = false;
                  break;
                }
              }
              if (isUnique) {
                roles.push(key2);
              }
              if (!elementRoleRelation) {
                elementRoles2.push([concept, roles]);
              }
            }
          }
        };
        for (k = 0; k < concepts.length; k++) {
          _loop();
        }
      }
    }
    var key2;
    var role;
    var concepts;
    var _loop;
    var k;
    var i;
    var elementRoleMap = {
      entries: function entries() {
        return elementRoles2;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i2 = 0, _elementRoles = elementRoles2; _i2 < _elementRoles.length; _i2++) {
          var _elementRoles$_i = _slicedToArray(_elementRoles[_i2], 2), _key = _elementRoles$_i[0], values = _elementRoles$_i[1];
          fn.call(thisArg, values, _key, elementRoles2);
        }
      },
      get: function get2(key3) {
        var item = elementRoles2.filter(function(tuple) {
          return key3.name === tuple[0].name && ariaRoleRelationConceptAttributeEquals(key3.attributes, tuple[0].attributes);
        })[0];
        return item && item[1];
      },
      has: function has(key3) {
        return !!elementRoleMap.get(key3);
      },
      keys: function keys2() {
        return elementRoles2.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key3 = _ref2[0];
          return key3;
        });
      },
      values: function values() {
        return elementRoles2.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    function ariaRoleRelationConceptEquals(a, b) {
      return a.name === b.name && ariaRoleRelationConstraintsEquals(a.constraints, b.constraints) && ariaRoleRelationConceptAttributeEquals(a.attributes, b.attributes);
    }
    function ariaRoleRelationConstraintsEquals(a, b) {
      if (a === void 0 && b !== void 0) {
        return false;
      }
      if (a !== void 0 && b === void 0) {
        return false;
      }
      if (a !== void 0 && b !== void 0) {
        if (a.length !== b.length) {
          return false;
        }
        for (var _i3 = 0; _i3 < a.length; _i3++) {
          if (a[_i3] !== b[_i3]) {
            return false;
          }
        }
      }
      return true;
    }
    function ariaRoleRelationConceptAttributeEquals(a, b) {
      if (a === void 0 && b !== void 0) {
        return false;
      }
      if (a !== void 0 && b === void 0) {
        return false;
      }
      if (a !== void 0 && b !== void 0) {
        if (a.length !== b.length) {
          return false;
        }
        for (var _i4 = 0; _i4 < a.length; _i4++) {
          if (a[_i4].name !== b[_i4].name || a[_i4].value !== b[_i4].value) {
            return false;
          }
          if (a[_i4].constraints === void 0 && b[_i4].constraints !== void 0) {
            return false;
          }
          if (a[_i4].constraints !== void 0 && b[_i4].constraints === void 0) {
            return false;
          }
          if (a[_i4].constraints !== void 0 && b[_i4].constraints !== void 0) {
            if (a[_i4].constraints.length !== b[_i4].constraints.length) {
              return false;
            }
            for (var j = 0; j < a[_i4].constraints.length; j++) {
              if (a[_i4].constraints[j] !== b[_i4].constraints[j]) {
                return false;
              }
            }
          }
        }
      }
      return true;
    }
    var _default = exports.default = (0, _iterationDecorator.default)(elementRoleMap, elementRoleMap.entries());
  }
});

// node_modules/aria-query/lib/roleElementMap.js
var require_roleElementMap = __commonJS({
  "node_modules/aria-query/lib/roleElementMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    var _rolesMap = _interopRequireDefault(require_rolesMap());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _slicedToArray(r, e2) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e2) || _unsupportedIterableToArray(r, e2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e2 = 0, n2 = Array(a); e2 < a; e2++) n2[e2] = r[e2];
      return n2;
    }
    function _iterableToArrayLimit(r, l2) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e2, n2, i2, u, a = [], f = true, o = false;
        try {
          if (i2 = (t = t.call(r)).next, 0 === l2) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e2 = i2.call(t)).done) && (a.push(e2.value), a.length !== l2); f = true) ;
        } catch (r2) {
          o = true, n2 = r2;
        } finally {
          try {
            if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n2;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    var roleElement = [];
    var keys = _rolesMap.default.keys();
    for (i = 0; i < keys.length; i++) {
      key2 = keys[i];
      role = _rolesMap.default.get(key2);
      relationConcepts = [];
      if (role) {
        concepts = [].concat(role.baseConcepts, role.relatedConcepts);
        for (k = 0; k < concepts.length; k++) {
          relation = concepts[k];
          if (relation.module === "HTML") {
            concept = relation.concept;
            if (concept != null) {
              relationConcepts.push(concept);
            }
          }
        }
        if (relationConcepts.length > 0) {
          roleElement.push([key2, relationConcepts]);
        }
      }
    }
    var key2;
    var role;
    var relationConcepts;
    var concepts;
    var relation;
    var concept;
    var k;
    var i;
    var roleElementMap = {
      entries: function entries() {
        return roleElement;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i = 0, _roleElement = roleElement; _i < _roleElement.length; _i++) {
          var _roleElement$_i = _slicedToArray(_roleElement[_i], 2), _key = _roleElement$_i[0], values = _roleElement$_i[1];
          fn.call(thisArg, values, _key, roleElement);
        }
      },
      get: function get2(key3) {
        var item = roleElement.filter(function(tuple) {
          return tuple[0] === key3 ? true : false;
        })[0];
        return item && item[1];
      },
      has: function has(key3) {
        return !!roleElementMap.get(key3);
      },
      keys: function keys2() {
        return roleElement.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key3 = _ref2[0];
          return key3;
        });
      },
      values: function values() {
        return roleElement.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = exports.default = (0, _iterationDecorator.default)(roleElementMap, roleElementMap.entries());
  }
});

// node_modules/aria-query/lib/index.js
var require_lib = __commonJS({
  "node_modules/aria-query/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.roles = exports.roleElements = exports.elementRoles = exports.dom = exports.aria = void 0;
    var _ariaPropsMap = _interopRequireDefault(require_ariaPropsMap());
    var _domMap = _interopRequireDefault(require_domMap());
    var _rolesMap = _interopRequireDefault(require_rolesMap());
    var _elementRoleMap = _interopRequireDefault(require_elementRoleMap());
    var _roleElementMap = _interopRequireDefault(require_roleElementMap());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var aria2 = exports.aria = _ariaPropsMap.default;
    var dom = exports.dom = _domMap.default;
    var roles = exports.roles = _rolesMap.default;
    var elementRoles2 = exports.elementRoles = _elementRoleMap.default;
    var roleElements = exports.roleElements = _roleElementMap.default;
  }
});

// node_modules/axobject-query/lib/util/iteratorProxy.js
var require_iteratorProxy2 = __commonJS({
  "node_modules/axobject-query/lib/util/iteratorProxy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function iteratorProxy() {
      var values = this;
      var index = 0;
      var iter = {
        "@@iterator": function iterator() {
          return iter;
        },
        next: function next2() {
          if (index < values.length) {
            var value = values[index];
            index = index + 1;
            return {
              done: false,
              value
            };
          } else {
            return {
              done: true
            };
          }
        }
      };
      return iter;
    }
    var _default = iteratorProxy;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/util/iterationDecorator.js
var require_iterationDecorator2 = __commonJS({
  "node_modules/axobject-query/lib/util/iterationDecorator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = iterationDecorator;
    var _iteratorProxy = _interopRequireDefault(require_iteratorProxy2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    function iterationDecorator(collection, entries) {
      if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
        Object.defineProperty(collection, Symbol.iterator, {
          value: _iteratorProxy.default.bind(entries)
        });
      }
      return collection;
    }
  }
});

// node_modules/axobject-query/lib/etc/objects/AbbrRole.js
var require_AbbrRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/AbbrRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AbbrRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "abbr"
        }
      }],
      type: "structure"
    };
    var _default = AbbrRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/AlertDialogRole.js
var require_AlertDialogRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/AlertDialogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AlertDialogRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "alertdialog"
        }
      }],
      type: "window"
    };
    var _default = AlertDialogRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/AlertRole.js
var require_AlertRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/AlertRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AlertRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "alert"
        }
      }],
      type: "structure"
    };
    var _default = AlertRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/AnnotationRole.js
var require_AnnotationRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/AnnotationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AnnotationRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = AnnotationRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ApplicationRole.js
var require_ApplicationRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ApplicationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ApplicationRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "application"
        }
      }],
      type: "window"
    };
    var _default = ApplicationRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ArticleRole.js
var require_ArticleRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ArticleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ArticleRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "article"
        }
      }, {
        module: "HTML",
        concept: {
          name: "article"
        }
      }],
      type: "structure"
    };
    var _default = ArticleRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/AudioRole.js
var require_AudioRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/AudioRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AudioRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "audio"
        }
      }],
      type: "widget"
    };
    var _default = AudioRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/BannerRole.js
var require_BannerRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/BannerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var BannerRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "banner"
        }
      }],
      type: "structure"
    };
    var _default = BannerRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/BlockquoteRole.js
var require_BlockquoteRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/BlockquoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var BlockquoteRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "blockquote"
        }
      }],
      type: "structure"
    };
    var _default = BlockquoteRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/BusyIndicatorRole.js
var require_BusyIndicatorRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/BusyIndicatorRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var BusyIndicatorRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          attributes: [{
            name: "aria-busy",
            value: "true"
          }]
        }
      }],
      type: "widget"
    };
    var _default = BusyIndicatorRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ButtonRole.js
var require_ButtonRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ButtonRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "button"
        }
      }, {
        module: "HTML",
        concept: {
          name: "button"
        }
      }],
      type: "widget"
    };
    var _default = ButtonRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/CanvasRole.js
var require_CanvasRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/CanvasRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var CanvasRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "canvas"
        }
      }],
      type: "widget"
    };
    var _default = CanvasRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/CaptionRole.js
var require_CaptionRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/CaptionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var CaptionRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "caption"
        }
      }],
      type: "structure"
    };
    var _default = CaptionRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/CellRole.js
var require_CellRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/CellRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var CellRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "cell"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "gridcell"
        }
      }, {
        module: "HTML",
        concept: {
          name: "td"
        }
      }],
      type: "widget"
    };
    var _default = CellRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/CheckBoxRole.js
var require_CheckBoxRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/CheckBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var CheckBoxRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "checkbox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "checkbox"
          }]
        }
      }],
      type: "widget"
    };
    var _default = CheckBoxRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ColorWellRole.js
var require_ColorWellRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ColorWellRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ColorWellRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "color"
          }]
        }
      }],
      type: "widget"
    };
    var _default = ColorWellRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ColumnHeaderRole.js
var require_ColumnHeaderRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ColumnHeaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ColumnHeaderRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "columnheader"
        }
      }, {
        module: "HTML",
        concept: {
          name: "th"
        }
      }],
      type: "widget"
    };
    var _default = ColumnHeaderRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ColumnRole.js
var require_ColumnRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ColumnRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ColumnRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = ColumnRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ComboBoxRole.js
var require_ComboBoxRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ComboBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ComboBoxRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "combobox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "select"
        }
      }],
      type: "widget"
    };
    var _default = ComboBoxRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ComplementaryRole.js
var require_ComplementaryRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ComplementaryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ComplementaryRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "complementary"
        }
      }],
      type: "structure"
    };
    var _default = ComplementaryRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ContentInfoRole.js
var require_ContentInfoRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ContentInfoRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ContentInfoRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "structureinfo"
        }
      }],
      type: "structure"
    };
    var _default = ContentInfoRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/DateRole.js
var require_DateRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/DateRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DateRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "date"
          }]
        }
      }],
      type: "widget"
    };
    var _default = DateRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/DateTimeRole.js
var require_DateTimeRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/DateTimeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DateTimeRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "datetime"
          }]
        }
      }],
      type: "widget"
    };
    var _default = DateTimeRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/DefinitionRole.js
var require_DefinitionRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/DefinitionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DefinitionRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "dfn"
        }
      }],
      type: "structure"
    };
    var _default = DefinitionRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/DescriptionListDetailRole.js
var require_DescriptionListDetailRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/DescriptionListDetailRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DescriptionListDetailRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "dd"
        }
      }],
      type: "structure"
    };
    var _default = DescriptionListDetailRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/DescriptionListRole.js
var require_DescriptionListRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/DescriptionListRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DescriptionListRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "dl"
        }
      }],
      type: "structure"
    };
    var _default = DescriptionListRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/DescriptionListTermRole.js
var require_DescriptionListTermRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/DescriptionListTermRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DescriptionListTermRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "dt"
        }
      }],
      type: "structure"
    };
    var _default = DescriptionListTermRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/DetailsRole.js
var require_DetailsRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/DetailsRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DetailsRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "details"
        }
      }],
      type: "structure"
    };
    var _default = DetailsRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/DialogRole.js
var require_DialogRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/DialogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DialogRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "dialog"
        }
      }, {
        module: "HTML",
        concept: {
          name: "dialog"
        }
      }],
      type: "window"
    };
    var _default = DialogRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/DirectoryRole.js
var require_DirectoryRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/DirectoryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DirectoryRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "directory"
        }
      }, {
        module: "HTML",
        concept: {
          name: "dir"
        }
      }],
      type: "structure"
    };
    var _default = DirectoryRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/DisclosureTriangleRole.js
var require_DisclosureTriangleRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/DisclosureTriangleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DisclosureTriangleRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          constraints: ["scoped to a details element"],
          name: "summary"
        }
      }],
      type: "widget"
    };
    var _default = DisclosureTriangleRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/DivRole.js
var require_DivRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/DivRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DivRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "div"
        }
      }],
      type: "generic"
    };
    var _default = DivRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/DocumentRole.js
var require_DocumentRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/DocumentRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DocumentRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "document"
        }
      }],
      type: "structure"
    };
    var _default = DocumentRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/EmbeddedObjectRole.js
var require_EmbeddedObjectRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/EmbeddedObjectRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var EmbeddedObjectRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "embed"
        }
      }],
      type: "widget"
    };
    var _default = EmbeddedObjectRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/FeedRole.js
var require_FeedRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/FeedRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FeedRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "feed"
        }
      }],
      type: "structure"
    };
    var _default = FeedRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/FigcaptionRole.js
var require_FigcaptionRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/FigcaptionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FigcaptionRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "figcaption"
        }
      }],
      type: "structure"
    };
    var _default = FigcaptionRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/FigureRole.js
var require_FigureRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/FigureRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FigureRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "figure"
        }
      }, {
        module: "HTML",
        concept: {
          name: "figure"
        }
      }],
      type: "structure"
    };
    var _default = FigureRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/FooterRole.js
var require_FooterRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/FooterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FooterRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "footer"
        }
      }],
      type: "structure"
    };
    var _default = FooterRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/FormRole.js
var require_FormRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/FormRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FormRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "form"
        }
      }, {
        module: "HTML",
        concept: {
          name: "form"
        }
      }],
      type: "structure"
    };
    var _default = FormRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/GridRole.js
var require_GridRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/GridRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var GridRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "grid"
        }
      }],
      type: "widget"
    };
    var _default = GridRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/GroupRole.js
var require_GroupRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/GroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var GroupRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "group"
        }
      }],
      type: "structure"
    };
    var _default = GroupRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/HeadingRole.js
var require_HeadingRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/HeadingRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var HeadingRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "heading"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h1"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h2"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h3"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h4"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h5"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h6"
        }
      }],
      type: "structure"
    };
    var _default = HeadingRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/IframePresentationalRole.js
var require_IframePresentationalRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/IframePresentationalRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var IframePresentationalRole = {
      relatedConcepts: [],
      type: "window"
    };
    var _default = IframePresentationalRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/IframeRole.js
var require_IframeRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/IframeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var IframeRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "iframe"
        }
      }],
      type: "window"
    };
    var _default = IframeRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/IgnoredRole.js
var require_IgnoredRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/IgnoredRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var IgnoredRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = IgnoredRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ImageMapLinkRole.js
var require_ImageMapLinkRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ImageMapLinkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ImageMapLinkRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = ImageMapLinkRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ImageMapRole.js
var require_ImageMapRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ImageMapRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ImageMapRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "img",
          attributes: [{
            name: "usemap"
          }]
        }
      }],
      type: "structure"
    };
    var _default = ImageMapRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ImageRole.js
var require_ImageRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ImageRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ImageRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "HTML",
        concept: {
          name: "img"
        }
      }],
      type: "structure"
    };
    var _default = ImageRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/InlineTextBoxRole.js
var require_InlineTextBoxRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/InlineTextBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var InlineTextBoxRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "input"
        }
      }],
      type: "widget"
    };
    var _default = InlineTextBoxRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/InputTimeRole.js
var require_InputTimeRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/InputTimeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var InputTimeRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "time"
          }]
        }
      }],
      type: "widget"
    };
    var _default = InputTimeRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/LabelRole.js
var require_LabelRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/LabelRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var LabelRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "label"
        }
      }],
      type: "structure"
    };
    var _default = LabelRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/LegendRole.js
var require_LegendRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/LegendRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var LegendRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "legend"
        }
      }],
      type: "structure"
    };
    var _default = LegendRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/LineBreakRole.js
var require_LineBreakRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/LineBreakRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var LineBreakRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "br"
        }
      }],
      type: "structure"
    };
    var _default = LineBreakRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/LinkRole.js
var require_LinkRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/LinkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var LinkRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "link"
        }
      }, {
        module: "HTML",
        concept: {
          name: "a",
          attributes: [{
            name: "href"
          }]
        }
      }],
      type: "widget"
    };
    var _default = LinkRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ListBoxOptionRole.js
var require_ListBoxOptionRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ListBoxOptionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ListBoxOptionRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "option"
        }
      }, {
        module: "HTML",
        concept: {
          name: "option"
        }
      }],
      type: "widget"
    };
    var _default = ListBoxOptionRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ListBoxRole.js
var require_ListBoxRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ListBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ListBoxRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "listbox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "datalist"
        }
      }, {
        module: "HTML",
        concept: {
          name: "select"
        }
      }],
      type: "widget"
    };
    var _default = ListBoxRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ListItemRole.js
var require_ListItemRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ListItemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ListItemRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "listitem"
        }
      }, {
        module: "HTML",
        concept: {
          name: "li"
        }
      }],
      type: "structure"
    };
    var _default = ListItemRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ListMarkerRole.js
var require_ListMarkerRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ListMarkerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ListMarkerRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = ListMarkerRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ListRole.js
var require_ListRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ListRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ListRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "list"
        }
      }, {
        module: "HTML",
        concept: {
          name: "ul"
        }
      }, {
        module: "HTML",
        concept: {
          name: "ol"
        }
      }],
      type: "structure"
    };
    var _default = ListRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/LogRole.js
var require_LogRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/LogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var LogRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "log"
        }
      }],
      type: "structure"
    };
    var _default = LogRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/MainRole.js
var require_MainRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/MainRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MainRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "main"
        }
      }, {
        module: "HTML",
        concept: {
          name: "main"
        }
      }],
      type: "structure"
    };
    var _default = MainRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/MarkRole.js
var require_MarkRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/MarkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MarkRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "mark"
        }
      }],
      type: "structure"
    };
    var _default = MarkRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/MarqueeRole.js
var require_MarqueeRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/MarqueeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MarqueeRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "marquee"
        }
      }, {
        module: "HTML",
        concept: {
          name: "marquee"
        }
      }],
      type: "structure"
    };
    var _default = MarqueeRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/MathRole.js
var require_MathRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/MathRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MathRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "math"
        }
      }],
      type: "structure"
    };
    var _default = MathRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/MenuBarRole.js
var require_MenuBarRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/MenuBarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuBarRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "menubar"
        }
      }],
      type: "structure"
    };
    var _default = MenuBarRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/MenuButtonRole.js
var require_MenuButtonRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/MenuButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuButtonRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = MenuButtonRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/MenuItemRole.js
var require_MenuItemRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/MenuItemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuItemRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "menuitem"
        }
      }, {
        module: "HTML",
        concept: {
          name: "menuitem"
        }
      }],
      type: "widget"
    };
    var _default = MenuItemRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/MenuItemCheckBoxRole.js
var require_MenuItemCheckBoxRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/MenuItemCheckBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuItemCheckBoxRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "menuitemcheckbox"
        }
      }],
      type: "widget"
    };
    var _default = MenuItemCheckBoxRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/MenuItemRadioRole.js
var require_MenuItemRadioRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/MenuItemRadioRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuItemRadioRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "menuitemradio"
        }
      }],
      type: "widget"
    };
    var _default = MenuItemRadioRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/MenuListOptionRole.js
var require_MenuListOptionRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/MenuListOptionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuListOptionRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = MenuListOptionRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/MenuListPopupRole.js
var require_MenuListPopupRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/MenuListPopupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuListPopupRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = MenuListPopupRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/MenuRole.js
var require_MenuRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/MenuRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "menu"
        }
      }, {
        module: "HTML",
        concept: {
          name: "menu"
        }
      }],
      type: "structure"
    };
    var _default = MenuRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/MeterRole.js
var require_MeterRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/MeterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MeterRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "meter"
        }
      }],
      type: "structure"
    };
    var _default = MeterRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/NavigationRole.js
var require_NavigationRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/NavigationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NavigationRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "navigation"
        }
      }, {
        module: "HTML",
        concept: {
          name: "nav"
        }
      }],
      type: "structure"
    };
    var _default = NavigationRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/NoneRole.js
var require_NoneRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/NoneRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NoneRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "none"
        }
      }],
      type: "structure"
    };
    var _default = NoneRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/NoteRole.js
var require_NoteRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/NoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NoteRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "note"
        }
      }],
      type: "structure"
    };
    var _default = NoteRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/OutlineRole.js
var require_OutlineRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/OutlineRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var OutlineRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = OutlineRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ParagraphRole.js
var require_ParagraphRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ParagraphRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ParagraphRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "p"
        }
      }],
      type: "structure"
    };
    var _default = ParagraphRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/PopUpButtonRole.js
var require_PopUpButtonRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/PopUpButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var PopUpButtonRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = PopUpButtonRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/PreRole.js
var require_PreRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/PreRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var PreRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "pre"
        }
      }],
      type: "structure"
    };
    var _default = PreRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/PresentationalRole.js
var require_PresentationalRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/PresentationalRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var PresentationalRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "presentation"
        }
      }],
      type: "structure"
    };
    var _default = PresentationalRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ProgressIndicatorRole.js
var require_ProgressIndicatorRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ProgressIndicatorRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ProgressIndicatorRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "progressbar"
        }
      }, {
        module: "HTML",
        concept: {
          name: "progress"
        }
      }],
      type: "structure"
    };
    var _default = ProgressIndicatorRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/RadioButtonRole.js
var require_RadioButtonRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/RadioButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RadioButtonRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "radio"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "radio"
          }]
        }
      }],
      type: "widget"
    };
    var _default = RadioButtonRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/RadioGroupRole.js
var require_RadioGroupRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/RadioGroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RadioGroupRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "radiogroup"
        }
      }],
      type: "structure"
    };
    var _default = RadioGroupRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/RegionRole.js
var require_RegionRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/RegionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RegionRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "region"
        }
      }],
      type: "structure"
    };
    var _default = RegionRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/RootWebAreaRole.js
var require_RootWebAreaRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/RootWebAreaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RootWebAreaRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = RootWebAreaRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/RowHeaderRole.js
var require_RowHeaderRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/RowHeaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RowHeaderRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "rowheader"
        }
      }, {
        module: "HTML",
        concept: {
          name: "th",
          attributes: [{
            name: "scope",
            value: "row"
          }]
        }
      }],
      type: "widget"
    };
    var _default = RowHeaderRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/RowRole.js
var require_RowRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/RowRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RowRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "row"
        }
      }, {
        module: "HTML",
        concept: {
          name: "tr"
        }
      }],
      type: "structure"
    };
    var _default = RowRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/RubyRole.js
var require_RubyRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/RubyRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RubyRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "ruby"
        }
      }],
      type: "structure"
    };
    var _default = RubyRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/RulerRole.js
var require_RulerRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/RulerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RulerRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = RulerRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ScrollAreaRole.js
var require_ScrollAreaRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ScrollAreaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ScrollAreaRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = ScrollAreaRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ScrollBarRole.js
var require_ScrollBarRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ScrollBarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ScrollBarRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "scrollbar"
        }
      }],
      type: "widget"
    };
    var _default = ScrollBarRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/SeamlessWebAreaRole.js
var require_SeamlessWebAreaRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/SeamlessWebAreaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SeamlessWebAreaRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = SeamlessWebAreaRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/SearchRole.js
var require_SearchRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/SearchRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SearchRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "search"
        }
      }],
      type: "structure"
    };
    var _default = SearchRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/SearchBoxRole.js
var require_SearchBoxRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/SearchBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SearchBoxRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "searchbox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "search"
          }]
        }
      }],
      type: "widget"
    };
    var _default = SearchBoxRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/SliderRole.js
var require_SliderRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/SliderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SliderRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "slider"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "range"
          }]
        }
      }],
      type: "widget"
    };
    var _default = SliderRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/SliderThumbRole.js
var require_SliderThumbRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/SliderThumbRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SliderThumbRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = SliderThumbRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/SpinButtonRole.js
var require_SpinButtonRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/SpinButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SpinButtonRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "spinbutton"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "number"
          }]
        }
      }],
      type: "widget"
    };
    var _default = SpinButtonRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/SpinButtonPartRole.js
var require_SpinButtonPartRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/SpinButtonPartRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SpinButtonPartRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = SpinButtonPartRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/SplitterRole.js
var require_SplitterRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/SplitterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SplitterRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "separator"
        }
      }],
      type: "widget"
    };
    var _default = SplitterRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/StaticTextRole.js
var require_StaticTextRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/StaticTextRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var StaticTextRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = StaticTextRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/StatusRole.js
var require_StatusRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/StatusRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var StatusRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "status"
        }
      }],
      type: "structure"
    };
    var _default = StatusRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/SVGRootRole.js
var require_SVGRootRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/SVGRootRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SVGRootRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = SVGRootRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/SwitchRole.js
var require_SwitchRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/SwitchRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SwitchRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "switch"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "checkbox"
          }]
        }
      }],
      type: "widget"
    };
    var _default = SwitchRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TabGroupRole.js
var require_TabGroupRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TabGroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TabGroupRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tablist"
        }
      }],
      type: "structure"
    };
    var _default = TabGroupRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TabRole.js
var require_TabRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TabRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TabRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tab"
        }
      }],
      type: "widget"
    };
    var _default = TabRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TableHeaderContainerRole.js
var require_TableHeaderContainerRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TableHeaderContainerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TableHeaderContainerRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = TableHeaderContainerRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TableRole.js
var require_TableRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TableRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TableRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "table"
        }
      }, {
        module: "HTML",
        concept: {
          name: "table"
        }
      }],
      type: "structure"
    };
    var _default = TableRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TabListRole.js
var require_TabListRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TabListRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TabListRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tablist"
        }
      }],
      type: "structure"
    };
    var _default = TabListRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TabPanelRole.js
var require_TabPanelRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TabPanelRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TabPanelRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tabpanel"
        }
      }],
      type: "structure"
    };
    var _default = TabPanelRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TermRole.js
var require_TermRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TermRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TermRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "term"
        }
      }],
      type: "structure"
    };
    var _default = TermRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TextAreaRole.js
var require_TextAreaRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TextAreaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TextAreaRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          attributes: [{
            name: "aria-multiline",
            value: "true"
          }],
          name: "textbox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "textarea"
        }
      }],
      type: "widget"
    };
    var _default = TextAreaRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TextFieldRole.js
var require_TextFieldRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TextFieldRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TextFieldRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "textbox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "text"
          }]
        }
      }],
      type: "widget"
    };
    var _default = TextFieldRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TimeRole.js
var require_TimeRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TimeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TimeRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "time"
        }
      }],
      type: "structure"
    };
    var _default = TimeRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TimerRole.js
var require_TimerRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TimerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TimerRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "timer"
        }
      }],
      type: "structure"
    };
    var _default = TimerRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ToggleButtonRole.js
var require_ToggleButtonRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ToggleButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ToggleButtonRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          attributes: [{
            name: "aria-pressed"
          }]
        }
      }],
      type: "widget"
    };
    var _default = ToggleButtonRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ToolbarRole.js
var require_ToolbarRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ToolbarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ToolbarRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "toolbar"
        }
      }],
      type: "structure"
    };
    var _default = ToolbarRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TreeRole.js
var require_TreeRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TreeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TreeRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tree"
        }
      }],
      type: "widget"
    };
    var _default = TreeRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TreeGridRole.js
var require_TreeGridRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TreeGridRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TreeGridRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "treegrid"
        }
      }],
      type: "widget"
    };
    var _default = TreeGridRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TreeItemRole.js
var require_TreeItemRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TreeItemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TreeItemRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "treeitem"
        }
      }],
      type: "widget"
    };
    var _default = TreeItemRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/UserInterfaceTooltipRole.js
var require_UserInterfaceTooltipRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/UserInterfaceTooltipRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var UserInterfaceTooltipRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tooltip"
        }
      }],
      type: "structure"
    };
    var _default = UserInterfaceTooltipRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/VideoRole.js
var require_VideoRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/VideoRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var VideoRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "video"
        }
      }],
      type: "widget"
    };
    var _default = VideoRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/WebAreaRole.js
var require_WebAreaRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/WebAreaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var WebAreaRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = WebAreaRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/WindowRole.js
var require_WindowRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/WindowRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var WindowRole = {
      relatedConcepts: [],
      type: "window"
    };
    var _default = WindowRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/AXObjectsMap.js
var require_AXObjectsMap = __commonJS({
  "node_modules/axobject-query/lib/AXObjectsMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator2());
    var _AbbrRole = _interopRequireDefault(require_AbbrRole());
    var _AlertDialogRole = _interopRequireDefault(require_AlertDialogRole());
    var _AlertRole = _interopRequireDefault(require_AlertRole());
    var _AnnotationRole = _interopRequireDefault(require_AnnotationRole());
    var _ApplicationRole = _interopRequireDefault(require_ApplicationRole());
    var _ArticleRole = _interopRequireDefault(require_ArticleRole());
    var _AudioRole = _interopRequireDefault(require_AudioRole());
    var _BannerRole = _interopRequireDefault(require_BannerRole());
    var _BlockquoteRole = _interopRequireDefault(require_BlockquoteRole());
    var _BusyIndicatorRole = _interopRequireDefault(require_BusyIndicatorRole());
    var _ButtonRole = _interopRequireDefault(require_ButtonRole());
    var _CanvasRole = _interopRequireDefault(require_CanvasRole());
    var _CaptionRole = _interopRequireDefault(require_CaptionRole());
    var _CellRole = _interopRequireDefault(require_CellRole());
    var _CheckBoxRole = _interopRequireDefault(require_CheckBoxRole());
    var _ColorWellRole = _interopRequireDefault(require_ColorWellRole());
    var _ColumnHeaderRole = _interopRequireDefault(require_ColumnHeaderRole());
    var _ColumnRole = _interopRequireDefault(require_ColumnRole());
    var _ComboBoxRole = _interopRequireDefault(require_ComboBoxRole());
    var _ComplementaryRole = _interopRequireDefault(require_ComplementaryRole());
    var _ContentInfoRole = _interopRequireDefault(require_ContentInfoRole());
    var _DateRole = _interopRequireDefault(require_DateRole());
    var _DateTimeRole = _interopRequireDefault(require_DateTimeRole());
    var _DefinitionRole = _interopRequireDefault(require_DefinitionRole());
    var _DescriptionListDetailRole = _interopRequireDefault(require_DescriptionListDetailRole());
    var _DescriptionListRole = _interopRequireDefault(require_DescriptionListRole());
    var _DescriptionListTermRole = _interopRequireDefault(require_DescriptionListTermRole());
    var _DetailsRole = _interopRequireDefault(require_DetailsRole());
    var _DialogRole = _interopRequireDefault(require_DialogRole());
    var _DirectoryRole = _interopRequireDefault(require_DirectoryRole());
    var _DisclosureTriangleRole = _interopRequireDefault(require_DisclosureTriangleRole());
    var _DivRole = _interopRequireDefault(require_DivRole());
    var _DocumentRole = _interopRequireDefault(require_DocumentRole());
    var _EmbeddedObjectRole = _interopRequireDefault(require_EmbeddedObjectRole());
    var _FeedRole = _interopRequireDefault(require_FeedRole());
    var _FigcaptionRole = _interopRequireDefault(require_FigcaptionRole());
    var _FigureRole = _interopRequireDefault(require_FigureRole());
    var _FooterRole = _interopRequireDefault(require_FooterRole());
    var _FormRole = _interopRequireDefault(require_FormRole());
    var _GridRole = _interopRequireDefault(require_GridRole());
    var _GroupRole = _interopRequireDefault(require_GroupRole());
    var _HeadingRole = _interopRequireDefault(require_HeadingRole());
    var _IframePresentationalRole = _interopRequireDefault(require_IframePresentationalRole());
    var _IframeRole = _interopRequireDefault(require_IframeRole());
    var _IgnoredRole = _interopRequireDefault(require_IgnoredRole());
    var _ImageMapLinkRole = _interopRequireDefault(require_ImageMapLinkRole());
    var _ImageMapRole = _interopRequireDefault(require_ImageMapRole());
    var _ImageRole = _interopRequireDefault(require_ImageRole());
    var _InlineTextBoxRole = _interopRequireDefault(require_InlineTextBoxRole());
    var _InputTimeRole = _interopRequireDefault(require_InputTimeRole());
    var _LabelRole = _interopRequireDefault(require_LabelRole());
    var _LegendRole = _interopRequireDefault(require_LegendRole());
    var _LineBreakRole = _interopRequireDefault(require_LineBreakRole());
    var _LinkRole = _interopRequireDefault(require_LinkRole());
    var _ListBoxOptionRole = _interopRequireDefault(require_ListBoxOptionRole());
    var _ListBoxRole = _interopRequireDefault(require_ListBoxRole());
    var _ListItemRole = _interopRequireDefault(require_ListItemRole());
    var _ListMarkerRole = _interopRequireDefault(require_ListMarkerRole());
    var _ListRole = _interopRequireDefault(require_ListRole());
    var _LogRole = _interopRequireDefault(require_LogRole());
    var _MainRole = _interopRequireDefault(require_MainRole());
    var _MarkRole = _interopRequireDefault(require_MarkRole());
    var _MarqueeRole = _interopRequireDefault(require_MarqueeRole());
    var _MathRole = _interopRequireDefault(require_MathRole());
    var _MenuBarRole = _interopRequireDefault(require_MenuBarRole());
    var _MenuButtonRole = _interopRequireDefault(require_MenuButtonRole());
    var _MenuItemRole = _interopRequireDefault(require_MenuItemRole());
    var _MenuItemCheckBoxRole = _interopRequireDefault(require_MenuItemCheckBoxRole());
    var _MenuItemRadioRole = _interopRequireDefault(require_MenuItemRadioRole());
    var _MenuListOptionRole = _interopRequireDefault(require_MenuListOptionRole());
    var _MenuListPopupRole = _interopRequireDefault(require_MenuListPopupRole());
    var _MenuRole = _interopRequireDefault(require_MenuRole());
    var _MeterRole = _interopRequireDefault(require_MeterRole());
    var _NavigationRole = _interopRequireDefault(require_NavigationRole());
    var _NoneRole = _interopRequireDefault(require_NoneRole());
    var _NoteRole = _interopRequireDefault(require_NoteRole());
    var _OutlineRole = _interopRequireDefault(require_OutlineRole());
    var _ParagraphRole = _interopRequireDefault(require_ParagraphRole());
    var _PopUpButtonRole = _interopRequireDefault(require_PopUpButtonRole());
    var _PreRole = _interopRequireDefault(require_PreRole());
    var _PresentationalRole = _interopRequireDefault(require_PresentationalRole());
    var _ProgressIndicatorRole = _interopRequireDefault(require_ProgressIndicatorRole());
    var _RadioButtonRole = _interopRequireDefault(require_RadioButtonRole());
    var _RadioGroupRole = _interopRequireDefault(require_RadioGroupRole());
    var _RegionRole = _interopRequireDefault(require_RegionRole());
    var _RootWebAreaRole = _interopRequireDefault(require_RootWebAreaRole());
    var _RowHeaderRole = _interopRequireDefault(require_RowHeaderRole());
    var _RowRole = _interopRequireDefault(require_RowRole());
    var _RubyRole = _interopRequireDefault(require_RubyRole());
    var _RulerRole = _interopRequireDefault(require_RulerRole());
    var _ScrollAreaRole = _interopRequireDefault(require_ScrollAreaRole());
    var _ScrollBarRole = _interopRequireDefault(require_ScrollBarRole());
    var _SeamlessWebAreaRole = _interopRequireDefault(require_SeamlessWebAreaRole());
    var _SearchRole = _interopRequireDefault(require_SearchRole());
    var _SearchBoxRole = _interopRequireDefault(require_SearchBoxRole());
    var _SliderRole = _interopRequireDefault(require_SliderRole());
    var _SliderThumbRole = _interopRequireDefault(require_SliderThumbRole());
    var _SpinButtonRole = _interopRequireDefault(require_SpinButtonRole());
    var _SpinButtonPartRole = _interopRequireDefault(require_SpinButtonPartRole());
    var _SplitterRole = _interopRequireDefault(require_SplitterRole());
    var _StaticTextRole = _interopRequireDefault(require_StaticTextRole());
    var _StatusRole = _interopRequireDefault(require_StatusRole());
    var _SVGRootRole = _interopRequireDefault(require_SVGRootRole());
    var _SwitchRole = _interopRequireDefault(require_SwitchRole());
    var _TabGroupRole = _interopRequireDefault(require_TabGroupRole());
    var _TabRole = _interopRequireDefault(require_TabRole());
    var _TableHeaderContainerRole = _interopRequireDefault(require_TableHeaderContainerRole());
    var _TableRole = _interopRequireDefault(require_TableRole());
    var _TabListRole = _interopRequireDefault(require_TabListRole());
    var _TabPanelRole = _interopRequireDefault(require_TabPanelRole());
    var _TermRole = _interopRequireDefault(require_TermRole());
    var _TextAreaRole = _interopRequireDefault(require_TextAreaRole());
    var _TextFieldRole = _interopRequireDefault(require_TextFieldRole());
    var _TimeRole = _interopRequireDefault(require_TimeRole());
    var _TimerRole = _interopRequireDefault(require_TimerRole());
    var _ToggleButtonRole = _interopRequireDefault(require_ToggleButtonRole());
    var _ToolbarRole = _interopRequireDefault(require_ToolbarRole());
    var _TreeRole = _interopRequireDefault(require_TreeRole());
    var _TreeGridRole = _interopRequireDefault(require_TreeGridRole());
    var _TreeItemRole = _interopRequireDefault(require_TreeItemRole());
    var _UserInterfaceTooltipRole = _interopRequireDefault(require_UserInterfaceTooltipRole());
    var _VideoRole = _interopRequireDefault(require_VideoRole());
    var _WebAreaRole = _interopRequireDefault(require_WebAreaRole());
    var _WindowRole = _interopRequireDefault(require_WindowRole());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set") return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    var AXObjects2 = [["AbbrRole", _AbbrRole.default], ["AlertDialogRole", _AlertDialogRole.default], ["AlertRole", _AlertRole.default], ["AnnotationRole", _AnnotationRole.default], ["ApplicationRole", _ApplicationRole.default], ["ArticleRole", _ArticleRole.default], ["AudioRole", _AudioRole.default], ["BannerRole", _BannerRole.default], ["BlockquoteRole", _BlockquoteRole.default], ["BusyIndicatorRole", _BusyIndicatorRole.default], ["ButtonRole", _ButtonRole.default], ["CanvasRole", _CanvasRole.default], ["CaptionRole", _CaptionRole.default], ["CellRole", _CellRole.default], ["CheckBoxRole", _CheckBoxRole.default], ["ColorWellRole", _ColorWellRole.default], ["ColumnHeaderRole", _ColumnHeaderRole.default], ["ColumnRole", _ColumnRole.default], ["ComboBoxRole", _ComboBoxRole.default], ["ComplementaryRole", _ComplementaryRole.default], ["ContentInfoRole", _ContentInfoRole.default], ["DateRole", _DateRole.default], ["DateTimeRole", _DateTimeRole.default], ["DefinitionRole", _DefinitionRole.default], ["DescriptionListDetailRole", _DescriptionListDetailRole.default], ["DescriptionListRole", _DescriptionListRole.default], ["DescriptionListTermRole", _DescriptionListTermRole.default], ["DetailsRole", _DetailsRole.default], ["DialogRole", _DialogRole.default], ["DirectoryRole", _DirectoryRole.default], ["DisclosureTriangleRole", _DisclosureTriangleRole.default], ["DivRole", _DivRole.default], ["DocumentRole", _DocumentRole.default], ["EmbeddedObjectRole", _EmbeddedObjectRole.default], ["FeedRole", _FeedRole.default], ["FigcaptionRole", _FigcaptionRole.default], ["FigureRole", _FigureRole.default], ["FooterRole", _FooterRole.default], ["FormRole", _FormRole.default], ["GridRole", _GridRole.default], ["GroupRole", _GroupRole.default], ["HeadingRole", _HeadingRole.default], ["IframePresentationalRole", _IframePresentationalRole.default], ["IframeRole", _IframeRole.default], ["IgnoredRole", _IgnoredRole.default], ["ImageMapLinkRole", _ImageMapLinkRole.default], ["ImageMapRole", _ImageMapRole.default], ["ImageRole", _ImageRole.default], ["InlineTextBoxRole", _InlineTextBoxRole.default], ["InputTimeRole", _InputTimeRole.default], ["LabelRole", _LabelRole.default], ["LegendRole", _LegendRole.default], ["LineBreakRole", _LineBreakRole.default], ["LinkRole", _LinkRole.default], ["ListBoxOptionRole", _ListBoxOptionRole.default], ["ListBoxRole", _ListBoxRole.default], ["ListItemRole", _ListItemRole.default], ["ListMarkerRole", _ListMarkerRole.default], ["ListRole", _ListRole.default], ["LogRole", _LogRole.default], ["MainRole", _MainRole.default], ["MarkRole", _MarkRole.default], ["MarqueeRole", _MarqueeRole.default], ["MathRole", _MathRole.default], ["MenuBarRole", _MenuBarRole.default], ["MenuButtonRole", _MenuButtonRole.default], ["MenuItemRole", _MenuItemRole.default], ["MenuItemCheckBoxRole", _MenuItemCheckBoxRole.default], ["MenuItemRadioRole", _MenuItemRadioRole.default], ["MenuListOptionRole", _MenuListOptionRole.default], ["MenuListPopupRole", _MenuListPopupRole.default], ["MenuRole", _MenuRole.default], ["MeterRole", _MeterRole.default], ["NavigationRole", _NavigationRole.default], ["NoneRole", _NoneRole.default], ["NoteRole", _NoteRole.default], ["OutlineRole", _OutlineRole.default], ["ParagraphRole", _ParagraphRole.default], ["PopUpButtonRole", _PopUpButtonRole.default], ["PreRole", _PreRole.default], ["PresentationalRole", _PresentationalRole.default], ["ProgressIndicatorRole", _ProgressIndicatorRole.default], ["RadioButtonRole", _RadioButtonRole.default], ["RadioGroupRole", _RadioGroupRole.default], ["RegionRole", _RegionRole.default], ["RootWebAreaRole", _RootWebAreaRole.default], ["RowHeaderRole", _RowHeaderRole.default], ["RowRole", _RowRole.default], ["RubyRole", _RubyRole.default], ["RulerRole", _RulerRole.default], ["ScrollAreaRole", _ScrollAreaRole.default], ["ScrollBarRole", _ScrollBarRole.default], ["SeamlessWebAreaRole", _SeamlessWebAreaRole.default], ["SearchRole", _SearchRole.default], ["SearchBoxRole", _SearchBoxRole.default], ["SliderRole", _SliderRole.default], ["SliderThumbRole", _SliderThumbRole.default], ["SpinButtonRole", _SpinButtonRole.default], ["SpinButtonPartRole", _SpinButtonPartRole.default], ["SplitterRole", _SplitterRole.default], ["StaticTextRole", _StaticTextRole.default], ["StatusRole", _StatusRole.default], ["SVGRootRole", _SVGRootRole.default], ["SwitchRole", _SwitchRole.default], ["TabGroupRole", _TabGroupRole.default], ["TabRole", _TabRole.default], ["TableHeaderContainerRole", _TableHeaderContainerRole.default], ["TableRole", _TableRole.default], ["TabListRole", _TabListRole.default], ["TabPanelRole", _TabPanelRole.default], ["TermRole", _TermRole.default], ["TextAreaRole", _TextAreaRole.default], ["TextFieldRole", _TextFieldRole.default], ["TimeRole", _TimeRole.default], ["TimerRole", _TimerRole.default], ["ToggleButtonRole", _ToggleButtonRole.default], ["ToolbarRole", _ToolbarRole.default], ["TreeRole", _TreeRole.default], ["TreeGridRole", _TreeGridRole.default], ["TreeItemRole", _TreeItemRole.default], ["UserInterfaceTooltipRole", _UserInterfaceTooltipRole.default], ["VideoRole", _VideoRole.default], ["WebAreaRole", _WebAreaRole.default], ["WindowRole", _WindowRole.default]];
    var AXObjectsMap = {
      entries: function entries() {
        return AXObjects2;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i = 0, _AXObjects = AXObjects2; _i < _AXObjects.length; _i++) {
          var _AXObjects$_i = _slicedToArray(_AXObjects[_i], 2), key2 = _AXObjects$_i[0], values = _AXObjects$_i[1];
          fn.call(thisArg, values, key2, AXObjects2);
        }
      },
      get: function get2(key2) {
        var item = AXObjects2.find(function(tuple) {
          return tuple[0] === key2 ? true : false;
        });
        return item && item[1];
      },
      has: function has(key2) {
        return !!AXObjectsMap.get(key2);
      },
      keys: function keys() {
        return AXObjects2.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return AXObjects2.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(AXObjectsMap, AXObjectsMap.entries());
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/AXObjectElementMap.js
var require_AXObjectElementMap = __commonJS({
  "node_modules/axobject-query/lib/AXObjectElementMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator2());
    var _AXObjectsMap = _interopRequireDefault(require_AXObjectsMap());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n2() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e2(_e2) {
            throw _e2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n2() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e2(_e3) {
        didErr = true;
        err = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set") return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var AXObjectElements = [];
    var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries());
    var _step;
    try {
      _loop = function _loop2() {
        var _step$value = _slicedToArray(_step.value, 2), name = _step$value[0], def = _step$value[1];
        var relatedConcepts = def.relatedConcepts;
        if (Array.isArray(relatedConcepts)) {
          relatedConcepts.forEach(function(relation) {
            if (relation.module === "HTML") {
              var concept = relation.concept;
              if (concept) {
                var index = AXObjectElements.findIndex(function(_ref5) {
                  var _ref6 = _slicedToArray(_ref5, 1), key2 = _ref6[0];
                  return key2 === name;
                });
                if (index === -1) {
                  AXObjectElements.push([name, []]);
                  index = AXObjectElements.length - 1;
                }
                AXObjectElements[index][1].push(concept);
              }
            }
          });
        }
      };
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        _loop();
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var _loop;
    var AXObjectElementMap = {
      entries: function entries() {
        return AXObjectElements;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i = 0, _AXObjectElements = AXObjectElements; _i < _AXObjectElements.length; _i++) {
          var _AXObjectElements$_i = _slicedToArray(_AXObjectElements[_i], 2), key2 = _AXObjectElements$_i[0], values = _AXObjectElements$_i[1];
          fn.call(thisArg, values, key2, AXObjectElements);
        }
      },
      get: function get2(key2) {
        var item = AXObjectElements.find(function(tuple) {
          return tuple[0] === key2 ? true : false;
        });
        return item && item[1];
      },
      has: function has(key2) {
        return !!AXObjectElementMap.get(key2);
      },
      keys: function keys() {
        return AXObjectElements.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return AXObjectElements.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(AXObjectElementMap, AXObjectElementMap.entries());
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/AXObjectRoleMap.js
var require_AXObjectRoleMap = __commonJS({
  "node_modules/axobject-query/lib/AXObjectRoleMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator2());
    var _AXObjectsMap = _interopRequireDefault(require_AXObjectsMap());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n2() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e2(_e2) {
            throw _e2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n2() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e2(_e3) {
        didErr = true;
        err = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set") return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var AXObjectRoleElements = [];
    var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries());
    var _step;
    try {
      _loop = function _loop2() {
        var _step$value = _slicedToArray(_step.value, 2), name = _step$value[0], def = _step$value[1];
        var relatedConcepts = def.relatedConcepts;
        if (Array.isArray(relatedConcepts)) {
          relatedConcepts.forEach(function(relation) {
            if (relation.module === "ARIA") {
              var concept = relation.concept;
              if (concept) {
                var index = AXObjectRoleElements.findIndex(function(_ref5) {
                  var _ref6 = _slicedToArray(_ref5, 1), key2 = _ref6[0];
                  return key2 === name;
                });
                if (index === -1) {
                  AXObjectRoleElements.push([name, []]);
                  index = AXObjectRoleElements.length - 1;
                }
                AXObjectRoleElements[index][1].push(concept);
              }
            }
          });
        }
      };
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        _loop();
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var _loop;
    var AXObjectRoleMap = {
      entries: function entries() {
        return AXObjectRoleElements;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i = 0, _AXObjectRoleElements = AXObjectRoleElements; _i < _AXObjectRoleElements.length; _i++) {
          var _AXObjectRoleElements2 = _slicedToArray(_AXObjectRoleElements[_i], 2), key2 = _AXObjectRoleElements2[0], values = _AXObjectRoleElements2[1];
          fn.call(thisArg, values, key2, AXObjectRoleElements);
        }
      },
      get: function get2(key2) {
        var item = AXObjectRoleElements.find(function(tuple) {
          return tuple[0] === key2 ? true : false;
        });
        return item && item[1];
      },
      has: function has(key2) {
        return !!AXObjectRoleMap.get(key2);
      },
      keys: function keys() {
        return AXObjectRoleElements.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return AXObjectRoleElements.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(AXObjectRoleMap, AXObjectRoleMap.entries());
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/elementAXObjectMap.js
var require_elementAXObjectMap = __commonJS({
  "node_modules/axobject-query/lib/elementAXObjectMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _AXObjectsMap = _interopRequireDefault(require_AXObjectsMap());
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n2() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e2(_e2) {
            throw _e2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n2() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e2(_e3) {
        didErr = true;
        err = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set") return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var elementAXObjects2 = [];
    var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries());
    var _step;
    try {
      _loop = function _loop2() {
        var _step$value = _slicedToArray(_step.value, 2), name = _step$value[0], def = _step$value[1];
        var relatedConcepts = def.relatedConcepts;
        if (Array.isArray(relatedConcepts)) {
          relatedConcepts.forEach(function(relation) {
            if (relation.module === "HTML") {
              var concept = relation.concept;
              if (concept != null) {
                var conceptStr = JSON.stringify(concept);
                var axObjects;
                var index = 0;
                for (; index < elementAXObjects2.length; index++) {
                  var key2 = elementAXObjects2[index][0];
                  if (JSON.stringify(key2) === conceptStr) {
                    axObjects = elementAXObjects2[index][1];
                    break;
                  }
                }
                if (!Array.isArray(axObjects)) {
                  axObjects = [];
                }
                var loc = axObjects.findIndex(function(item) {
                  return item === name;
                });
                if (loc === -1) {
                  axObjects.push(name);
                }
                if (index < elementAXObjects2.length) {
                  elementAXObjects2.splice(index, 1, [concept, axObjects]);
                } else {
                  elementAXObjects2.push([concept, axObjects]);
                }
              }
            }
          });
        }
      };
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        _loop();
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var _loop;
    function deepAxObjectModelRelationshipConceptAttributeCheck(a, b) {
      if (a === void 0 && b !== void 0) {
        return false;
      }
      if (a !== void 0 && b === void 0) {
        return false;
      }
      if (a !== void 0 && b !== void 0) {
        if (a.length != b.length) {
          return false;
        }
        for (var i = 0; i < a.length; i++) {
          if (b[i].name !== a[i].name || b[i].value !== a[i].value) {
            return false;
          }
        }
      }
      return true;
    }
    var elementAXObjectMap = {
      entries: function entries() {
        return elementAXObjects2;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i = 0, _elementAXObjects = elementAXObjects2; _i < _elementAXObjects.length; _i++) {
          var _elementAXObjects$_i = _slicedToArray(_elementAXObjects[_i], 2), key2 = _elementAXObjects$_i[0], values = _elementAXObjects$_i[1];
          fn.call(thisArg, values, key2, elementAXObjects2);
        }
      },
      get: function get2(key2) {
        var item = elementAXObjects2.find(function(tuple) {
          return key2.name === tuple[0].name && deepAxObjectModelRelationshipConceptAttributeCheck(key2.attributes, tuple[0].attributes);
        });
        return item && item[1];
      },
      has: function has(key2) {
        return !!elementAXObjectMap.get(key2);
      },
      keys: function keys() {
        return elementAXObjects2.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return elementAXObjects2.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(elementAXObjectMap, elementAXObjectMap.entries());
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/axobject-query/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.elementAXObjects = exports.AXObjects = exports.AXObjectRoles = exports.AXObjectElements = void 0;
    var _AXObjectElementMap = _interopRequireDefault(require_AXObjectElementMap());
    var _AXObjectRoleMap = _interopRequireDefault(require_AXObjectRoleMap());
    var _AXObjectsMap = _interopRequireDefault(require_AXObjectsMap());
    var _elementAXObjectMap = _interopRequireDefault(require_elementAXObjectMap());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var AXObjectElements = _AXObjectElementMap.default;
    exports.AXObjectElements = AXObjectElements;
    var AXObjectRoles2 = _AXObjectRoleMap.default;
    exports.AXObjectRoles = AXObjectRoles2;
    var AXObjects2 = _AXObjectsMap.default;
    exports.AXObjects = AXObjects2;
    var elementAXObjects2 = _elementAXObjectMap.default;
    exports.elementAXObjects = elementAXObjects2;
  }
});

// node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var require_sourcemap_codec_umd = __commonJS({
  "node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.sourcemapCodec = {}));
    })(exports, function(exports2) {
      "use strict";
      const comma = ",".charCodeAt(0);
      const semicolon = ";".charCodeAt(0);
      const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      const intToChar = new Uint8Array(64);
      const charToInt = new Uint8Array(128);
      for (let i = 0; i < chars.length; i++) {
        const c2 = chars.charCodeAt(i);
        intToChar[i] = c2;
        charToInt[c2] = i;
      }
      function decodeInteger(reader, relative) {
        let value = 0;
        let shift = 0;
        let integer = 0;
        do {
          const c2 = reader.next();
          integer = charToInt[c2];
          value |= (integer & 31) << shift;
          shift += 5;
        } while (integer & 32);
        const shouldNegate = value & 1;
        value >>>= 1;
        if (shouldNegate) {
          value = -2147483648 | -value;
        }
        return relative + value;
      }
      function encodeInteger(builder, num, relative) {
        let delta = num - relative;
        delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
        do {
          let clamped = delta & 31;
          delta >>>= 5;
          if (delta > 0)
            clamped |= 32;
          builder.write(intToChar[clamped]);
        } while (delta > 0);
        return num;
      }
      function hasMoreVlq(reader, max) {
        if (reader.pos >= max)
          return false;
        return reader.peek() !== comma;
      }
      const bufLength = 1024 * 16;
      const td = typeof TextDecoder !== "undefined" ? new TextDecoder() : typeof Buffer !== "undefined" ? {
        decode(buf) {
          const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
          return out.toString();
        }
      } : {
        decode(buf) {
          let out = "";
          for (let i = 0; i < buf.length; i++) {
            out += String.fromCharCode(buf[i]);
          }
          return out;
        }
      };
      class StringWriter {
        constructor() {
          this.pos = 0;
          this.out = "";
          this.buffer = new Uint8Array(bufLength);
        }
        write(v) {
          const { buffer } = this;
          buffer[this.pos++] = v;
          if (this.pos === bufLength) {
            this.out += td.decode(buffer);
            this.pos = 0;
          }
        }
        flush() {
          const { buffer, out, pos } = this;
          return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
        }
      }
      class StringReader {
        constructor(buffer) {
          this.pos = 0;
          this.buffer = buffer;
        }
        next() {
          return this.buffer.charCodeAt(this.pos++);
        }
        peek() {
          return this.buffer.charCodeAt(this.pos);
        }
        indexOf(char) {
          const { buffer, pos } = this;
          const idx = buffer.indexOf(char, pos);
          return idx === -1 ? buffer.length : idx;
        }
      }
      const EMPTY = [];
      function decodeOriginalScopes(input) {
        const { length } = input;
        const reader = new StringReader(input);
        const scopes = [];
        const stack = [];
        let line = 0;
        for (; reader.pos < length; reader.pos++) {
          line = decodeInteger(reader, line);
          const column = decodeInteger(reader, 0);
          if (!hasMoreVlq(reader, length)) {
            const last = stack.pop();
            last[2] = line;
            last[3] = column;
            continue;
          }
          const kind = decodeInteger(reader, 0);
          const fields = decodeInteger(reader, 0);
          const hasName = fields & 1;
          const scope = hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind];
          let vars = EMPTY;
          if (hasMoreVlq(reader, length)) {
            vars = [];
            do {
              const varsIndex = decodeInteger(reader, 0);
              vars.push(varsIndex);
            } while (hasMoreVlq(reader, length));
          }
          scope.vars = vars;
          scopes.push(scope);
          stack.push(scope);
        }
        return scopes;
      }
      function encodeOriginalScopes(scopes) {
        const writer = new StringWriter();
        for (let i = 0; i < scopes.length; ) {
          i = _encodeOriginalScopes(scopes, i, writer, [0]);
        }
        return writer.flush();
      }
      function _encodeOriginalScopes(scopes, index, writer, state) {
        const scope = scopes[index];
        const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;
        if (index > 0)
          writer.write(comma);
        state[0] = encodeInteger(writer, startLine, state[0]);
        encodeInteger(writer, startColumn, 0);
        encodeInteger(writer, kind, 0);
        const fields = scope.length === 6 ? 1 : 0;
        encodeInteger(writer, fields, 0);
        if (scope.length === 6)
          encodeInteger(writer, scope[5], 0);
        for (const v of vars) {
          encodeInteger(writer, v, 0);
        }
        for (index++; index < scopes.length; ) {
          const next2 = scopes[index];
          const { 0: l2, 1: c2 } = next2;
          if (l2 > endLine || l2 === endLine && c2 >= endColumn) {
            break;
          }
          index = _encodeOriginalScopes(scopes, index, writer, state);
        }
        writer.write(comma);
        state[0] = encodeInteger(writer, endLine, state[0]);
        encodeInteger(writer, endColumn, 0);
        return index;
      }
      function decodeGeneratedRanges(input) {
        const { length } = input;
        const reader = new StringReader(input);
        const ranges = [];
        const stack = [];
        let genLine = 0;
        let definitionSourcesIndex = 0;
        let definitionScopeIndex = 0;
        let callsiteSourcesIndex = 0;
        let callsiteLine = 0;
        let callsiteColumn = 0;
        let bindingLine = 0;
        let bindingColumn = 0;
        do {
          const semi = reader.indexOf(";");
          let genColumn = 0;
          for (; reader.pos < semi; reader.pos++) {
            genColumn = decodeInteger(reader, genColumn);
            if (!hasMoreVlq(reader, semi)) {
              const last = stack.pop();
              last[2] = genLine;
              last[3] = genColumn;
              continue;
            }
            const fields = decodeInteger(reader, 0);
            const hasDefinition = fields & 1;
            const hasCallsite = fields & 2;
            const hasScope = fields & 4;
            let callsite = null;
            let bindings = EMPTY;
            let range;
            if (hasDefinition) {
              const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);
              definitionScopeIndex = decodeInteger(reader, definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0);
              definitionSourcesIndex = defSourcesIndex;
              range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex];
            } else {
              range = [genLine, genColumn, 0, 0];
            }
            range.isScope = !!hasScope;
            if (hasCallsite) {
              const prevCsi = callsiteSourcesIndex;
              const prevLine = callsiteLine;
              callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);
              const sameSource = prevCsi === callsiteSourcesIndex;
              callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);
              callsiteColumn = decodeInteger(reader, sameSource && prevLine === callsiteLine ? callsiteColumn : 0);
              callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];
            }
            range.callsite = callsite;
            if (hasMoreVlq(reader, semi)) {
              bindings = [];
              do {
                bindingLine = genLine;
                bindingColumn = genColumn;
                const expressionsCount = decodeInteger(reader, 0);
                let expressionRanges;
                if (expressionsCount < -1) {
                  expressionRanges = [[decodeInteger(reader, 0)]];
                  for (let i = -1; i > expressionsCount; i--) {
                    const prevBl = bindingLine;
                    bindingLine = decodeInteger(reader, bindingLine);
                    bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);
                    const expression = decodeInteger(reader, 0);
                    expressionRanges.push([expression, bindingLine, bindingColumn]);
                  }
                } else {
                  expressionRanges = [[expressionsCount]];
                }
                bindings.push(expressionRanges);
              } while (hasMoreVlq(reader, semi));
            }
            range.bindings = bindings;
            ranges.push(range);
            stack.push(range);
          }
          genLine++;
          reader.pos = semi + 1;
        } while (reader.pos < length);
        return ranges;
      }
      function encodeGeneratedRanges(ranges) {
        if (ranges.length === 0)
          return "";
        const writer = new StringWriter();
        for (let i = 0; i < ranges.length; ) {
          i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);
        }
        return writer.flush();
      }
      function _encodeGeneratedRanges(ranges, index, writer, state) {
        const range = ranges[index];
        const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, isScope, callsite, bindings } = range;
        if (state[0] < startLine) {
          catchupLine(writer, state[0], startLine);
          state[0] = startLine;
          state[1] = 0;
        } else if (index > 0) {
          writer.write(comma);
        }
        state[1] = encodeInteger(writer, range[1], state[1]);
        const fields = (range.length === 6 ? 1 : 0) | (callsite ? 2 : 0) | (isScope ? 4 : 0);
        encodeInteger(writer, fields, 0);
        if (range.length === 6) {
          const { 4: sourcesIndex, 5: scopesIndex } = range;
          if (sourcesIndex !== state[2]) {
            state[3] = 0;
          }
          state[2] = encodeInteger(writer, sourcesIndex, state[2]);
          state[3] = encodeInteger(writer, scopesIndex, state[3]);
        }
        if (callsite) {
          const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite;
          if (sourcesIndex !== state[4]) {
            state[5] = 0;
            state[6] = 0;
          } else if (callLine !== state[5]) {
            state[6] = 0;
          }
          state[4] = encodeInteger(writer, sourcesIndex, state[4]);
          state[5] = encodeInteger(writer, callLine, state[5]);
          state[6] = encodeInteger(writer, callColumn, state[6]);
        }
        if (bindings) {
          for (const binding of bindings) {
            if (binding.length > 1)
              encodeInteger(writer, -binding.length, 0);
            const expression = binding[0][0];
            encodeInteger(writer, expression, 0);
            let bindingStartLine = startLine;
            let bindingStartColumn = startColumn;
            for (let i = 1; i < binding.length; i++) {
              const expRange = binding[i];
              bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);
              bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);
              encodeInteger(writer, expRange[0], 0);
            }
          }
        }
        for (index++; index < ranges.length; ) {
          const next2 = ranges[index];
          const { 0: l2, 1: c2 } = next2;
          if (l2 > endLine || l2 === endLine && c2 >= endColumn) {
            break;
          }
          index = _encodeGeneratedRanges(ranges, index, writer, state);
        }
        if (state[0] < endLine) {
          catchupLine(writer, state[0], endLine);
          state[0] = endLine;
          state[1] = 0;
        } else {
          writer.write(comma);
        }
        state[1] = encodeInteger(writer, endColumn, state[1]);
        return index;
      }
      function catchupLine(writer, lastLine, line) {
        do {
          writer.write(semicolon);
        } while (++lastLine < line);
      }
      function decode(mappings) {
        const { length } = mappings;
        const reader = new StringReader(mappings);
        const decoded = [];
        let genColumn = 0;
        let sourcesIndex = 0;
        let sourceLine = 0;
        let sourceColumn = 0;
        let namesIndex = 0;
        do {
          const semi = reader.indexOf(";");
          const line = [];
          let sorted = true;
          let lastCol = 0;
          genColumn = 0;
          while (reader.pos < semi) {
            let seg;
            genColumn = decodeInteger(reader, genColumn);
            if (genColumn < lastCol)
              sorted = false;
            lastCol = genColumn;
            if (hasMoreVlq(reader, semi)) {
              sourcesIndex = decodeInteger(reader, sourcesIndex);
              sourceLine = decodeInteger(reader, sourceLine);
              sourceColumn = decodeInteger(reader, sourceColumn);
              if (hasMoreVlq(reader, semi)) {
                namesIndex = decodeInteger(reader, namesIndex);
                seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];
              } else {
                seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];
              }
            } else {
              seg = [genColumn];
            }
            line.push(seg);
            reader.pos++;
          }
          if (!sorted)
            sort(line);
          decoded.push(line);
          reader.pos = semi + 1;
        } while (reader.pos <= length);
        return decoded;
      }
      function sort(line) {
        line.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[0] - b[0];
      }
      function encode3(decoded) {
        const writer = new StringWriter();
        let sourcesIndex = 0;
        let sourceLine = 0;
        let sourceColumn = 0;
        let namesIndex = 0;
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          if (i > 0)
            writer.write(semicolon);
          if (line.length === 0)
            continue;
          let genColumn = 0;
          for (let j = 0; j < line.length; j++) {
            const segment = line[j];
            if (j > 0)
              writer.write(comma);
            genColumn = encodeInteger(writer, segment[0], genColumn);
            if (segment.length === 1)
              continue;
            sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
            sourceLine = encodeInteger(writer, segment[2], sourceLine);
            sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
            if (segment.length === 4)
              continue;
            namesIndex = encodeInteger(writer, segment[4], namesIndex);
          }
        }
        return writer.flush();
      }
      exports2.decode = decode;
      exports2.decodeGeneratedRanges = decodeGeneratedRanges;
      exports2.decodeOriginalScopes = decodeOriginalScopes;
      exports2.encode = encode3;
      exports2.encodeGeneratedRanges = encodeGeneratedRanges;
      exports2.encodeOriginalScopes = encodeOriginalScopes;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var require_resolve_uri_umd = __commonJS({
  "node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.resolveURI = factory());
    })(exports, function() {
      "use strict";
      const schemeRegex = /^[\w+.-]+:\/\//;
      const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
      const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      function isAbsoluteUrl(input) {
        return schemeRegex.test(input);
      }
      function isSchemeRelativeUrl(input) {
        return input.startsWith("//");
      }
      function isAbsolutePath(input) {
        return input.startsWith("/");
      }
      function isFileUrl(input) {
        return input.startsWith("file:");
      }
      function isRelative(input) {
        return /^[.?#]/.test(input);
      }
      function parseAbsoluteUrl(input) {
        const match = urlRegex.exec(input);
        return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
      }
      function parseFileUrl(input) {
        const match = fileRegex.exec(input);
        const path11 = match[2];
        return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path11) ? path11 : "/" + path11, match[3] || "", match[4] || "");
      }
      function makeUrl(scheme, user, host, port, path11, query, hash2) {
        return {
          scheme,
          user,
          host,
          port,
          path: path11,
          query,
          hash: hash2,
          type: 7
        };
      }
      function parseUrl(input) {
        if (isSchemeRelativeUrl(input)) {
          const url2 = parseAbsoluteUrl("http:" + input);
          url2.scheme = "";
          url2.type = 6;
          return url2;
        }
        if (isAbsolutePath(input)) {
          const url2 = parseAbsoluteUrl("http://foo.com" + input);
          url2.scheme = "";
          url2.host = "";
          url2.type = 5;
          return url2;
        }
        if (isFileUrl(input))
          return parseFileUrl(input);
        if (isAbsoluteUrl(input))
          return parseAbsoluteUrl(input);
        const url = parseAbsoluteUrl("http://foo.com/" + input);
        url.scheme = "";
        url.host = "";
        url.type = input ? input.startsWith("?") ? 3 : input.startsWith("#") ? 2 : 4 : 1;
        return url;
      }
      function stripPathFilename(path11) {
        if (path11.endsWith("/.."))
          return path11;
        const index = path11.lastIndexOf("/");
        return path11.slice(0, index + 1);
      }
      function mergePaths(url, base) {
        normalizePath(base, base.type);
        if (url.path === "/") {
          url.path = base.path;
        } else {
          url.path = stripPathFilename(base.path) + url.path;
        }
      }
      function normalizePath(url, type) {
        const rel = type <= 4;
        const pieces = url.path.split("/");
        let pointer = 1;
        let positive = 0;
        let addTrailingSlash = false;
        for (let i = 1; i < pieces.length; i++) {
          const piece = pieces[i];
          if (!piece) {
            addTrailingSlash = true;
            continue;
          }
          addTrailingSlash = false;
          if (piece === ".")
            continue;
          if (piece === "..") {
            if (positive) {
              addTrailingSlash = true;
              positive--;
              pointer--;
            } else if (rel) {
              pieces[pointer++] = piece;
            }
            continue;
          }
          pieces[pointer++] = piece;
          positive++;
        }
        let path11 = "";
        for (let i = 1; i < pointer; i++) {
          path11 += "/" + pieces[i];
        }
        if (!path11 || addTrailingSlash && !path11.endsWith("/..")) {
          path11 += "/";
        }
        url.path = path11;
      }
      function resolve(input, base) {
        if (!input && !base)
          return "";
        const url = parseUrl(input);
        let inputType = url.type;
        if (base && inputType !== 7) {
          const baseUrl = parseUrl(base);
          const baseType = baseUrl.type;
          switch (inputType) {
            case 1:
              url.hash = baseUrl.hash;
            case 2:
              url.query = baseUrl.query;
            case 3:
            case 4:
              mergePaths(url, baseUrl);
            case 5:
              url.user = baseUrl.user;
              url.host = baseUrl.host;
              url.port = baseUrl.port;
            case 6:
              url.scheme = baseUrl.scheme;
          }
          if (baseType > inputType)
            inputType = baseType;
        }
        normalizePath(url, inputType);
        const queryHash = url.query + url.hash;
        switch (inputType) {
          case 2:
          case 3:
            return queryHash;
          case 4: {
            const path11 = url.path.slice(1);
            if (!path11)
              return queryHash || ".";
            if (isRelative(base || input) && !isRelative(path11)) {
              return "./" + path11 + queryHash;
            }
            return path11 + queryHash;
          }
          case 5:
            return url.path + queryHash;
          default:
            return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
        }
      }
      return resolve;
    });
  }
});

// node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var require_trace_mapping_umd = __commonJS({
  "node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_sourcemap_codec_umd(), require_resolve_uri_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/sourcemap-codec", "@jridgewell/resolve-uri"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.traceMapping = {}, global.sourcemapCodec, global.resolveURI));
    })(exports, function(exports2, sourcemapCodec, resolveUri) {
      "use strict";
      function resolve(input, base) {
        if (base && !base.endsWith("/"))
          base += "/";
        return resolveUri(input, base);
      }
      function stripFilename(path11) {
        if (!path11)
          return "";
        const index = path11.lastIndexOf("/");
        return path11.slice(0, index + 1);
      }
      const COLUMN = 0;
      const SOURCES_INDEX = 1;
      const SOURCE_LINE = 2;
      const SOURCE_COLUMN = 3;
      const NAMES_INDEX = 4;
      const REV_GENERATED_LINE = 1;
      const REV_GENERATED_COLUMN = 2;
      function maybeSort(mappings, owned) {
        const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
        if (unsortedIndex === mappings.length)
          return mappings;
        if (!owned)
          mappings = mappings.slice();
        for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
          mappings[i] = sortSegments(mappings[i], owned);
        }
        return mappings;
      }
      function nextUnsortedSegmentLine(mappings, start) {
        for (let i = start; i < mappings.length; i++) {
          if (!isSorted(mappings[i]))
            return i;
        }
        return mappings.length;
      }
      function isSorted(line) {
        for (let j = 1; j < line.length; j++) {
          if (line[j][COLUMN] < line[j - 1][COLUMN]) {
            return false;
          }
        }
        return true;
      }
      function sortSegments(line, owned) {
        if (!owned)
          line = line.slice();
        return line.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[COLUMN] - b[COLUMN];
      }
      let found = false;
      function binarySearch(haystack, needle, low, high) {
        while (low <= high) {
          const mid = low + (high - low >> 1);
          const cmp = haystack[mid][COLUMN] - needle;
          if (cmp === 0) {
            found = true;
            return mid;
          }
          if (cmp < 0) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
        found = false;
        return low - 1;
      }
      function upperBound(haystack, needle, index) {
        for (let i = index + 1; i < haystack.length; index = i++) {
          if (haystack[i][COLUMN] !== needle)
            break;
        }
        return index;
      }
      function lowerBound(haystack, needle, index) {
        for (let i = index - 1; i >= 0; index = i--) {
          if (haystack[i][COLUMN] !== needle)
            break;
        }
        return index;
      }
      function memoizedState() {
        return {
          lastKey: -1,
          lastNeedle: -1,
          lastIndex: -1
        };
      }
      function memoizedBinarySearch(haystack, needle, state, key2) {
        const { lastKey, lastNeedle, lastIndex } = state;
        let low = 0;
        let high = haystack.length - 1;
        if (key2 === lastKey) {
          if (needle === lastNeedle) {
            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
            return lastIndex;
          }
          if (needle >= lastNeedle) {
            low = lastIndex === -1 ? 0 : lastIndex;
          } else {
            high = lastIndex;
          }
        }
        state.lastKey = key2;
        state.lastNeedle = needle;
        return state.lastIndex = binarySearch(haystack, needle, low, high);
      }
      function buildBySources(decoded, memos) {
        const sources = memos.map(buildNullArray);
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            if (seg.length === 1)
              continue;
            const sourceIndex2 = seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            const originalSource = sources[sourceIndex2];
            const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);
            const memo = memos[sourceIndex2];
            let index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));
            memo.lastIndex = ++index;
            insert(originalLine, index, [sourceColumn, i, seg[COLUMN]]);
          }
        }
        return sources;
      }
      function insert(array2, index, value) {
        for (let i = array2.length; i > index; i--) {
          array2[i] = array2[i - 1];
        }
        array2[index] = value;
      }
      function buildNullArray() {
        return { __proto__: null };
      }
      const AnyMap = function(map, mapUrl) {
        const parsed = parse6(map);
        if (!("sections" in parsed)) {
          return new TraceMap(parsed, mapUrl);
        }
        const mappings = [];
        const sources = [];
        const sourcesContent = [];
        const names = [];
        const ignoreList = [];
        recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, ignoreList, 0, 0, Infinity, Infinity);
        const joined = {
          version: 3,
          file: parsed.file,
          names,
          sources,
          sourcesContent,
          mappings,
          ignoreList
        };
        return presortedDecodedMap(joined);
      };
      function parse6(map) {
        return typeof map === "string" ? JSON.parse(map) : map;
      }
      function recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        const { sections } = input;
        for (let i = 0; i < sections.length; i++) {
          const { map, offset: offset2 } = sections[i];
          let sl = stopLine;
          let sc = stopColumn;
          if (i + 1 < sections.length) {
            const nextOffset = sections[i + 1].offset;
            sl = Math.min(stopLine, lineOffset + nextOffset.line);
            if (sl === stopLine) {
              sc = Math.min(stopColumn, columnOffset + nextOffset.column);
            } else if (sl < stopLine) {
              sc = columnOffset + nextOffset.column;
            }
          }
          addSection(map, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset + offset2.line, columnOffset + offset2.column, sl, sc);
        }
      }
      function addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        const parsed = parse6(input);
        if ("sections" in parsed)
          return recurse(...arguments);
        const map = new TraceMap(parsed, mapUrl);
        const sourcesOffset = sources.length;
        const namesOffset = names.length;
        const decoded = decodedMappings(map);
        const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;
        append(sources, resolvedSources);
        append(names, map.names);
        if (contents)
          append(sourcesContent, contents);
        else
          for (let i = 0; i < resolvedSources.length; i++)
            sourcesContent.push(null);
        if (ignores)
          for (let i = 0; i < ignores.length; i++)
            ignoreList.push(ignores[i] + sourcesOffset);
        for (let i = 0; i < decoded.length; i++) {
          const lineI = lineOffset + i;
          if (lineI > stopLine)
            return;
          const out = getLine(mappings, lineI);
          const cOffset = i === 0 ? columnOffset : 0;
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const column = cOffset + seg[COLUMN];
            if (lineI === stopLine && column >= stopColumn)
              return;
            if (seg.length === 1) {
              out.push([column]);
              continue;
            }
            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            out.push(seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);
          }
        }
      }
      function append(arr, other) {
        for (let i = 0; i < other.length; i++)
          arr.push(other[i]);
      }
      function getLine(arr, index) {
        for (let i = arr.length; i <= index; i++)
          arr[i] = [];
        return arr[index];
      }
      const LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
      const COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
      const LEAST_UPPER_BOUND = -1;
      const GREATEST_LOWER_BOUND = 1;
      class TraceMap {
        constructor(map, mapUrl) {
          const isString = typeof map === "string";
          if (!isString && map._decodedMemo)
            return map;
          const parsed = isString ? JSON.parse(map) : map;
          const { version: version2, file, names, sourceRoot, sources, sourcesContent } = parsed;
          this.version = version2;
          this.file = file;
          this.names = names || [];
          this.sourceRoot = sourceRoot;
          this.sources = sources;
          this.sourcesContent = sourcesContent;
          this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
          const from = resolve(sourceRoot || "", stripFilename(mapUrl));
          this.resolvedSources = sources.map((s) => resolve(s || "", from));
          const { mappings } = parsed;
          if (typeof mappings === "string") {
            this._encoded = mappings;
            this._decoded = void 0;
          } else {
            this._encoded = void 0;
            this._decoded = maybeSort(mappings, isString);
          }
          this._decodedMemo = memoizedState();
          this._bySources = void 0;
          this._bySourceMemos = void 0;
        }
      }
      function cast(map) {
        return map;
      }
      function encodedMappings(map) {
        var _a2;
        var _b;
        return (_a2 = (_b = cast(map))._encoded) !== null && _a2 !== void 0 ? _a2 : _b._encoded = sourcemapCodec.encode(cast(map)._decoded);
      }
      function decodedMappings(map) {
        var _a2;
        return (_a2 = cast(map))._decoded || (_a2._decoded = sourcemapCodec.decode(cast(map)._encoded));
      }
      function traceSegment(map, line, column) {
        const decoded = decodedMappings(map);
        if (line >= decoded.length)
          return null;
        const segments = decoded[line];
        const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, GREATEST_LOWER_BOUND);
        return index === -1 ? null : segments[index];
      }
      function originalPositionFor(map, needle) {
        let { line, column, bias } = needle;
        line--;
        if (line < 0)
          throw new Error(LINE_GTR_ZERO);
        if (column < 0)
          throw new Error(COL_GTR_EQ_ZERO);
        const decoded = decodedMappings(map);
        if (line >= decoded.length)
          return OMapping(null, null, null, null);
        const segments = decoded[line];
        const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
        if (index === -1)
          return OMapping(null, null, null, null);
        const segment = segments[index];
        if (segment.length === 1)
          return OMapping(null, null, null, null);
        const { names, resolvedSources } = map;
        return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
      }
      function generatedPositionFor(map, needle) {
        const { source: source2, line, column, bias } = needle;
        return generatedPosition(map, source2, line, column, bias || GREATEST_LOWER_BOUND, false);
      }
      function allGeneratedPositionsFor(map, needle) {
        const { source: source2, line, column, bias } = needle;
        return generatedPosition(map, source2, line, column, bias || LEAST_UPPER_BOUND, true);
      }
      function eachMapping(map, cb) {
        const decoded = decodedMappings(map);
        const { names, resolvedSources } = map;
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const generatedLine = i + 1;
            const generatedColumn = seg[0];
            let source2 = null;
            let originalLine = null;
            let originalColumn = null;
            let name = null;
            if (seg.length !== 1) {
              source2 = resolvedSources[seg[1]];
              originalLine = seg[2] + 1;
              originalColumn = seg[3];
            }
            if (seg.length === 5)
              name = names[seg[4]];
            cb({
              generatedLine,
              generatedColumn,
              source: source2,
              originalLine,
              originalColumn,
              name
            });
          }
        }
      }
      function sourceIndex(map, source2) {
        const { sources, resolvedSources } = map;
        let index = sources.indexOf(source2);
        if (index === -1)
          index = resolvedSources.indexOf(source2);
        return index;
      }
      function sourceContentFor(map, source2) {
        const { sourcesContent } = map;
        if (sourcesContent == null)
          return null;
        const index = sourceIndex(map, source2);
        return index === -1 ? null : sourcesContent[index];
      }
      function isIgnored(map, source2) {
        const { ignoreList } = map;
        if (ignoreList == null)
          return false;
        const index = sourceIndex(map, source2);
        return index === -1 ? false : ignoreList.includes(index);
      }
      function presortedDecodedMap(map, mapUrl) {
        const tracer = new TraceMap(clone(map, []), mapUrl);
        cast(tracer)._decoded = map.mappings;
        return tracer;
      }
      function decodedMap(map) {
        return clone(map, decodedMappings(map));
      }
      function encodedMap(map) {
        return clone(map, encodedMappings(map));
      }
      function clone(map, mappings) {
        return {
          version: map.version,
          file: map.file,
          names: map.names,
          sourceRoot: map.sourceRoot,
          sources: map.sources,
          sourcesContent: map.sourcesContent,
          mappings,
          ignoreList: map.ignoreList || map.x_google_ignoreList
        };
      }
      function OMapping(source2, line, column, name) {
        return { source: source2, line, column, name };
      }
      function GMapping(line, column) {
        return { line, column };
      }
      function traceSegmentInternal(segments, memo, line, column, bias) {
        let index = memoizedBinarySearch(segments, column, memo, line);
        if (found) {
          index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
        } else if (bias === LEAST_UPPER_BOUND)
          index++;
        if (index === -1 || index === segments.length)
          return -1;
        return index;
      }
      function sliceGeneratedPositions(segments, memo, line, column, bias) {
        let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);
        if (!found && bias === LEAST_UPPER_BOUND)
          min++;
        if (min === -1 || min === segments.length)
          return [];
        const matchedColumn = found ? column : segments[min][COLUMN];
        if (!found)
          min = lowerBound(segments, matchedColumn, min);
        const max = upperBound(segments, matchedColumn, min);
        const result = [];
        for (; min <= max; min++) {
          const segment = segments[min];
          result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
        }
        return result;
      }
      function generatedPosition(map, source2, line, column, bias, all) {
        var _a2;
        line--;
        if (line < 0)
          throw new Error(LINE_GTR_ZERO);
        if (column < 0)
          throw new Error(COL_GTR_EQ_ZERO);
        const { sources, resolvedSources } = map;
        let sourceIndex2 = sources.indexOf(source2);
        if (sourceIndex2 === -1)
          sourceIndex2 = resolvedSources.indexOf(source2);
        if (sourceIndex2 === -1)
          return all ? [] : GMapping(null, null);
        const generated = (_a2 = cast(map))._bySources || (_a2._bySources = buildBySources(decodedMappings(map), cast(map)._bySourceMemos = sources.map(memoizedState)));
        const segments = generated[sourceIndex2][line];
        if (segments == null)
          return all ? [] : GMapping(null, null);
        const memo = cast(map)._bySourceMemos[sourceIndex2];
        if (all)
          return sliceGeneratedPositions(segments, memo, line, column, bias);
        const index = traceSegmentInternal(segments, memo, line, column, bias);
        if (index === -1)
          return GMapping(null, null);
        const segment = segments[index];
        return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
      }
      exports2.AnyMap = AnyMap;
      exports2.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND;
      exports2.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND;
      exports2.TraceMap = TraceMap;
      exports2.allGeneratedPositionsFor = allGeneratedPositionsFor;
      exports2.decodedMap = decodedMap;
      exports2.decodedMappings = decodedMappings;
      exports2.eachMapping = eachMapping;
      exports2.encodedMap = encodedMap;
      exports2.encodedMappings = encodedMappings;
      exports2.generatedPositionFor = generatedPositionFor;
      exports2.isIgnored = isIgnored;
      exports2.originalPositionFor = originalPositionFor;
      exports2.presortedDecodedMap = presortedDecodedMap;
      exports2.sourceContentFor = sourceContentFor;
      exports2.traceSegment = traceSegment;
    });
  }
});

// node_modules/@jridgewell/set-array/dist/set-array.umd.js
var require_set_array_umd = __commonJS({
  "node_modules/@jridgewell/set-array/dist/set-array.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.setArray = {}));
    })(exports, function(exports2) {
      "use strict";
      class SetArray {
        constructor() {
          this._indexes = { __proto__: null };
          this.array = [];
        }
      }
      function cast(set2) {
        return set2;
      }
      function get2(setarr, key2) {
        return cast(setarr)._indexes[key2];
      }
      function put(setarr, key2) {
        const index = get2(setarr, key2);
        if (index !== void 0)
          return index;
        const { array: array2, _indexes: indexes } = cast(setarr);
        const length = array2.push(key2);
        return indexes[key2] = length - 1;
      }
      function pop(setarr) {
        const { array: array2, _indexes: indexes } = cast(setarr);
        if (array2.length === 0)
          return;
        const last = array2.pop();
        indexes[last] = void 0;
      }
      function remove(setarr, key2) {
        const index = get2(setarr, key2);
        if (index === void 0)
          return;
        const { array: array2, _indexes: indexes } = cast(setarr);
        for (let i = index + 1; i < array2.length; i++) {
          const k = array2[i];
          array2[i - 1] = k;
          indexes[k]--;
        }
        indexes[key2] = void 0;
        array2.pop();
      }
      exports2.SetArray = SetArray;
      exports2.get = get2;
      exports2.pop = pop;
      exports2.put = put;
      exports2.remove = remove;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
var require_gen_mapping_umd = __commonJS({
  "node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_set_array_umd(), require_sourcemap_codec_umd(), require_trace_mapping_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/set-array", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.genMapping = {}, global.setArray, global.sourcemapCodec, global.traceMapping));
    })(exports, function(exports2, setArray, sourcemapCodec, traceMapping) {
      "use strict";
      const COLUMN = 0;
      const SOURCES_INDEX = 1;
      const SOURCE_LINE = 2;
      const SOURCE_COLUMN = 3;
      const NAMES_INDEX = 4;
      const NO_NAME = -1;
      class GenMapping {
        constructor({ file, sourceRoot } = {}) {
          this._names = new setArray.SetArray();
          this._sources = new setArray.SetArray();
          this._sourcesContent = [];
          this._mappings = [];
          this.file = file;
          this.sourceRoot = sourceRoot;
          this._ignoreList = new setArray.SetArray();
        }
      }
      function cast(map) {
        return map;
      }
      function addSegment(map, genLine, genColumn, source2, sourceLine, sourceColumn, name, content) {
        return addSegmentInternal(false, map, genLine, genColumn, source2, sourceLine, sourceColumn, name, content);
      }
      function addMapping(map, mapping) {
        return addMappingInternal(false, map, mapping);
      }
      const maybeAddSegment = (map, genLine, genColumn, source2, sourceLine, sourceColumn, name, content) => {
        return addSegmentInternal(true, map, genLine, genColumn, source2, sourceLine, sourceColumn, name, content);
      };
      const maybeAddMapping = (map, mapping) => {
        return addMappingInternal(true, map, mapping);
      };
      function setSourceContent(map, source2, content) {
        const { _sources: sources, _sourcesContent: sourcesContent } = cast(map);
        const index = setArray.put(sources, source2);
        sourcesContent[index] = content;
      }
      function setIgnore(map, source2, ignore = true) {
        const { _sources: sources, _sourcesContent: sourcesContent, _ignoreList: ignoreList } = cast(map);
        const index = setArray.put(sources, source2);
        if (index === sourcesContent.length)
          sourcesContent[index] = null;
        if (ignore)
          setArray.put(ignoreList, index);
        else
          setArray.remove(ignoreList, index);
      }
      function toDecodedMap(map) {
        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, _ignoreList: ignoreList } = cast(map);
        removeEmptyFinalLines(mappings);
        return {
          version: 3,
          file: map.file || void 0,
          names: names.array,
          sourceRoot: map.sourceRoot || void 0,
          sources: sources.array,
          sourcesContent,
          mappings,
          ignoreList: ignoreList.array
        };
      }
      function toEncodedMap(map) {
        const decoded = toDecodedMap(map);
        return Object.assign(Object.assign({}, decoded), { mappings: sourcemapCodec.encode(decoded.mappings) });
      }
      function fromMap(input) {
        const map = new traceMapping.TraceMap(input);
        const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });
        putAll(cast(gen)._names, map.names);
        putAll(cast(gen)._sources, map.sources);
        cast(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);
        cast(gen)._mappings = traceMapping.decodedMappings(map);
        if (map.ignoreList)
          putAll(cast(gen)._ignoreList, map.ignoreList);
        return gen;
      }
      function allMappings(map) {
        const out = [];
        const { _mappings: mappings, _sources: sources, _names: names } = cast(map);
        for (let i = 0; i < mappings.length; i++) {
          const line = mappings[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const generated = { line: i + 1, column: seg[COLUMN] };
            let source2 = void 0;
            let original = void 0;
            let name = void 0;
            if (seg.length !== 1) {
              source2 = sources.array[seg[SOURCES_INDEX]];
              original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };
              if (seg.length === 5)
                name = names.array[seg[NAMES_INDEX]];
            }
            out.push({ generated, source: source2, original, name });
          }
        }
        return out;
      }
      function addSegmentInternal(skipable, map, genLine, genColumn, source2, sourceLine, sourceColumn, name, content) {
        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = cast(map);
        const line = getLine(mappings, genLine);
        const index = getColumnIndex(line, genColumn);
        if (!source2) {
          if (skipable && skipSourceless(line, index))
            return;
          return insert(line, index, [genColumn]);
        }
        const sourcesIndex = setArray.put(sources, source2);
        const namesIndex = name ? setArray.put(names, name) : NO_NAME;
        if (sourcesIndex === sourcesContent.length)
          sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;
        if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
          return;
        }
        return insert(line, index, name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
      }
      function getLine(mappings, index) {
        for (let i = mappings.length; i <= index; i++) {
          mappings[i] = [];
        }
        return mappings[index];
      }
      function getColumnIndex(line, genColumn) {
        let index = line.length;
        for (let i = index - 1; i >= 0; index = i--) {
          const current2 = line[i];
          if (genColumn >= current2[COLUMN])
            break;
        }
        return index;
      }
      function insert(array2, index, value) {
        for (let i = array2.length; i > index; i--) {
          array2[i] = array2[i - 1];
        }
        array2[index] = value;
      }
      function removeEmptyFinalLines(mappings) {
        const { length } = mappings;
        let len = length;
        for (let i = len - 1; i >= 0; len = i, i--) {
          if (mappings[i].length > 0)
            break;
        }
        if (len < length)
          mappings.length = len;
      }
      function putAll(setarr, array2) {
        for (let i = 0; i < array2.length; i++)
          setArray.put(setarr, array2[i]);
      }
      function skipSourceless(line, index) {
        if (index === 0)
          return true;
        const prev = line[index - 1];
        return prev.length === 1;
      }
      function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
        if (index === 0)
          return false;
        const prev = line[index - 1];
        if (prev.length === 1)
          return false;
        return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
      }
      function addMappingInternal(skipable, map, mapping) {
        const { generated, source: source2, original, name, content } = mapping;
        if (!source2) {
          return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
        }
        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, source2, original.line - 1, original.column, name, content);
      }
      exports2.GenMapping = GenMapping;
      exports2.addMapping = addMapping;
      exports2.addSegment = addSegment;
      exports2.allMappings = allMappings;
      exports2.fromMap = fromMap;
      exports2.maybeAddMapping = maybeAddMapping;
      exports2.maybeAddSegment = maybeAddSegment;
      exports2.setIgnore = setIgnore;
      exports2.setSourceContent = setSourceContent;
      exports2.toDecodedMap = toDecodedMap;
      exports2.toEncodedMap = toEncodedMap;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/@ampproject/remapping/dist/remapping.umd.js
var require_remapping_umd = __commonJS({
  "node_modules/@ampproject/remapping/dist/remapping.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory(require_trace_mapping_umd(), require_gen_mapping_umd()) : typeof define === "function" && define.amd ? define(["@jridgewell/trace-mapping", "@jridgewell/gen-mapping"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.remapping = factory(global.traceMapping, global.genMapping));
    })(exports, function(traceMapping, genMapping) {
      "use strict";
      const SOURCELESS_MAPPING = SegmentObject("", -1, -1, "", null, false);
      const EMPTY_SOURCES = [];
      function SegmentObject(source2, line, column, name, content, ignore) {
        return { source: source2, line, column, name, content, ignore };
      }
      function Source(map, sources, source2, content, ignore) {
        return {
          map,
          sources,
          source: source2,
          content,
          ignore
        };
      }
      function MapSource(map, sources) {
        return Source(map, sources, "", null, false);
      }
      function OriginalSource(source2, content, ignore) {
        return Source(null, EMPTY_SOURCES, source2, content, ignore);
      }
      function traceMappings(tree) {
        const gen = new genMapping.GenMapping({ file: tree.map.file });
        const { sources: rootSources, map } = tree;
        const rootNames = map.names;
        const rootMappings = traceMapping.decodedMappings(map);
        for (let i = 0; i < rootMappings.length; i++) {
          const segments = rootMappings[i];
          for (let j = 0; j < segments.length; j++) {
            const segment = segments[j];
            const genCol = segment[0];
            let traced = SOURCELESS_MAPPING;
            if (segment.length !== 1) {
              const source3 = rootSources[segment[1]];
              traced = originalPositionFor(source3, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : "");
              if (traced == null)
                continue;
            }
            const { column, line, name, content, source: source2, ignore } = traced;
            genMapping.maybeAddSegment(gen, i, genCol, source2, line, column, name);
            if (source2 && content != null)
              genMapping.setSourceContent(gen, source2, content);
            if (ignore)
              genMapping.setIgnore(gen, source2, true);
          }
        }
        return gen;
      }
      function originalPositionFor(source2, line, column, name) {
        if (!source2.map) {
          return SegmentObject(source2.source, line, column, name, source2.content, source2.ignore);
        }
        const segment = traceMapping.traceSegment(source2.map, line, column);
        if (segment == null)
          return null;
        if (segment.length === 1)
          return SOURCELESS_MAPPING;
        return originalPositionFor(source2.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source2.map.names[segment[4]] : name);
      }
      function asArray(value) {
        if (Array.isArray(value))
          return value;
        return [value];
      }
      function buildSourceMapTree(input, loader) {
        const maps = asArray(input).map((m) => new traceMapping.TraceMap(m, ""));
        const map = maps.pop();
        for (let i = 0; i < maps.length; i++) {
          if (maps[i].sources.length > 1) {
            throw new Error(`Transformation map ${i} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
          }
        }
        let tree = build(map, loader, "", 0);
        for (let i = maps.length - 1; i >= 0; i--) {
          tree = MapSource(maps[i], [tree]);
        }
        return tree;
      }
      function build(map, loader, importer, importerDepth) {
        const { resolvedSources, sourcesContent, ignoreList } = map;
        const depth = importerDepth + 1;
        const children = resolvedSources.map((sourceFile, i) => {
          const ctx = {
            importer,
            depth,
            source: sourceFile || "",
            content: void 0,
            ignore: void 0
          };
          const sourceMap = loader(ctx.source, ctx);
          const { source: source2, content, ignore } = ctx;
          if (sourceMap)
            return build(new traceMapping.TraceMap(sourceMap, source2), loader, source2, depth);
          const sourceContent = content !== void 0 ? content : sourcesContent ? sourcesContent[i] : null;
          const ignored = ignore !== void 0 ? ignore : ignoreList ? ignoreList.includes(i) : false;
          return OriginalSource(source2, sourceContent, ignored);
        });
        return MapSource(map, children);
      }
      class SourceMap2 {
        constructor(map, options) {
          const out = options.decodedMappings ? genMapping.toDecodedMap(map) : genMapping.toEncodedMap(map);
          this.version = out.version;
          this.file = out.file;
          this.mappings = out.mappings;
          this.names = out.names;
          this.ignoreList = out.ignoreList;
          this.sourceRoot = out.sourceRoot;
          this.sources = out.sources;
          if (!options.excludeContent) {
            this.sourcesContent = out.sourcesContent;
          }
        }
        toString() {
          return JSON.stringify(this);
        }
      }
      function remapping2(input, loader, options) {
        const opts = typeof options === "object" ? options : { excludeContent: !!options, decodedMappings: false };
        const tree = buildSourceMapTree(input, loader);
        return new SourceMap2(traceMappings(tree), opts);
      }
      return remapping2;
    });
  }
});

// node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "node_modules/deepmerge/dist/cjs.js"(exports, module) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge2(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source2, options) {
      return target.concat(source2).map(function(element2) {
        return cloneUnlessOtherwiseSpecified(element2, options);
      });
    }
    function getMergeFunction(key2, options) {
      if (!options.customMerge) {
        return deepmerge2;
      }
      var customMerge = options.customMerge(key2);
      return typeof customMerge === "function" ? customMerge : deepmerge2;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object4, property) {
      try {
        return property in object4;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key2) {
      return propertyIsOnObject(target, key2) && !(Object.hasOwnProperty.call(target, key2) && Object.propertyIsEnumerable.call(target, key2));
    }
    function mergeObject(target, source2, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key2) {
          destination[key2] = cloneUnlessOtherwiseSpecified(target[key2], options);
        });
      }
      getKeys(source2).forEach(function(key2) {
        if (propertyIsUnsafe(target, key2)) {
          return;
        }
        if (propertyIsOnObject(target, key2) && options.isMergeableObject(source2[key2])) {
          destination[key2] = getMergeFunction(key2, options)(target[key2], source2[key2], options);
        } else {
          destination[key2] = cloneUnlessOtherwiseSpecified(source2[key2], options);
        }
      });
      return destination;
    }
    function deepmerge2(target, source2, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source2);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source2, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source2, options);
      } else {
        return mergeObject(target, source2, options);
      }
    }
    deepmerge2.all = function deepmergeAll(array2, options) {
      if (!Array.isArray(array2)) {
        throw new Error("first argument should be an array");
      }
      return array2.reduce(function(prev, next2) {
        return deepmerge2(prev, next2, options);
      }, {});
    };
    var deepmerge_1 = deepmerge2;
    module.exports = deepmerge_1;
  }
});

// node_modules/vitefu/src/sync.cjs
var require_sync = __commonJS({
  "node_modules/vitefu/src/sync.cjs"(exports, module) {
    function isDepIncluded2(dep, optimizeDepsInclude) {
      return optimizeDepsInclude.some((id2) => parseIncludeStr(id2) === dep);
    }
    function isDepExcluded2(dep, optimizeDepsExclude) {
      dep = parseIncludeStr(dep);
      return optimizeDepsExclude.some(
        (id2) => id2 === dep || dep.startsWith(`${id2}/`)
      );
    }
    function isDepNoExternaled2(dep, ssrNoExternal) {
      if (ssrNoExternal === true) {
        return true;
      } else {
        return isMatch(dep, ssrNoExternal);
      }
    }
    function isDepExternaled2(dep, ssrExternal) {
      if (ssrExternal === true) {
        return false;
      } else {
        return ssrExternal.includes(dep);
      }
    }
    function parseIncludeStr(raw) {
      const lastArrow = raw.lastIndexOf(">");
      return lastArrow === -1 ? raw : raw.slice(lastArrow + 1).trim();
    }
    function isMatch(target, pattern) {
      if (Array.isArray(pattern)) {
        return pattern.some((p) => isMatch(target, p));
      } else if (typeof pattern === "string") {
        return target === pattern;
      } else if (pattern instanceof RegExp) {
        return pattern.test(target);
      }
    }
    module.exports = {
      isDepIncluded: isDepIncluded2,
      isDepExcluded: isDepExcluded2,
      isDepNoExternaled: isDepNoExternaled2,
      isDepExternaled: isDepExternaled2
    };
  }
});

// node_modules/@sveltejs/vite-plugin-svelte/src/index.js
var import_node_fs10 = __toESM(require_node_fs());
var import_node_process7 = __toESM(require_node_process());

// node_modules/@sveltejs/vite-plugin-svelte-inspector/src/index.js
var import_node_fs = __toESM(require_node_fs());
var import_node_path = __toESM(require_node_path());
var import_node_url = __toESM(require_node_url());

// node_modules/@sveltejs/vite-plugin-svelte-inspector/src/debug.js
var import_debug = __toESM(require_browser(), 1);
var debug = (0, import_debug.default)("vite-plugin-svelte-inspector");

// node_modules/@sveltejs/vite-plugin-svelte-inspector/src/options.js
var import_node_process = __toESM(require_node_process(), 1);
var defaultInspectorOptions = {
  toggleKeyCombo: "alt-x",
  navKeys: { parent: "ArrowUp", child: "ArrowDown", next: "ArrowRight", prev: "ArrowLeft" },
  escapeKeys: ["Backspace", "Escape"],
  openKey: "Enter",
  holdMode: true,
  showToggleButton: "active",
  toggleButtonPos: "top-right",
  customStyles: true
};
function parseEnvironmentOptions(config) {
  const env = loadEnv(config.mode, config.envDir ?? import_node_process.default.cwd(), "SVELTE_INSPECTOR");
  const options = env == null ? void 0 : env.SVELTE_INSPECTOR_OPTIONS;
  const toggle = env == null ? void 0 : env.SVELTE_INSPECTOR_TOGGLE;
  if (options) {
    try {
      const parsed = JSON.parse(options);
      const parsedType = typeof parsed;
      if (parsedType === "boolean") {
        return parsed;
      } else if (parsedType === "object") {
        if (Array.isArray(parsed)) {
          throw new Error("invalid type, expected object map but got array");
        }
        const parsedKeys = Object.keys(parsed);
        const defaultKeys = Object.keys(defaultInspectorOptions);
        const unknownKeys = parsedKeys.filter((k) => !defaultKeys.includes(k));
        if (unknownKeys.length) {
          config.logger.warn(
            `[vite-plugin-svelte-inspector] ignoring unknown options in environment SVELTE_INSPECTOR_OPTIONS: ${unknownKeys.join(
              ", "
            )}`
          );
          for (const key2 of unknownKeys) {
            delete parsed[key2];
          }
        }
        debug("loaded environment config", parsed);
        return parsed;
      }
    } catch (e2) {
      config.logger.error(
        `[vite-plugin-svelte-inspector] failed to parse inspector options from environment SVELTE_INSPECTOR_OPTIONS="${options}"
${e2}`
      );
    }
  } else if (toggle) {
    const keyConfig = {
      toggleKeyCombo: toggle
    };
    debug("loaded environment config", keyConfig);
    return keyConfig;
  }
}

// node_modules/@sveltejs/vite-plugin-svelte-inspector/src/utils.js
var postfixRE = /[?#].*$/s;
function cleanUrl(url) {
  return url.replace(postfixRE, "");
}

// node_modules/@sveltejs/vite-plugin-svelte-inspector/src/index.js
function getInspectorPath() {
  const pluginPath = normalizePath$3(import_node_path.default.dirname((0, import_node_url.fileURLToPath)(import.meta.url)));
  return pluginPath.replace(
    /\/vite-plugin-svelte-inspector\/src$/,
    "/vite-plugin-svelte-inspector/src/runtime/"
  );
}
function svelteInspector(options) {
  const inspectorPath = getInspectorPath();
  debug(`svelte inspector path: ${inspectorPath}`);
  let viteConfig;
  let inspectorOptions;
  let disabled = false;
  return {
    name: "vite-plugin-svelte-inspector",
    apply: "serve",
    enforce: "pre",
    configResolved(config) {
      var _a2, _b, _c;
      viteConfig = config;
      const environmentOptions = parseEnvironmentOptions(config);
      if (environmentOptions === false) {
        debug("environment options set to false, inspector disabled");
        disabled = true;
        return;
      }
      const vps = config.plugins.find((p) => p.name === "vite-plugin-svelte");
      const configFileOptions = (_b = (_a2 = vps == null ? void 0 : vps.api) == null ? void 0 : _a2.options) == null ? void 0 : _b.inspector;
      if (vps && !options && !configFileOptions && !environmentOptions) {
        debug("vite-plugin-svelte didn't pass options, inspector disabled");
        disabled = true;
        return;
      }
      if (environmentOptions === true) {
        inspectorOptions = defaultInspectorOptions;
      } else {
        inspectorOptions = {
          ...defaultInspectorOptions,
          ...configFileOptions,
          ...options,
          ...environmentOptions || {}
        };
      }
      inspectorOptions.__internal = {
        base: ((_c = config.base) == null ? void 0 : _c.replace(/\/$/, "")) || ""
      };
    },
    async resolveId(importee, _, options2) {
      if ((options2 == null ? void 0 : options2.ssr) || disabled) {
        return;
      }
      if (importee.startsWith("virtual:svelte-inspector-options")) {
        return importee;
      } else if (importee.startsWith("virtual:svelte-inspector-path:")) {
        return importee.replace("virtual:svelte-inspector-path:", inspectorPath);
      }
    },
    async load(id2, options2) {
      if ((options2 == null ? void 0 : options2.ssr) || disabled) {
        return;
      }
      if (id2 === "virtual:svelte-inspector-options") {
        return `export default ${JSON.stringify(inspectorOptions ?? {})}`;
      } else if (id2.startsWith(inspectorPath)) {
        const file = cleanUrl(id2);
        if (import_node_fs.default.existsSync(id2)) {
          return await import_node_fs.default.promises.readFile(file, "utf-8");
        } else {
          viteConfig.logger.error(
            `[vite-plugin-svelte-inspector] failed to find svelte-inspector: ${id2}`
          );
        }
      }
    },
    transform(code, id2, options2) {
      if ((options2 == null ? void 0 : options2.ssr) || disabled) {
        return;
      }
      if (id2.includes("vite/dist/client/client.mjs")) {
        return { code: `${code}
import('virtual:svelte-inspector-path:load-inspector.js')` };
      }
    }
  };
}

// node_modules/kleur/colors.mjs
var FORCE_COLOR;
var NODE_DISABLE_COLORS;
var NO_COLOR;
var TERM;
var isTTY = true;
if (typeof process !== "undefined") {
  ({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});
  isTTY = process.stdout && process.stdout.isTTY;
}
var $ = {
  enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== "dumb" && (FORCE_COLOR != null && FORCE_COLOR !== "0" || isTTY)
};
function init(x, y) {
  let rgx = new RegExp(`\\x1b\\[${y}m`, "g");
  let open2 = `\x1B[${x}m`, close2 = `\x1B[${y}m`;
  return function(txt) {
    if (!$.enabled || txt == null) return txt;
    return open2 + (!!~("" + txt).indexOf(close2) ? txt.replace(rgx, close2 + open2) : txt) + close2;
  };
}
var reset = init(0, 0);
var bold = init(1, 22);
var dim = init(2, 22);
var italic = init(3, 23);
var underline = init(4, 24);
var inverse = init(7, 27);
var hidden = init(8, 28);
var strikethrough = init(9, 29);
var black = init(30, 39);
var red = init(31, 39);
var green = init(32, 39);
var yellow = init(33, 39);
var blue = init(34, 39);
var magenta = init(35, 39);
var cyan = init(36, 39);
var white = init(37, 39);
var gray = init(90, 39);
var grey = init(90, 39);
var bgBlack = init(40, 49);
var bgRed = init(41, 49);
var bgGreen = init(42, 49);
var bgYellow = init(43, 49);
var bgBlue = init(44, 49);
var bgMagenta = init(45, 49);
var bgCyan = init(46, 49);
var bgWhite = init(47, 49);

// node_modules/@sveltejs/vite-plugin-svelte/src/utils/log.js
var import_debug4 = __toESM(require_browser(), 1);
var levels = ["debug", "info", "warn", "error", "silent"];
var prefix = "vite-plugin-svelte";
var loggers = {
  debug: {
    log: (0, import_debug4.default)(`${prefix}`),
    enabled: false,
    isDebug: true
  },
  info: {
    color: cyan,
    log: console.log,
    enabled: true
  },
  warn: {
    color: yellow,
    log: console.warn,
    enabled: true
  },
  error: {
    color: red,
    log: console.error,
    enabled: true
  },
  silent: {
    enabled: false
  }
};
var _level = "info";
function setLevel(level) {
  if (level === _level) {
    return;
  }
  const levelIndex = levels.indexOf(level);
  if (levelIndex > -1) {
    _level = level;
    for (let i = 0; i < levels.length; i++) {
      loggers[levels[i]].enabled = i >= levelIndex;
    }
  } else {
    _log(loggers.error, `invalid log level: ${level} `);
  }
}
function _log(logger, message, payload, namespace) {
  if (!logger.enabled) {
    return;
  }
  if (logger.isDebug) {
    let log2 = logger.log;
    if (namespace) {
      if (!isDebugNamespaceEnabled(namespace)) {
        return;
      }
      log2 = logger.log.extend(namespace);
    }
    if (payload !== void 0) {
      log2(message, payload);
    } else {
      log2(message);
    }
  } else {
    logger.log(
      logger.color(
        `${(/* @__PURE__ */ new Date()).toLocaleTimeString()} [${prefix}${namespace ? `:${namespace}` : ""}] ${message}`
      )
    );
    if (payload) {
      logger.log(payload);
    }
  }
}
function createLogger(level) {
  const logger = loggers[level];
  const logFn = (
    /** @type {import('../types/log.d.ts').LogFn} */
    _log.bind(null, logger)
  );
  const logged = /* @__PURE__ */ new Set();
  const once = function(message, payload, namespace) {
    if (!logger.enabled || logged.has(message)) {
      return;
    }
    logged.add(message);
    logFn.apply(null, [message, payload, namespace]);
  };
  Object.defineProperty(logFn, "enabled", {
    get() {
      return logger.enabled;
    }
  });
  Object.defineProperty(logFn, "once", {
    get() {
      return once;
    }
  });
  return logFn;
}
var log = {
  debug: createLogger("debug"),
  info: createLogger("info"),
  warn: createLogger("warn"),
  error: createLogger("error"),
  setLevel
};
function logCompilerWarnings(svelteRequest, warnings2, options) {
  var _a2, _b, _c;
  const { emitCss, onwarn, isBuild } = options;
  const sendViaWS = !isBuild && ((_a2 = options.experimental) == null ? void 0 : _a2.sendWarningsToBrowser);
  let warn = isBuild ? warnBuild : warnDev;
  const handledByDefaultWarn = [];
  const notIgnored = warnings2 == null ? void 0 : warnings2.filter((w2) => !ignoreCompilerWarning(w2, isBuild, emitCss));
  const extra = buildExtraWarnings(warnings2, isBuild);
  const allWarnings = [...notIgnored, ...extra];
  if (sendViaWS) {
    const _warn = warn;
    warn = (w2) => {
      handledByDefaultWarn.push(w2);
      _warn(w2);
    };
  }
  allWarnings.forEach((warning) => {
    if (onwarn) {
      onwarn(warning, warn);
    } else {
      warn(warning);
    }
  });
  if (sendViaWS) {
    const message = {
      id: svelteRequest.id,
      filename: svelteRequest.filename,
      normalizedFilename: svelteRequest.normalizedFilename,
      timestamp: svelteRequest.timestamp,
      warnings: handledByDefaultWarn,
      // allWarnings filtered by warnings where onwarn did not call the default handler
      allWarnings,
      // includes warnings filtered by onwarn and our extra vite plugin svelte warnings
      rawWarnings: warnings2
      // raw compiler output
    };
    log.debug(`sending svelte:warnings message for ${svelteRequest.normalizedFilename}`);
    (_c = (_b = options.server) == null ? void 0 : _b.ws) == null ? void 0 : _c.send("svelte:warnings", message);
  }
}
function ignoreCompilerWarning(warning, isBuild, emitCss) {
  return !emitCss && warning.code === "css_unused_selector" || // same as rollup-plugin-svelte
  !isBuild && isNoScopableElementWarning(warning);
}
function isNoScopableElementWarning(warning) {
  return warning.code === "css_unused_selector" && warning.message.includes('"*"');
}
function buildExtraWarnings(warnings2, isBuild) {
  const extraWarnings = [];
  if (!isBuild) {
    const noScopableElementWarnings = warnings2.filter((w2) => isNoScopableElementWarning(w2));
    if (noScopableElementWarnings.length > 0) {
      const noScopableElementWarning = noScopableElementWarnings[noScopableElementWarnings.length - 1];
      extraWarnings.push({
        ...noScopableElementWarning,
        code: "vite-plugin-svelte-css-no-scopable-elements",
        message: "No scopable elements found in template. If you're using global styles in the style tag, you should move it into an external stylesheet file and import it in JS. See https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/faq.md#where-should-i-put-my-global-styles."
      });
    }
  }
  return extraWarnings;
}
function warnDev(w2) {
  var _a2;
  if ((_a2 = w2.filename) == null ? void 0 : _a2.includes("node_modules")) {
    if (isDebugNamespaceEnabled("node-modules-onwarn")) {
      log.debug(buildExtendedLogMessage(w2), void 0, "node-modules-onwarn");
    }
  } else if (log.info.enabled) {
    log.info(buildExtendedLogMessage(w2));
  }
}
function warnBuild(w2) {
  var _a2;
  if ((_a2 = w2.filename) == null ? void 0 : _a2.includes("node_modules")) {
    if (isDebugNamespaceEnabled("node-modules-onwarn")) {
      log.debug(buildExtendedLogMessage(w2), w2.frame, "node-modules-onwarn");
    }
  } else if (log.warn.enabled) {
    log.warn(buildExtendedLogMessage(w2), w2.frame);
  }
}
function buildExtendedLogMessage(w2) {
  const parts = [];
  if (w2.filename) {
    parts.push(w2.filename);
  }
  if (w2.start) {
    parts.push(":", w2.start.line, ":", w2.start.column);
  }
  if (w2.message) {
    if (parts.length > 0) {
      parts.push(" ");
    }
    parts.push(w2.message);
  }
  return parts.join("");
}
function isDebugNamespaceEnabled(namespace) {
  return import_debug4.default.enabled(`${prefix}:${namespace}`);
}

// node_modules/@sveltejs/vite-plugin-svelte/src/utils/error.js
function toRollupError(error, options) {
  const { filename: filename2, frame, start, code, name, stack } = error;
  const rollupError = {
    name,
    // needed otherwise sveltekit coalesce_to_error turns it into a string
    id: filename2,
    message: buildExtendedLogMessage(error),
    // include filename:line:column so that it's clickable
    frame: formatFrameForVite(frame),
    code,
    stack: options.isBuild || options.isDebug || !frame ? stack : ""
  };
  if (start) {
    rollupError.loc = {
      line: start.line,
      column: start.column,
      file: filename2
    };
  }
  return rollupError;
}
function toESBuildError(error, options) {
  const { filename: filename2, frame, start, stack } = error;
  const partialMessage = {
    text: buildExtendedLogMessage(error)
  };
  if (start) {
    partialMessage.location = {
      line: start.line,
      column: start.column,
      file: filename2,
      lineText: lineFromFrame(start.line, frame)
      // needed to get a meaningful error message on cli
    };
  }
  if (options.isBuild || options.isDebug || !frame) {
    partialMessage.detail = stack;
  }
  return partialMessage;
}
function lineFromFrame(lineNo, frame) {
  if (!frame) {
    return "";
  }
  const lines = frame.split("\n");
  const errorLine = lines.find((line) => line.trimStart().startsWith(`${lineNo}: `));
  return errorLine ? errorLine.substring(errorLine.indexOf(": ") + 3) : "";
}
function formatFrameForVite(frame) {
  if (!frame) {
    return "";
  }
  return frame.split("\n").map((line) => line.match(/^\s+\^/) ? "   " + line : " " + line.replace(":", " | ")).join("\n");
}
function couldBeFixedByCssPreprocessor(code) {
  return code === "expected_token" || code === "unexpected_eof" || (code == null ? void 0 : code.startsWith("css_"));
}
function enhanceCompileError(err, originalCode, preprocessors) {
  var _a2, _b, _c;
  preprocessors = arraify(preprocessors ?? []);
  const additionalMessages = [];
  if (couldBeFixedByCssPreprocessor(err.code)) {
    const styleRe = /<!--[^]*?-->|<style((?:\s+[^=>'"/]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"/]+)*\s*)(?:\/>|>([\S\s]*?)<\/style>)/g;
    let m;
    while (m = styleRe.exec(originalCode)) {
      if (!((_a2 = m[1]) == null ? void 0 : _a2.includes("lang="))) {
        additionalMessages.push("Did you forget to add a lang attribute to your style tag?");
      }
      if (preprocessors.every((p) => p.style == null || p.name === "inject-scope-everything-rule")) {
        const preprocessorType = ((_c = (_b = m[1]) == null ? void 0 : _b.match(/lang="(.+?)"/)) == null ? void 0 : _c[1]) ?? "style";
        additionalMessages.push(
          `Did you forget to add a ${preprocessorType} preprocessor? See https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/preprocess.md for more information.`
        );
      }
    }
  }
  if (additionalMessages.length) {
    err.message += "\n\n- " + additionalMessages.join("\n- ");
  }
  return err;
}
function arraify(value) {
  return Array.isArray(value) ? value : [value];
}

// node_modules/@sveltejs/vite-plugin-svelte/src/handle-hot-update.js
async function handleHotUpdate(compileSvelte2, ctx, svelteRequest, cache, options) {
  if (!cache.has(svelteRequest)) {
    log.debug(
      `handleHotUpdate called before initial transform for ${svelteRequest.id}`,
      void 0,
      "hmr"
    );
    return;
  }
  const { read, server, modules } = ctx;
  const cachedJS = cache.getJS(svelteRequest);
  const cachedCss = cache.getCSS(svelteRequest);
  const content = await read();
  let compileData;
  try {
    compileData = await compileSvelte2(svelteRequest, content, options);
    cache.update(compileData);
  } catch (e2) {
    cache.setError(svelteRequest, e2);
    throw toRollupError(e2, options);
  }
  const affectedModules = [...modules];
  const cssIdx = modules.findIndex((m) => m.id === svelteRequest.cssId);
  if (cssIdx > -1) {
    const cssUpdated = cssChanged(cachedCss, compileData.compiled.css);
    if (!cssUpdated) {
      log.debug(`skipping unchanged css for ${svelteRequest.cssId}`, void 0, "hmr");
      affectedModules.splice(cssIdx, 1);
    }
  }
  const jsIdx = modules.findIndex((m) => m.id === svelteRequest.id);
  if (jsIdx > -1) {
    const jsUpdated = jsChanged(cachedJS, compileData.compiled.js, svelteRequest.filename);
    if (!jsUpdated) {
      log.debug(`skipping unchanged js for ${svelteRequest.id}`, void 0, "hmr");
      affectedModules.splice(jsIdx, 1);
      logCompilerWarnings(svelteRequest, compileData.compiled.warnings, options);
    }
  }
  const ssrModulesToInvalidate = affectedModules.filter((m) => !!m.ssrTransformResult);
  if (ssrModulesToInvalidate.length > 0) {
    log.debug(
      `invalidating modules ${ssrModulesToInvalidate.map((m) => m.id).join(", ")}`,
      void 0,
      "hmr"
    );
    ssrModulesToInvalidate.forEach((moduleNode) => server.moduleGraph.invalidateModule(moduleNode));
  }
  if (affectedModules.length > 0) {
    log.debug(
      `handleHotUpdate for ${svelteRequest.id} result: ${affectedModules.map((m) => m.id).join(", ")}`,
      void 0,
      "hmr"
    );
  }
  return affectedModules;
}
function cssChanged(prev, next2) {
  return !isCodeEqual(prev == null ? void 0 : prev.code, next2 == null ? void 0 : next2.code);
}
function jsChanged(prev, next2, filename2) {
  const prevJs = prev == null ? void 0 : prev.code;
  const nextJs = next2 == null ? void 0 : next2.code;
  const isStrictEqual = isCodeEqual(prevJs, nextJs);
  if (isStrictEqual) {
    return false;
  }
  const isLooseEqual = isCodeEqual(normalizeJsCode(prevJs), normalizeJsCode(nextJs));
  if (!isStrictEqual && isLooseEqual) {
    log.debug(
      `ignoring compiler output js change for ${filename2} as it is equal to previous output after normalization`,
      void 0,
      "hmr"
    );
  }
  return !isLooseEqual;
}
function isCodeEqual(prev, next2) {
  if (!prev && !next2) {
    return true;
  }
  if (!prev && next2 || prev && !next2) {
    return false;
  }
  return prev === next2;
}
function normalizeJsCode(code) {
  if (!code) {
    return code;
  }
  return code.replace(/\s*\badd_location\s*\([^)]*\)\s*;?/g, "");
}

// node_modules/zimmerframe/src/walk.js
function walk(node, state, visitors6) {
  const universal = visitors6._;
  let stopped = false;
  function default_visitor(_, { next: next2, state: state2 }) {
    next2(state2);
  }
  function visit(node2, path11, state2) {
    if (stopped) return;
    if (!node2.type) return;
    let result;
    const mutations = {};
    const context = {
      path: path11,
      state: state2,
      next: (next_state = state2) => {
        path11.push(node2);
        for (const key2 in node2) {
          if (key2 === "type") continue;
          const child_node = node2[key2];
          if (child_node && typeof child_node === "object") {
            if (Array.isArray(child_node)) {
              const array_mutations = {};
              child_node.forEach((node3, i) => {
                if (node3 && typeof node3 === "object") {
                  const result2 = visit(node3, path11, next_state);
                  if (result2) array_mutations[i] = result2;
                }
              });
              if (Object.keys(array_mutations).length > 0) {
                mutations[key2] = child_node.map(
                  (node3, i) => array_mutations[i] ?? node3
                );
              }
            } else {
              const result2 = visit(
                /** @type {T} */
                child_node,
                path11,
                next_state
              );
              if (result2) {
                mutations[key2] = result2;
              }
            }
          }
        }
        path11.pop();
        if (Object.keys(mutations).length > 0) {
          return apply_mutations(node2, mutations);
        }
      },
      stop: () => {
        stopped = true;
      },
      visit: (next_node, next_state = state2) => {
        path11.push(node2);
        const result2 = visit(next_node, path11, next_state) ?? next_node;
        path11.pop();
        return result2;
      }
    };
    let visitor = (
      /** @type {import('./types').Visitor<T, U, T>} */
      visitors6[
        /** @type {T['type']} */
        node2.type
      ] ?? default_visitor
    );
    if (universal) {
      let inner_result;
      result = universal(node2, {
        ...context,
        /** @param {U} next_state */
        next: (next_state = state2) => {
          state2 = next_state;
          inner_result = visitor(node2, {
            ...context,
            state: next_state
          });
          return inner_result;
        }
      });
      if (!result && inner_result) {
        result = inner_result;
      }
    } else {
      result = visitor(node2, context);
    }
    if (!result) {
      if (Object.keys(mutations).length > 0) {
        result = apply_mutations(node2, mutations);
      }
    }
    if (result) {
      return result;
    }
  }
  return visit(node, [], state) ?? node;
}
function apply_mutations(node, mutations) {
  const obj = {};
  const descriptors = Object.getOwnPropertyDescriptors(node);
  for (const key2 in descriptors) {
    Object.defineProperty(obj, key2, descriptors[key2]);
  }
  for (const key2 in mutations) {
    obj[key2] = mutations[key2];
  }
  return (
    /** @type {T} */
    obj
  );
}

// node_modules/svelte/src/compiler/phases/patterns.js
var regex_whitespace = /\s/;
var regex_whitespaces = /\s+/;
var regex_starts_with_newline = /^\r?\n/;
var regex_starts_with_whitespace = /^\s/;
var regex_starts_with_whitespaces = /^[ \t\r\n]+/;
var regex_ends_with_whitespace = /\s$/;
var regex_ends_with_whitespaces = /[ \t\r\n]+$/;
var regex_not_whitespace = /[^ \t\r\n]/;
var regex_whitespaces_strict = /[ \t\n\r\f]+/g;
var regex_only_whitespaces = /^[ \t\n\r\f]+$/;
var regex_not_newline_characters = /[^\n]/g;
var regex_is_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
var regex_invalid_identifier_chars = /(^[^a-zA-Z_$]|[^a-zA-Z0-9_$])/g;
var regex_starts_with_vowel = /^[aeiou]/;
var regex_heading_tags = /^h[1-6]$/;
var regex_illegal_attribute_character = /(^[0-9-.])|[\^$@%&#?!|()[\]{}^*+~;]/;
var regex_bidirectional_control_characters = /[\u202a\u202b\u202c\u202d\u202e\u2066\u2067\u2068\u2069]+/g;

// node_modules/svelte/src/compiler/phases/1-parse/utils/fuzzymatch.js
function fuzzymatch(name, names) {
  if (names.length === 0) return null;
  const set2 = new FuzzySet(names);
  const matches = set2.get(name);
  return matches && matches[0][0] > 0.7 ? matches[0][1] : null;
}
var GRAM_SIZE_LOWER = 2;
var GRAM_SIZE_UPPER = 3;
function _distance(str1, str2) {
  if (str1 === null && str2 === null) {
    throw "Trying to compare two null values";
  }
  if (str1 === null || str2 === null) return 0;
  str1 = String(str1);
  str2 = String(str2);
  const distance = levenshtein(str1, str2);
  return 1 - distance / Math.max(str1.length, str2.length);
}
function levenshtein(str1, str2) {
  const current2 = [];
  let prev = 0;
  let value = 0;
  for (let i = 0; i <= str2.length; i++) {
    for (let j = 0; j <= str1.length; j++) {
      if (i && j) {
        if (str1.charAt(j - 1) === str2.charAt(i - 1)) {
          value = prev;
        } else {
          value = Math.min(current2[j], current2[j - 1], prev) + 1;
        }
      } else {
        value = i + j;
      }
      prev = current2[j];
      current2[j] = value;
    }
  }
  return (
    /** @type {number} */
    current2.pop()
  );
}
var non_word_regex = /[^\w, ]+/;
function iterate_grams(value, gram_size = 2) {
  const simplified = "-" + value.toLowerCase().replace(non_word_regex, "") + "-";
  const len_diff = gram_size - simplified.length;
  const results = [];
  if (len_diff > 0) {
    for (let i = 0; i < len_diff; ++i) {
      value += "-";
    }
  }
  for (let i = 0; i < simplified.length - gram_size + 1; ++i) {
    results.push(simplified.slice(i, i + gram_size));
  }
  return results;
}
function gram_counter(value, gram_size = 2) {
  const result = {};
  const grams = iterate_grams(value, gram_size);
  let i = 0;
  for (i; i < grams.length; ++i) {
    if (grams[i] in result) {
      result[grams[i]] += 1;
    } else {
      result[grams[i]] = 1;
    }
  }
  return result;
}
function sort_descending(a, b) {
  return b[0] - a[0];
}
var FuzzySet = class {
  /** @param {string[]} arr */
  constructor(arr) {
    /** @type {Record<string, string>} */
    __publicField(this, "exact_set", {});
    /** @type {Record<string, [number, number][]>} */
    __publicField(this, "match_dict", {});
    /** @type {Record<string, number[]>} */
    __publicField(this, "items", {});
    for (let i = GRAM_SIZE_LOWER; i < GRAM_SIZE_UPPER + 1; ++i) {
      this.items[i] = [];
    }
    for (let i = 0; i < arr.length; ++i) {
      this.add(arr[i]);
    }
  }
  /** @param {string} value */
  add(value) {
    const normalized_value = value.toLowerCase();
    if (normalized_value in this.exact_set) {
      return false;
    }
    let i = GRAM_SIZE_LOWER;
    for (i; i < GRAM_SIZE_UPPER + 1; ++i) {
      this._add(value, i);
    }
  }
  /**
   * @param {string} value
   * @param {number} gram_size
   */
  _add(value, gram_size) {
    const normalized_value = value.toLowerCase();
    const items = this.items[gram_size] || [];
    const index = items.length;
    items.push(0);
    const gram_counts = gram_counter(normalized_value, gram_size);
    let sum_of_square_gram_counts = 0;
    let gram;
    let gram_count;
    for (gram in gram_counts) {
      gram_count = gram_counts[gram];
      sum_of_square_gram_counts += Math.pow(gram_count, 2);
      if (gram in this.match_dict) {
        this.match_dict[gram].push([index, gram_count]);
      } else {
        this.match_dict[gram] = [[index, gram_count]];
      }
    }
    const vector_normal = Math.sqrt(sum_of_square_gram_counts);
    items[index] = [vector_normal, normalized_value];
    this.items[gram_size] = items;
    this.exact_set[normalized_value] = value;
  }
  /** @param {string} value */
  get(value) {
    const normalized_value = value.toLowerCase();
    const result = this.exact_set[normalized_value];
    if (result) {
      return (
        /** @type {MatchTuple[]} */
        [[1, result]]
      );
    }
    for (let gram_size = GRAM_SIZE_UPPER; gram_size >= GRAM_SIZE_LOWER; --gram_size) {
      const results = this.__get(value, gram_size);
      if (results.length > 0) return results;
    }
    return null;
  }
  /**
   * @param {string} value
   * @param {number} gram_size
   * @returns {MatchTuple[]}
   */
  __get(value, gram_size) {
    const normalized_value = value.toLowerCase();
    const matches = {};
    const gram_counts = gram_counter(normalized_value, gram_size);
    const items = this.items[gram_size];
    let sum_of_square_gram_counts = 0;
    let gram;
    let gram_count;
    let i;
    let index;
    let other_gram_count;
    for (gram in gram_counts) {
      gram_count = gram_counts[gram];
      sum_of_square_gram_counts += Math.pow(gram_count, 2);
      if (gram in this.match_dict) {
        for (i = 0; i < this.match_dict[gram].length; ++i) {
          index = this.match_dict[gram][i][0];
          other_gram_count = this.match_dict[gram][i][1];
          if (index in matches) {
            matches[index] += gram_count * other_gram_count;
          } else {
            matches[index] = gram_count * other_gram_count;
          }
        }
      }
    }
    const vector_normal = Math.sqrt(sum_of_square_gram_counts);
    let results = [];
    let match_score;
    for (const match_index in matches) {
      match_score = matches[match_index];
      results.push([match_score / (vector_normal * items[match_index][0]), items[match_index][1]]);
    }
    results.sort(sort_descending);
    let new_results = [];
    const end_index = Math.min(50, results.length);
    for (let i2 = 0; i2 < end_index; ++i2) {
      new_results.push([_distance(results[i2][1], normalized_value), results[i2][1]]);
    }
    results = new_results;
    results.sort(sort_descending);
    new_results = [];
    for (let i2 = 0; i2 < results.length; ++i2) {
      if (results[i2][0] === results[0][0]) {
        new_results.push([results[i2][0], this.exact_set[results[i2][1]]]);
      }
    }
    return new_results;
  }
};

// node_modules/locate-character/src/index.js
function rangeContains(range, index) {
  return range.start <= index && index < range.end;
}
function getLocator(source2, options = {}) {
  const { offsetLine = 0, offsetColumn = 0 } = options;
  let start = 0;
  const ranges = source2.split("\n").map((line, i2) => {
    const end = start + line.length + 1;
    const range = { start, end, line: i2 };
    start = end;
    return range;
  });
  let i = 0;
  function locator2(search, index) {
    if (typeof search === "string") {
      search = source2.indexOf(search, index ?? 0);
    }
    if (search === -1) return void 0;
    let range = ranges[i];
    const d = search >= range.end ? 1 : -1;
    while (range) {
      if (rangeContains(range, search)) {
        return {
          line: offsetLine + range.line,
          column: offsetColumn + search - range.start,
          character: search
        };
      }
      i += d;
      range = ranges[i];
    }
  }
  return locator2;
}

// node_modules/svelte/src/compiler/state.js
var warnings = [];
var filename;
var source;
var dev;
var locator = getLocator("", { offsetLine: 1 });
function locate_node(node) {
  const loc = (
    /** @type {Location} */
    locator(
      /** @type {number} */
      node.start
    )
  );
  return `${sanitize_location(filename)}:${loc == null ? void 0 : loc.line}:${loc.column}`;
}
var warning_filter;
var ignore_stack = [];
var ignore_map = /* @__PURE__ */ new Map();
function push_ignore(ignores) {
  const next2 = /* @__PURE__ */ new Set([...ignore_stack.at(-1) || [], ...ignores]);
  ignore_stack.push(next2);
}
function pop_ignore() {
  ignore_stack.pop();
}
function reset_warning_filter(fn = () => true) {
  warning_filter = fn;
}
function is_ignored(node, code) {
  var _a2;
  return dev && !!((_a2 = ignore_map.get(node)) == null ? void 0 : _a2.some((codes3) => codes3.has(code)));
}
function reset2(_source, options) {
  var _a2;
  source = _source;
  const root_dir = (_a2 = options.rootDir) == null ? void 0 : _a2.replace(/\\/g, "/");
  filename = options.filename.replace(/\\/g, "/");
  dev = !!options.dev;
  if (typeof root_dir === "string" && filename.startsWith(root_dir)) {
    filename = filename.replace(root_dir, "").replace(/^[/\\]/, "");
  }
  locator = getLocator(source, { offsetLine: 1 });
  warnings = [];
  ignore_stack = [];
  ignore_map.clear();
}

// node_modules/svelte/src/compiler/utils/compile_diagnostic.js
var regex_tabs = /^\t+/;
function tabs_to_spaces(str) {
  return str.replace(regex_tabs, (match) => match.split("	").join("  "));
}
function get_code_frame(source2, line, column) {
  const lines = source2.split("\n");
  const frame_start = Math.max(0, line - 2);
  const frame_end = Math.min(line + 3, lines.length);
  const digits = String(frame_end + 1).length;
  return lines.slice(frame_start, frame_end).map((str, i) => {
    const is_error_line = frame_start + i === line;
    const line_num = String(i + frame_start + 1).padStart(digits, " ");
    if (is_error_line) {
      const indicator = " ".repeat(digits + 2 + tabs_to_spaces(str.slice(0, column)).length) + "^";
      return `${line_num}: ${tabs_to_spaces(str)}
${indicator}`;
    }
    return `${line_num}: ${tabs_to_spaces(str)}`;
  }).join("\n");
}
var CompileDiagnostic = class {
  /**
   * @param {string} code
   * @param {string} message
   * @param {[number, number] | undefined} position
   */
  constructor(code, message, position) {
    __publicField(this, "name", "CompileDiagnostic");
    this.code = code;
    this.message = message;
    if (filename) {
      this.filename = filename;
    }
    if (position) {
      this.position = position;
      this.start = locator(position[0]);
      this.end = locator(position[1]);
      if (this.start && this.end) {
        this.frame = get_code_frame(source, this.start.line - 1, this.end.column);
      }
    }
  }
  toString() {
    let out = `${this.code}: ${this.message}`;
    if (this.filename) {
      out += `
${this.filename}`;
      if (this.start) {
        out += `:${this.start.line}:${this.start.column}`;
      }
    }
    if (this.frame) {
      out += `
${this.frame}`;
    }
    return out;
  }
  toJSON() {
    return {
      code: this.code,
      message: this.message,
      filename: this.filename,
      start: this.start,
      end: this.end,
      position: this.position,
      frame: this.frame
    };
  }
};

// node_modules/svelte/src/compiler/warnings.js
var InternalCompileWarning = class extends CompileDiagnostic {
  /**
   * @param {string} code
   * @param {string} message
   * @param {[number, number] | undefined} position
   */
  constructor(code, message, position) {
    super(code, message, position);
    __publicField(this, "name", "CompileWarning");
  }
};
function w(node, code, message) {
  var _a2;
  let stack = ignore_stack;
  if (node) {
    stack = ignore_map.get(node) ?? ignore_stack;
  }
  if (stack && ((_a2 = stack.at(-1)) == null ? void 0 : _a2.has(code))) return;
  const warning = new InternalCompileWarning(code, message, node && node.start !== void 0 ? [node.start, node.end ?? node.start] : void 0);
  if (!warning_filter(warning)) return;
  warnings.push(warning);
}
var codes = [
  "a11y_accesskey",
  "a11y_aria_activedescendant_has_tabindex",
  "a11y_aria_attributes",
  "a11y_autocomplete_valid",
  "a11y_autofocus",
  "a11y_click_events_have_key_events",
  "a11y_consider_explicit_label",
  "a11y_distracting_elements",
  "a11y_figcaption_index",
  "a11y_figcaption_parent",
  "a11y_hidden",
  "a11y_img_redundant_alt",
  "a11y_incorrect_aria_attribute_type",
  "a11y_incorrect_aria_attribute_type_boolean",
  "a11y_incorrect_aria_attribute_type_id",
  "a11y_incorrect_aria_attribute_type_idlist",
  "a11y_incorrect_aria_attribute_type_integer",
  "a11y_incorrect_aria_attribute_type_token",
  "a11y_incorrect_aria_attribute_type_tokenlist",
  "a11y_incorrect_aria_attribute_type_tristate",
  "a11y_interactive_supports_focus",
  "a11y_invalid_attribute",
  "a11y_label_has_associated_control",
  "a11y_media_has_caption",
  "a11y_misplaced_role",
  "a11y_misplaced_scope",
  "a11y_missing_attribute",
  "a11y_missing_content",
  "a11y_mouse_events_have_key_events",
  "a11y_no_abstract_role",
  "a11y_no_interactive_element_to_noninteractive_role",
  "a11y_no_noninteractive_element_interactions",
  "a11y_no_noninteractive_element_to_interactive_role",
  "a11y_no_noninteractive_tabindex",
  "a11y_no_redundant_roles",
  "a11y_no_static_element_interactions",
  "a11y_positive_tabindex",
  "a11y_role_has_required_aria_props",
  "a11y_role_supports_aria_props",
  "a11y_role_supports_aria_props_implicit",
  "a11y_unknown_aria_attribute",
  "a11y_unknown_role",
  "bidirectional_control_characters",
  "legacy_code",
  "unknown_code",
  "options_deprecated_accessors",
  "options_deprecated_immutable",
  "options_missing_custom_element",
  "options_removed_enable_sourcemap",
  "options_removed_hydratable",
  "options_removed_loop_guard_timeout",
  "options_renamed_ssr_dom",
  "custom_element_props_identifier",
  "export_let_unused",
  "legacy_component_creation",
  "non_reactive_update",
  "perf_avoid_inline_class",
  "perf_avoid_nested_class",
  "reactive_declaration_invalid_placement",
  "reactive_declaration_module_script_dependency",
  "state_referenced_locally",
  "store_rune_conflict",
  "css_unused_selector",
  "attribute_avoid_is",
  "attribute_global_event_reference",
  "attribute_illegal_colon",
  "attribute_invalid_property_name",
  "attribute_quoted",
  "bind_invalid_each_rest",
  "block_empty",
  "component_name_lowercase",
  "element_implicitly_closed",
  "element_invalid_self_closing_tag",
  "event_directive_deprecated",
  "node_invalid_placement_ssr",
  "script_context_deprecated",
  "script_unknown_attribute",
  "slot_element_deprecated",
  "svelte_component_deprecated",
  "svelte_element_invalid_this",
  "svelte_self_deprecated"
];
function a11y_accesskey(node) {
  w(node, "a11y_accesskey", `Avoid using accesskey
https://svelte.dev/e/a11y_accesskey`);
}
function a11y_aria_activedescendant_has_tabindex(node) {
  w(node, "a11y_aria_activedescendant_has_tabindex", `An element with an aria-activedescendant attribute should have a tabindex value
https://svelte.dev/e/a11y_aria_activedescendant_has_tabindex`);
}
function a11y_aria_attributes(node, name) {
  w(node, "a11y_aria_attributes", `\`<${name}>\` should not have aria-* attributes
https://svelte.dev/e/a11y_aria_attributes`);
}
function a11y_autocomplete_valid(node, value, type) {
  w(node, "a11y_autocomplete_valid", `'${value}' is an invalid value for 'autocomplete' on \`<input type="${type}">\`
https://svelte.dev/e/a11y_autocomplete_valid`);
}
function a11y_autofocus(node) {
  w(node, "a11y_autofocus", `Avoid using autofocus
https://svelte.dev/e/a11y_autofocus`);
}
function a11y_click_events_have_key_events(node) {
  w(node, "a11y_click_events_have_key_events", `Visible, non-interactive elements with a click event must be accompanied by a keyboard event handler. Consider whether an interactive element such as \`<button type="button">\` or \`<a>\` might be more appropriate
https://svelte.dev/e/a11y_click_events_have_key_events`);
}
function a11y_consider_explicit_label(node) {
  w(node, "a11y_consider_explicit_label", `Buttons and links should either contain text or have an \`aria-label\` or \`aria-labelledby\` attribute
https://svelte.dev/e/a11y_consider_explicit_label`);
}
function a11y_distracting_elements(node, name) {
  w(node, "a11y_distracting_elements", `Avoid \`<${name}>\` elements
https://svelte.dev/e/a11y_distracting_elements`);
}
function a11y_figcaption_index(node) {
  w(node, "a11y_figcaption_index", `\`<figcaption>\` must be first or last child of \`<figure>\`
https://svelte.dev/e/a11y_figcaption_index`);
}
function a11y_figcaption_parent(node) {
  w(node, "a11y_figcaption_parent", `\`<figcaption>\` must be an immediate child of \`<figure>\`
https://svelte.dev/e/a11y_figcaption_parent`);
}
function a11y_hidden(node, name) {
  w(node, "a11y_hidden", `\`<${name}>\` element should not be hidden
https://svelte.dev/e/a11y_hidden`);
}
function a11y_img_redundant_alt(node) {
  w(node, "a11y_img_redundant_alt", `Screenreaders already announce \`<img>\` elements as an image
https://svelte.dev/e/a11y_img_redundant_alt`);
}
function a11y_incorrect_aria_attribute_type(node, attribute, type) {
  w(node, "a11y_incorrect_aria_attribute_type", `The value of '${attribute}' must be a ${type}
https://svelte.dev/e/a11y_incorrect_aria_attribute_type`);
}
function a11y_incorrect_aria_attribute_type_boolean(node, attribute) {
  w(node, "a11y_incorrect_aria_attribute_type_boolean", `The value of '${attribute}' must be either 'true' or 'false'. It cannot be empty
https://svelte.dev/e/a11y_incorrect_aria_attribute_type_boolean`);
}
function a11y_incorrect_aria_attribute_type_idlist(node, attribute) {
  w(node, "a11y_incorrect_aria_attribute_type_idlist", `The value of '${attribute}' must be a space-separated list of strings that represent DOM element IDs
https://svelte.dev/e/a11y_incorrect_aria_attribute_type_idlist`);
}
function a11y_incorrect_aria_attribute_type_integer(node, attribute) {
  w(node, "a11y_incorrect_aria_attribute_type_integer", `The value of '${attribute}' must be an integer
https://svelte.dev/e/a11y_incorrect_aria_attribute_type_integer`);
}
function a11y_incorrect_aria_attribute_type_token(node, attribute, values) {
  w(node, "a11y_incorrect_aria_attribute_type_token", `The value of '${attribute}' must be exactly one of ${values}
https://svelte.dev/e/a11y_incorrect_aria_attribute_type_token`);
}
function a11y_incorrect_aria_attribute_type_tokenlist(node, attribute, values) {
  w(node, "a11y_incorrect_aria_attribute_type_tokenlist", `The value of '${attribute}' must be a space-separated list of one or more of ${values}
https://svelte.dev/e/a11y_incorrect_aria_attribute_type_tokenlist`);
}
function a11y_incorrect_aria_attribute_type_tristate(node, attribute) {
  w(node, "a11y_incorrect_aria_attribute_type_tristate", `The value of '${attribute}' must be exactly one of true, false, or mixed
https://svelte.dev/e/a11y_incorrect_aria_attribute_type_tristate`);
}
function a11y_interactive_supports_focus(node, role) {
  w(node, "a11y_interactive_supports_focus", `Elements with the '${role}' interactive role must have a tabindex value
https://svelte.dev/e/a11y_interactive_supports_focus`);
}
function a11y_invalid_attribute(node, href_value, href_attribute) {
  w(node, "a11y_invalid_attribute", `'${href_value}' is not a valid ${href_attribute} attribute
https://svelte.dev/e/a11y_invalid_attribute`);
}
function a11y_label_has_associated_control(node) {
  w(node, "a11y_label_has_associated_control", `A form label must be associated with a control
https://svelte.dev/e/a11y_label_has_associated_control`);
}
function a11y_media_has_caption(node) {
  w(node, "a11y_media_has_caption", `\`<video>\` elements must have a \`<track kind="captions">\`
https://svelte.dev/e/a11y_media_has_caption`);
}
function a11y_misplaced_role(node, name) {
  w(node, "a11y_misplaced_role", `\`<${name}>\` should not have role attribute
https://svelte.dev/e/a11y_misplaced_role`);
}
function a11y_misplaced_scope(node) {
  w(node, "a11y_misplaced_scope", `The scope attribute should only be used with \`<th>\` elements
https://svelte.dev/e/a11y_misplaced_scope`);
}
function a11y_missing_attribute(node, name, article, sequence3) {
  w(node, "a11y_missing_attribute", `\`<${name}>\` element should have ${article} ${sequence3} attribute
https://svelte.dev/e/a11y_missing_attribute`);
}
function a11y_missing_content(node, name) {
  w(node, "a11y_missing_content", `\`<${name}>\` element should contain text
https://svelte.dev/e/a11y_missing_content`);
}
function a11y_mouse_events_have_key_events(node, event, accompanied_by) {
  w(node, "a11y_mouse_events_have_key_events", `'${event}' event must be accompanied by '${accompanied_by}' event
https://svelte.dev/e/a11y_mouse_events_have_key_events`);
}
function a11y_no_abstract_role(node, role) {
  w(node, "a11y_no_abstract_role", `Abstract role '${role}' is forbidden
https://svelte.dev/e/a11y_no_abstract_role`);
}
function a11y_no_interactive_element_to_noninteractive_role(node, element2, role) {
  w(node, "a11y_no_interactive_element_to_noninteractive_role", `\`<${element2}>\` cannot have role '${role}'
https://svelte.dev/e/a11y_no_interactive_element_to_noninteractive_role`);
}
function a11y_no_noninteractive_element_interactions(node, element2) {
  w(node, "a11y_no_noninteractive_element_interactions", `Non-interactive element \`<${element2}>\` should not be assigned mouse or keyboard event listeners
https://svelte.dev/e/a11y_no_noninteractive_element_interactions`);
}
function a11y_no_noninteractive_element_to_interactive_role(node, element2, role) {
  w(node, "a11y_no_noninteractive_element_to_interactive_role", `Non-interactive element \`<${element2}>\` cannot have interactive role '${role}'
https://svelte.dev/e/a11y_no_noninteractive_element_to_interactive_role`);
}
function a11y_no_noninteractive_tabindex(node) {
  w(node, "a11y_no_noninteractive_tabindex", `noninteractive element cannot have nonnegative tabIndex value
https://svelte.dev/e/a11y_no_noninteractive_tabindex`);
}
function a11y_no_redundant_roles(node, role) {
  w(node, "a11y_no_redundant_roles", `Redundant role '${role}'
https://svelte.dev/e/a11y_no_redundant_roles`);
}
function a11y_no_static_element_interactions(node, element2, handler) {
  w(node, "a11y_no_static_element_interactions", `\`<${element2}>\` with a ${handler} handler must have an ARIA role
https://svelte.dev/e/a11y_no_static_element_interactions`);
}
function a11y_positive_tabindex(node) {
  w(node, "a11y_positive_tabindex", `Avoid tabindex values above zero
https://svelte.dev/e/a11y_positive_tabindex`);
}
function a11y_role_has_required_aria_props(node, role, props) {
  w(node, "a11y_role_has_required_aria_props", `Elements with the ARIA role "${role}" must have the following attributes defined: ${props}
https://svelte.dev/e/a11y_role_has_required_aria_props`);
}
function a11y_role_supports_aria_props(node, attribute, role) {
  w(node, "a11y_role_supports_aria_props", `The attribute '${attribute}' is not supported by the role '${role}'
https://svelte.dev/e/a11y_role_supports_aria_props`);
}
function a11y_role_supports_aria_props_implicit(node, attribute, role, name) {
  w(node, "a11y_role_supports_aria_props_implicit", `The attribute '${attribute}' is not supported by the role '${role}'. This role is implicit on the element \`<${name}>\`
https://svelte.dev/e/a11y_role_supports_aria_props_implicit`);
}
function a11y_unknown_aria_attribute(node, attribute, suggestion) {
  w(node, "a11y_unknown_aria_attribute", `${suggestion ? `Unknown aria attribute 'aria-${attribute}'. Did you mean '${suggestion}'?` : `Unknown aria attribute 'aria-${attribute}'`}
https://svelte.dev/e/a11y_unknown_aria_attribute`);
}
function a11y_unknown_role(node, role, suggestion) {
  w(node, "a11y_unknown_role", `${suggestion ? `Unknown role '${role}'. Did you mean '${suggestion}'?` : `Unknown role '${role}'`}
https://svelte.dev/e/a11y_unknown_role`);
}
function bidirectional_control_characters(node) {
  w(node, "bidirectional_control_characters", `A bidirectional control character was detected in your code. These characters can be used to alter the visual direction of your code and could have unintended consequences
https://svelte.dev/e/bidirectional_control_characters`);
}
function legacy_code(node, code, suggestion) {
  w(node, "legacy_code", `\`${code}\` is no longer valid — please use \`${suggestion}\` instead
https://svelte.dev/e/legacy_code`);
}
function unknown_code(node, code, suggestion) {
  w(node, "unknown_code", `${suggestion ? `\`${code}\` is not a recognised code (did you mean \`${suggestion}\`?)` : `\`${code}\` is not a recognised code`}
https://svelte.dev/e/unknown_code`);
}
function options_deprecated_accessors(node) {
  w(node, "options_deprecated_accessors", `The \`accessors\` option has been deprecated. It will have no effect in runes mode
https://svelte.dev/e/options_deprecated_accessors`);
}
function options_deprecated_immutable(node) {
  w(node, "options_deprecated_immutable", `The \`immutable\` option has been deprecated. It will have no effect in runes mode
https://svelte.dev/e/options_deprecated_immutable`);
}
function options_missing_custom_element(node) {
  w(node, "options_missing_custom_element", `The \`customElement\` option is used when generating a custom element. Did you forget the \`customElement: true\` compile option?
https://svelte.dev/e/options_missing_custom_element`);
}
function options_removed_enable_sourcemap(node) {
  w(node, "options_removed_enable_sourcemap", `The \`enableSourcemap\` option has been removed. Source maps are always generated now, and tooling can choose to ignore them
https://svelte.dev/e/options_removed_enable_sourcemap`);
}
function options_removed_hydratable(node) {
  w(node, "options_removed_hydratable", `The \`hydratable\` option has been removed. Svelte components are always hydratable now
https://svelte.dev/e/options_removed_hydratable`);
}
function options_removed_loop_guard_timeout(node) {
  w(node, "options_removed_loop_guard_timeout", `The \`loopGuardTimeout\` option has been removed
https://svelte.dev/e/options_removed_loop_guard_timeout`);
}
function options_renamed_ssr_dom(node) {
  w(node, "options_renamed_ssr_dom", `\`generate: "dom"\` and \`generate: "ssr"\` options have been renamed to "client" and "server" respectively
https://svelte.dev/e/options_renamed_ssr_dom`);
}
function custom_element_props_identifier(node) {
  w(node, "custom_element_props_identifier", `Using a rest element or a non-destructured declaration with \`$props()\` means that Svelte can't infer what properties to expose when creating a custom element. Consider destructuring all the props or explicitly specifying the \`customElement.props\` option.
https://svelte.dev/e/custom_element_props_identifier`);
}
function export_let_unused(node, name) {
  w(node, "export_let_unused", `Component has unused export property '${name}'. If it is for external reference only, please consider using \`export const ${name}\`
https://svelte.dev/e/export_let_unused`);
}
function legacy_component_creation(node) {
  w(node, "legacy_component_creation", `Svelte 5 components are no longer classes. Instantiate them using \`mount\` or \`hydrate\` (imported from 'svelte') instead.
https://svelte.dev/e/legacy_component_creation`);
}
function non_reactive_update(node, name) {
  w(node, "non_reactive_update", `\`${name}\` is updated, but is not declared with \`$state(...)\`. Changing its value will not correctly trigger updates
https://svelte.dev/e/non_reactive_update`);
}
function perf_avoid_inline_class(node) {
  w(node, "perf_avoid_inline_class", `Avoid 'new class' — instead, declare the class at the top level scope
https://svelte.dev/e/perf_avoid_inline_class`);
}
function perf_avoid_nested_class(node) {
  w(node, "perf_avoid_nested_class", `Avoid declaring classes below the top level scope
https://svelte.dev/e/perf_avoid_nested_class`);
}
function reactive_declaration_invalid_placement(node) {
  w(node, "reactive_declaration_invalid_placement", `Reactive declarations only exist at the top level of the instance script
https://svelte.dev/e/reactive_declaration_invalid_placement`);
}
function reactive_declaration_module_script_dependency(node) {
  w(node, "reactive_declaration_module_script_dependency", `Reassignments of module-level declarations will not cause reactive statements to update
https://svelte.dev/e/reactive_declaration_module_script_dependency`);
}
function state_referenced_locally(node, name, type) {
  w(node, "state_referenced_locally", `This reference only captures the initial value of \`${name}\`. Did you mean to reference it inside a ${type} instead?
https://svelte.dev/e/state_referenced_locally`);
}
function store_rune_conflict(node, name) {
  w(node, "store_rune_conflict", `It looks like you're using the \`$${name}\` rune, but there is a local binding called \`${name}\`. Referencing a local variable with a \`$\` prefix will create a store subscription. Please rename \`${name}\` to avoid the ambiguity
https://svelte.dev/e/store_rune_conflict`);
}
function css_unused_selector(node, name) {
  w(node, "css_unused_selector", `Unused CSS selector "${name}"
https://svelte.dev/e/css_unused_selector`);
}
function attribute_avoid_is(node) {
  w(node, "attribute_avoid_is", `The "is" attribute is not supported cross-browser and should be avoided
https://svelte.dev/e/attribute_avoid_is`);
}
function attribute_global_event_reference(node, name) {
  w(node, "attribute_global_event_reference", `You are referencing \`globalThis.${name}\`. Did you forget to declare a variable with that name?
https://svelte.dev/e/attribute_global_event_reference`);
}
function attribute_illegal_colon(node) {
  w(node, "attribute_illegal_colon", `Attributes should not contain ':' characters to prevent ambiguity with Svelte directives
https://svelte.dev/e/attribute_illegal_colon`);
}
function attribute_invalid_property_name(node, wrong, right) {
  w(node, "attribute_invalid_property_name", `'${wrong}' is not a valid HTML attribute. Did you mean '${right}'?
https://svelte.dev/e/attribute_invalid_property_name`);
}
function attribute_quoted(node) {
  w(node, "attribute_quoted", `Quoted attributes on components and custom elements will be stringified in a future version of Svelte. If this isn't what you want, remove the quotes
https://svelte.dev/e/attribute_quoted`);
}
function bind_invalid_each_rest(node, name) {
  w(node, "bind_invalid_each_rest", `The rest operator (...) will create a new object and binding '${name}' with the original object will not work
https://svelte.dev/e/bind_invalid_each_rest`);
}
function block_empty(node) {
  w(node, "block_empty", `Empty block
https://svelte.dev/e/block_empty`);
}
function component_name_lowercase(node, name) {
  w(node, "component_name_lowercase", `\`<${name}>\` will be treated as an HTML element unless it begins with a capital letter
https://svelte.dev/e/component_name_lowercase`);
}
function element_implicitly_closed(node, tag2, closing) {
  w(node, "element_implicitly_closed", `This element is implicitly closed by the following \`${tag2}\`, which can cause an unexpected DOM structure. Add an explicit \`${closing}\` to avoid surprises.
https://svelte.dev/e/element_implicitly_closed`);
}
function element_invalid_self_closing_tag(node, name) {
  w(node, "element_invalid_self_closing_tag", `Self-closing HTML tags for non-void elements are ambiguous — use \`<${name} ...></${name}>\` rather than \`<${name} ... />\`
https://svelte.dev/e/element_invalid_self_closing_tag`);
}
function event_directive_deprecated(node, name) {
  w(node, "event_directive_deprecated", `Using \`on:${name}\` to listen to the ${name} event is deprecated. Use the event attribute \`on${name}\` instead
https://svelte.dev/e/event_directive_deprecated`);
}
function node_invalid_placement_ssr(node, message) {
  w(node, "node_invalid_placement_ssr", `${message}. When rendering this component on the server, the resulting HTML will be modified by the browser (by moving, removing, or inserting elements), likely resulting in a \`hydration_mismatch\` warning
https://svelte.dev/e/node_invalid_placement_ssr`);
}
function script_context_deprecated(node) {
  w(node, "script_context_deprecated", `\`context="module"\` is deprecated, use the \`module\` attribute instead
https://svelte.dev/e/script_context_deprecated`);
}
function script_unknown_attribute(node) {
  w(node, "script_unknown_attribute", `Unrecognized attribute — should be one of \`generics\`, \`lang\` or \`module\`. If this exists for a preprocessor, ensure that the preprocessor removes it
https://svelte.dev/e/script_unknown_attribute`);
}
function slot_element_deprecated(node) {
  w(node, "slot_element_deprecated", `Using \`<slot>\` to render parent content is deprecated. Use \`{@render ...}\` tags instead
https://svelte.dev/e/slot_element_deprecated`);
}
function svelte_component_deprecated(node) {
  w(node, "svelte_component_deprecated", `\`<svelte:component>\` is deprecated in runes mode — components are dynamic by default
https://svelte.dev/e/svelte_component_deprecated`);
}
function svelte_element_invalid_this(node) {
  w(node, "svelte_element_invalid_this", `\`this\` should be an \`{expression}\`. Using a string attribute value will cause an error in future versions of Svelte
https://svelte.dev/e/svelte_element_invalid_this`);
}
function svelte_self_deprecated(node, name, basename) {
  w(node, "svelte_self_deprecated", `\`<svelte:self>\` is deprecated — use self-imports (e.g. \`import ${name} from './${basename}'\`) instead
https://svelte.dev/e/svelte_self_deprecated`);
}

// node_modules/svelte/src/compiler/utils/extract_svelte_ignore.js
var regex_svelte_ignore = /^\s*svelte-ignore\s/;
var replacements = {
  "non-top-level-reactive-declaration": "reactive_declaration_invalid_placement",
  "module-script-reactive-declaration": "reactive_declaration_module_script",
  "empty-block": "block_empty",
  "avoid-is": "attribute_avoid_is",
  "invalid-html-attribute": "attribute_invalid_property_name",
  "a11y-structure": "a11y_figcaption_parent",
  "illegal-attribute-character": "attribute_illegal_colon",
  "invalid-rest-eachblock-binding": "bind_invalid_each_rest",
  "unused-export-let": "export_let_unused"
};
var codes2 = codes.concat(IGNORABLE_RUNTIME_WARNINGS);
function extract_svelte_ignore(offset2, text2, runes) {
  const match = regex_svelte_ignore.exec(text2);
  if (!match) return [];
  let length = match[0].length;
  offset2 += length;
  const ignores = [];
  if (runes) {
    for (const match2 of text2.slice(length).matchAll(/([\w$-]+)(,)?/gm)) {
      const code = match2[1];
      if (codes2.includes(code)) {
        ignores.push(code);
      } else {
        const replacement = replacements[code] ?? code.replace(/-/g, "_");
        const start = offset2 + /** @type {number} */
        match2.index;
        const end = start + code.length;
        if (codes2.includes(replacement)) {
          legacy_code({ start, end }, code, replacement);
        } else {
          const suggestion = fuzzymatch(code, codes2);
          unknown_code({ start, end }, code, suggestion);
        }
      }
      if (!match2[2]) {
        break;
      }
    }
  } else {
    for (const match2 of text2.slice(length).matchAll(/[\w$-]+/gm)) {
      const code = match2[0];
      ignores.push(code);
      if (!codes2.includes(code)) {
        const replacement = replacements[code] ?? code.replace(/-/g, "_");
        if (codes2.includes(replacement)) {
          ignores.push(replacement);
        }
      }
    }
  }
  return ignores;
}

// node_modules/svelte/src/compiler/legacy.js
function remove_surrounding_whitespace_nodes(nodes) {
  const first = nodes.at(0);
  const last = nodes.at(-1);
  if ((first == null ? void 0 : first.type) === "Text") {
    if (!regex_not_whitespace.test(first.data)) {
      nodes.shift();
    } else {
      first.data = first.data.replace(regex_starts_with_whitespaces, "");
    }
  }
  if ((last == null ? void 0 : last.type) === "Text") {
    if (!regex_not_whitespace.test(last.data)) {
      nodes.pop();
    } else {
      last.data = last.data.replace(regex_ends_with_whitespaces, "");
    }
  }
}
function convert(source2, ast) {
  const root = (
    /** @type {AST.SvelteNode | Legacy.LegacySvelteNode} */
    ast
  );
  return (
    /** @type {Legacy.LegacyRoot} */
    walk(root, null, {
      _(node, { next: next2 }) {
        delete node.metadata;
        next2();
      },
      // @ts-ignore
      Root(node, { visit }) {
        const { instance, module, options } = node;
        if (
          /** @type {any} */
          options == null ? void 0 : options.__raw__
        ) {
          let idx = node.fragment.nodes.findIndex((node2) => options.end <= node2.start);
          if (idx === -1) {
            idx = node.fragment.nodes.length;
          }
          node.fragment.nodes.splice(
            idx,
            0,
            /** @type {any} */
            options.__raw__
          );
        }
        let start = null;
        let end = null;
        if (node.fragment.nodes.length > 0) {
          const first = (
            /** @type {AST.BaseNode} */
            node.fragment.nodes.at(0)
          );
          const last = (
            /** @type {AST.BaseNode} */
            node.fragment.nodes.at(-1)
          );
          start = first.start;
          end = last.end;
          while (/\s/.test(source2[start])) start += 1;
          while (/\s/.test(source2[end - 1])) end -= 1;
        }
        if (instance) {
          delete instance.attributes;
        }
        if (module) {
          delete module.attributes;
        }
        return {
          html: {
            type: "Fragment",
            start,
            end,
            children: node.fragment.nodes.map((child) => visit(child))
          },
          instance,
          module,
          css: ast.css ? visit(ast.css) : void 0
        };
      },
      AnimateDirective(node) {
        return { ...node, type: "Animation" };
      },
      // @ts-ignore
      AwaitBlock(node, { visit }) {
        var _a2, _b, _c;
        let pendingblock = {
          type: "PendingBlock",
          /** @type {number | null} */
          start: null,
          /** @type {number | null} */
          end: null,
          children: ((_a2 = node.pending) == null ? void 0 : _a2.nodes.map((child) => visit(child))) ?? [],
          skip: true
        };
        let thenblock = {
          type: "ThenBlock",
          /** @type {number | null} */
          start: null,
          /** @type {number | null} */
          end: null,
          children: ((_b = node.then) == null ? void 0 : _b.nodes.map((child) => visit(child))) ?? [],
          skip: true
        };
        let catchblock = {
          type: "CatchBlock",
          /** @type {number | null} */
          start: null,
          /** @type {number | null} */
          end: null,
          children: ((_c = node.catch) == null ? void 0 : _c.nodes.map((child) => visit(child))) ?? [],
          skip: true
        };
        if (node.pending) {
          const first = node.pending.nodes.at(0);
          const last = node.pending.nodes.at(-1);
          pendingblock.start = (first == null ? void 0 : first.start) ?? source2.indexOf("}", node.expression.end) + 1;
          pendingblock.end = (last == null ? void 0 : last.end) ?? pendingblock.start;
          pendingblock.skip = false;
        }
        if (node.then) {
          const first = node.then.nodes.at(0);
          const last = node.then.nodes.at(-1);
          thenblock.start = pendingblock.end ?? (first == null ? void 0 : first.start) ?? source2.indexOf("}", node.expression.end) + 1;
          thenblock.end = (last == null ? void 0 : last.end) ?? source2.lastIndexOf("}", pendingblock.end ?? node.expression.end) + 1;
          thenblock.skip = false;
        }
        if (node.catch) {
          const first = node.catch.nodes.at(0);
          const last = node.catch.nodes.at(-1);
          catchblock.start = thenblock.end ?? pendingblock.end ?? (first == null ? void 0 : first.start) ?? source2.indexOf("}", node.expression.end) + 1;
          catchblock.end = (last == null ? void 0 : last.end) ?? source2.lastIndexOf("}", thenblock.end ?? pendingblock.end ?? node.expression.end) + 1;
          catchblock.skip = false;
        }
        return {
          type: "AwaitBlock",
          start: node.start,
          end: node.end,
          expression: node.expression,
          value: node.value,
          error: node.error,
          pending: pendingblock,
          then: thenblock,
          catch: catchblock
        };
      },
      BindDirective(node) {
        return { ...node, type: "Binding" };
      },
      ClassDirective(node) {
        return { ...node, type: "Class" };
      },
      Comment(node) {
        return {
          ...node,
          ignores: extract_svelte_ignore(node.start, node.data, false)
        };
      },
      ComplexSelector(node, { next: next2 }) {
        next2();
        const children = [];
        for (const child of node.children) {
          if (child.combinator) {
            children.push(child.combinator);
          }
          children.push(...child.selectors);
        }
        return {
          type: "Selector",
          start: node.start,
          end: node.end,
          children
        };
      },
      Component(node, { visit }) {
        return {
          type: "InlineComponent",
          start: node.start,
          end: node.end,
          name: node.name,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      // @ts-ignore
      ConstTag(node) {
        if (
          /** @type {Legacy.LegacyConstTag} */
          node.expression !== void 0
        ) {
          return node;
        }
        const modern_node = (
          /** @type {AST.ConstTag} */
          node
        );
        const { id: left } = { ...modern_node.declaration.declarations[0] };
        delete left.typeAnnotation;
        return {
          type: "ConstTag",
          start: modern_node.start,
          end: node.end,
          expression: {
            type: "AssignmentExpression",
            start: (modern_node.declaration.start ?? 0) + "const ".length,
            end: modern_node.declaration.end ?? 0,
            operator: "=",
            left,
            right: modern_node.declaration.declarations[0].init
          }
        };
      },
      // @ts-ignore
      KeyBlock(node, { visit }) {
        remove_surrounding_whitespace_nodes(node.fragment.nodes);
        return {
          type: "KeyBlock",
          start: node.start,
          end: node.end,
          expression: node.expression,
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      // @ts-ignore
      EachBlock(node, { visit }) {
        let elseblock = void 0;
        if (node.fallback) {
          const first = node.fallback.nodes.at(0);
          const end = source2.lastIndexOf(
            "{",
            /** @type {number} */
            node.end - 1
          );
          const start = (first == null ? void 0 : first.start) ?? end;
          remove_surrounding_whitespace_nodes(node.fallback.nodes);
          elseblock = {
            type: "ElseBlock",
            start,
            end,
            children: node.fallback.nodes.map((child) => visit(child))
          };
        }
        remove_surrounding_whitespace_nodes(node.body.nodes);
        return {
          type: "EachBlock",
          start: node.start,
          end: node.end,
          children: node.body.nodes.map((child) => visit(child)),
          context: node.context,
          expression: node.expression,
          index: node.index,
          key: node.key,
          else: elseblock
        };
      },
      ExpressionTag(node, { path: path11 }) {
        const parent = path11.at(-1);
        if ((parent == null ? void 0 : parent.type) === "Attribute") {
          if (source2[parent.start] === "{") {
            return {
              type: "AttributeShorthand",
              start: node.start,
              end: node.end,
              expression: node.expression
            };
          }
        }
        return {
          type: "MustacheTag",
          start: node.start,
          end: node.end,
          expression: node.expression
        };
      },
      HtmlTag(node) {
        return { ...node, type: "RawMustacheTag" };
      },
      // @ts-ignore
      IfBlock(node, { visit }) {
        var _a2, _b;
        let elseblock = void 0;
        if (node.alternate) {
          let nodes = node.alternate.nodes;
          if (nodes.length === 1 && nodes[0].type === "IfBlock" && nodes[0].elseif) {
            nodes = nodes[0].consequent.nodes;
          }
          const end = source2.lastIndexOf(
            "{",
            /** @type {number} */
            node.end - 1
          );
          const start2 = ((_a2 = nodes.at(0)) == null ? void 0 : _a2.start) ?? end;
          remove_surrounding_whitespace_nodes(node.alternate.nodes);
          elseblock = {
            type: "ElseBlock",
            start: start2,
            end,
            children: node.alternate.nodes.map(
              (child) => (
                /** @type {Legacy.LegacyElementLike} */
                visit(child)
              )
            )
          };
        }
        const start = node.elseif ? ((_b = node.consequent.nodes[0]) == null ? void 0 : _b.start) ?? source2.lastIndexOf(
          "{",
          /** @type {number} */
          node.end - 1
        ) : node.start;
        remove_surrounding_whitespace_nodes(node.consequent.nodes);
        return {
          type: "IfBlock",
          start,
          end: node.end,
          expression: node.test,
          children: node.consequent.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          ),
          else: elseblock,
          elseif: node.elseif ? true : void 0
        };
      },
      OnDirective(node) {
        return { ...node, type: "EventHandler" };
      },
      // @ts-expect-error
      SnippetBlock(node, { visit }) {
        remove_surrounding_whitespace_nodes(node.body.nodes);
        return {
          type: "SnippetBlock",
          start: node.start,
          end: node.end,
          expression: node.expression,
          parameters: node.parameters,
          children: node.body.nodes.map((child) => visit(child)),
          typeParams: node.typeParams
        };
      },
      // @ts-expect-error
      SvelteBoundary(node, { visit }) {
        remove_surrounding_whitespace_nodes(node.fragment.nodes);
        return {
          type: "SvelteBoundary",
          name: "svelte:boundary",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map((child) => visit(child))
        };
      },
      RegularElement(node, { visit }) {
        return {
          type: "Element",
          start: node.start,
          end: node.end,
          name: node.name,
          attributes: node.attributes.map((child) => visit(child)),
          children: node.fragment.nodes.map((child) => visit(child))
        };
      },
      SlotElement(node, { visit }) {
        return {
          type: "Slot",
          start: node.start,
          end: node.end,
          name: node.name,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      Attribute(node, { visit, next: next2, path: path11 }) {
        if (node.value !== true && !Array.isArray(node.value)) {
          path11.push(node);
          const value = (
            /** @type {Legacy.LegacyAttribute['value']} */
            [visit(node.value)]
          );
          path11.pop();
          return {
            ...node,
            value
          };
        } else {
          return next2();
        }
      },
      StyleDirective(node, { visit, next: next2, path: path11 }) {
        if (node.value !== true && !Array.isArray(node.value)) {
          path11.push(node);
          const value = (
            /** @type {Legacy.LegacyStyleDirective['value']} */
            [visit(node.value)]
          );
          path11.pop();
          return {
            ...node,
            value
          };
        } else {
          return next2();
        }
      },
      SpreadAttribute(node) {
        return { ...node, type: "Spread" };
      },
      StyleSheet(node, context) {
        return {
          ...node,
          ...context.next(),
          type: "Style"
        };
      },
      SvelteBody(node, { visit }) {
        return {
          type: "Body",
          name: "svelte:body",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      SvelteComponent(node, { visit }) {
        return {
          type: "InlineComponent",
          name: "svelte:component",
          start: node.start,
          end: node.end,
          expression: node.expression,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      SvelteDocument(node, { visit }) {
        return {
          type: "Document",
          name: "svelte:document",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      SvelteElement(node, { visit }) {
        let tag2 = node.tag;
        if (tag2.type === "Literal" && typeof tag2.value === "string" && source2[
          /** @type {number} */
          node.tag.start - 1
        ] !== "{") {
          tag2 = tag2.value;
        }
        return {
          type: "Element",
          name: "svelte:element",
          start: node.start,
          end: node.end,
          tag: tag2,
          attributes: node.attributes.map((child) => visit(child)),
          children: node.fragment.nodes.map((child) => visit(child))
        };
      },
      SvelteFragment(node, { visit }) {
        return {
          type: "SlotTemplate",
          name: "svelte:fragment",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (a) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(a)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      SvelteHead(node, { visit }) {
        return {
          type: "Head",
          name: "svelte:head",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      SvelteOptions(node, { visit }) {
        return {
          type: "Options",
          name: "svelte:options",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          )
        };
      },
      SvelteSelf(node, { visit }) {
        return {
          type: "InlineComponent",
          name: "svelte:self",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      SvelteWindow(node, { visit }) {
        return {
          type: "Window",
          name: "svelte:window",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      Text(node, { path: path11 }) {
        const parent = path11.at(-1);
        if ((parent == null ? void 0 : parent.type) === "RegularElement" && parent.name === "style") {
          return (
            /** @type {AST.Text} */
            {
              type: "Text",
              start: node.start,
              end: node.end,
              data: node.data
            }
          );
        }
      },
      TitleElement(node, { visit }) {
        return {
          type: "Title",
          name: "title",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      TransitionDirective(node) {
        return { ...node, type: "Transition" };
      },
      UseDirective(node) {
        return { ...node, type: "Action" };
      },
      LetDirective(node) {
        return { ...node, type: "Let" };
      }
    })
  );
}

// node_modules/acorn/dist/acorn.mjs
var acorn_exports = {};
__export(acorn_exports, {
  Node: () => Node,
  Parser: () => Parser,
  Position: () => Position,
  SourceLocation: () => SourceLocation,
  TokContext: () => TokContext,
  Token: () => Token,
  TokenType: () => TokenType,
  defaultOptions: () => defaultOptions,
  getLineInfo: () => getLineInfo,
  isIdentifierChar: () => isIdentifierChar,
  isIdentifierStart: () => isIdentifierStart,
  isNewLine: () => isNewLine,
  keywordTypes: () => keywords,
  lineBreak: () => lineBreak,
  lineBreakG: () => lineBreakG,
  nonASCIIwhitespace: () => nonASCIIwhitespace,
  parse: () => parse3,
  parseExpressionAt: () => parseExpressionAt2,
  tokContexts: () => types,
  tokTypes: () => types$1,
  tokenizer: () => tokenizer2,
  version: () => version
});
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟍꟐꟑꟓꟕ-Ƛꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code, set2) {
  var pos = 65536;
  for (var i = 0; i < set2.length; i += 2) {
    pos += set2[i];
    if (pos > code) {
      return false;
    }
    pos += set2[i + 1];
    if (pos >= code) {
      return true;
    }
  }
  return false;
}
function isIdentifierStart(code, astral) {
  if (code < 65) {
    return code === 36;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code, astral) {
  if (code < 48) {
    return code === 36;
  }
  if (code < 58) {
    return true;
  }
  if (code < 65) {
    return false;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
var TokenType = function TokenType2(label, conf) {
  if (conf === void 0) conf = {};
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};
function binop(name, prec) {
  return new TokenType(name, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true };
var startsExpr = { startsExpr: true };
var keywords = {};
function kw(name, options) {
  if (options === void 0) options = {};
  options.keyword = name;
  return keywords[name] = new TokenType(name, options);
}
var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),
  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true }),
  coalesce: binop("??", 1),
  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", { isLoop: true, beforeExpr: true }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", { isLoop: true }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", { isLoop: true }),
  _with: kw("with"),
  _new: kw("new", { beforeExpr: true, startsExpr: true }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", { beforeExpr: true, binop: 7 }),
  _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code) {
  return code === 10 || code === 13 || code === 8232 || code === 8233;
}
function nextLineBreak(code, from, end) {
  if (end === void 0) end = code.length;
  for (var i = from; i < end; i++) {
    var next2 = code.charCodeAt(i);
    if (isNewLine(next2)) {
      return i < end - 1 && next2 === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
    }
  }
  return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;
var hasOwn = Object.hasOwn || function(obj, propName) {
  return hasOwnProperty.call(obj, propName);
};
var isArray = Array.isArray || function(obj) {
  return toString.call(obj) === "[object Array]";
};
var regexpCache = /* @__PURE__ */ Object.create(null);
function wordsRegexp(words) {
  return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
}
function codePointToString(code) {
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position2(line, col) {
  this.line = line;
  this.column = col;
};
Position.prototype.offset = function offset(n2) {
  return new Position(this.line, this.column + n2);
};
var SourceLocation = function SourceLocation2(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) {
    this.source = p.sourceFile;
  }
};
function getLineInfo(input, offset2) {
  for (var line = 1, cur = 0; ; ) {
    var nextBreak = nextLineBreak(input, cur, offset2);
    if (nextBreak < 0) {
      return new Position(line, offset2 - cur);
    }
    ++line;
    cur = nextBreak;
  }
}
var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called when
  // a semicolon is automatically inserted. It will be passed the
  // position of the inserted semicolon as an offset, and if
  // `locations` is enabled, it is given the location as a `{line,
  // column}` object as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: false,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: false,
  // By default, the parser will verify that private properties are
  // only used in places where they are valid and have been declared.
  // Set this to false to turn such checks off.
  checkPrivateFields: true,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  // When this option has an array as value, objects representing the
  // comments are pushed to it.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
  var options = {};
  for (var opt in defaultOptions) {
    options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
  }
  if (options.ecmaVersion === "latest") {
    options.ecmaVersion = 1e8;
  } else if (options.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options.ecmaVersion = 11;
  } else if (options.ecmaVersion >= 2015) {
    options.ecmaVersion -= 2009;
  }
  if (options.allowReserved == null) {
    options.allowReserved = options.ecmaVersion < 5;
  }
  if (!opts || opts.allowHashBang == null) {
    options.allowHashBang = options.ecmaVersion >= 14;
  }
  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function(token) {
      return tokens.push(token);
    };
  }
  if (isArray(options.onComment)) {
    options.onComment = pushComment(options, options.onComment);
  }
  return options;
}
function pushComment(options, array2) {
  return function(block2, text2, start, end, startLoc, endLoc) {
    var comment = {
      type: block2 ? "Block" : "Line",
      value: text2,
      start,
      end
    };
    if (options.locations) {
      comment.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options.ranges) {
      comment.range = [start, end];
    }
    array2.push(comment);
  };
}
var SCOPE_TOP = 1;
var SCOPE_FUNCTION = 2;
var SCOPE_ASYNC = 4;
var SCOPE_GENERATOR = 8;
var SCOPE_ARROW = 16;
var SCOPE_SIMPLE_CATCH = 32;
var SCOPE_SUPER = 64;
var SCOPE_DIRECT_SUPER = 128;
var SCOPE_CLASS_STATIC_BLOCK = 256;
var SCOPE_CLASS_FIELD_INIT = 512;
var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async2, generator) {
  return SCOPE_FUNCTION | (async2 ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0;
var BIND_VAR = 1;
var BIND_LEXICAL = 2;
var BIND_FUNCTION = 3;
var BIND_SIMPLE_CATCH = 4;
var BIND_OUTSIDE = 5;
var Parser = function Parser2(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options.allowReserved !== true) {
    reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
    if (options.sourceType === "module") {
      reserved += " await";
    }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);
  this.containsEsc = false;
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }
  this.type = types$1.eof;
  this.value = null;
  this.start = this.end = this.pos;
  this.startLoc = this.endLoc = this.curPosition();
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;
  this.context = this.initialContext();
  this.exprAllowed = true;
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  this.labels = [];
  this.undefinedExports = /* @__PURE__ */ Object.create(null);
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
    this.skipLineComment(2);
  }
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);
  this.regexpState = null;
  this.privateNameStack = [];
};
var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
Parser.prototype.parse = function parse() {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node);
};
prototypeAccessors.inFunction.get = function() {
  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
};
prototypeAccessors.inAsync.get = function() {
  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
};
prototypeAccessors.canAwait.get = function() {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var ref2 = this.scopeStack[i];
    var flags = ref2.flags;
    if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) {
      return false;
    }
    if (flags & SCOPE_FUNCTION) {
      return (flags & SCOPE_ASYNC) > 0;
    }
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  return (flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var ref2 = this.scopeStack[i];
    var flags = ref2.flags;
    if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) || flags & SCOPE_FUNCTION && !(flags & SCOPE_ARROW)) {
      return true;
    }
  }
  return false;
};
prototypeAccessors.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser.extend = function extend() {
  var plugins = [], len = arguments.length;
  while (len--) plugins[len] = arguments[len];
  var cls = this;
  for (var i = 0; i < plugins.length; i++) {
    cls = plugins[i](cls);
  }
  return cls;
};
Parser.parse = function parse2(input, options) {
  return new this(options, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression();
};
Parser.tokenizer = function tokenizer(input, options) {
  return new this(options, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype;
var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
  if (this.options.ecmaVersion < 5) {
    return false;
  }
  for (; ; ) {
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start));
    if (!match) {
      return false;
    }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next2 = this.input.charAt(end);
      return next2 === ";" || next2 === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next2) || next2 === "!" && this.input.charAt(end + 1) === "=");
    }
    start += match[0].length;
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === ";") {
      start++;
    }
  }
};
pp$9.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true;
  } else {
    return false;
  }
};
pp$9.isContextual = function(name) {
  return this.type === types$1.name && this.value === name && !this.containsEsc;
};
pp$9.eatContextual = function(name) {
  if (!this.isContextual(name)) {
    return false;
  }
  this.next();
  return true;
};
pp$9.expectContextual = function(name) {
  if (!this.eatContextual(name)) {
    this.unexpected();
  }
};
pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) {
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    }
    return true;
  }
};
pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
    this.unexpected();
  }
};
pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma) {
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    }
    if (!notNext) {
      this.next();
    }
    return true;
  }
};
pp$9.expect = function(type) {
  this.eat(type) || this.unexpected();
};
pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors = function DestructuringErrors2() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
    return;
  }
  if (refDestructuringErrors.trailingComma > -1) {
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) {
    this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) {
    return false;
  }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) {
    return shorthandAssign >= 0 || doubleProto >= 0;
  }
  if (shorthandAssign >= 0) {
    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
  }
  if (doubleProto >= 0) {
    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }
};
pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }
  if (this.awaitPos) {
    this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};
pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression") {
    return this.isSimpleAssignTarget(expr.expression);
  }
  return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(node) {
  var exports = /* @__PURE__ */ Object.create(null);
  if (!node.body) {
    node.body = [];
  }
  while (this.type !== types$1.eof) {
    var stmt2 = this.parseStatement(null, true, exports);
    node.body.push(stmt2);
  }
  if (this.inModule) {
    for (var i = 0, list3 = Object.keys(this.undefinedExports); i < list3.length; i += 1) {
      var name = list3[i];
      this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
    }
  }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program");
};
var loopLabel = { kind: "loop" };
var switchLabel = { kind: "switch" };
pp$8.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next2 = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next2);
  if (nextCh === 91 || nextCh === 92) {
    return true;
  }
  if (context) {
    return false;
  }
  if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
    return true;
  }
  if (isIdentifierStart(nextCh, true)) {
    var pos = next2 + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
      ++pos;
    }
    if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
      return true;
    }
    var ident = this.input.slice(next2, pos);
    if (!keywordRelationalOperator.test(ident)) {
      return true;
    }
  }
  return false;
};
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next2 = this.pos + skip[0].length, after;
  return !lineBreak.test(this.input.slice(this.pos, next2)) && this.input.slice(next2, next2 + 8) === "function" && (next2 + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next2 + 8)) || after > 55295 && after < 56320));
};
pp$8.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;
  if (this.isLet(context)) {
    starttype = types$1._var;
    kind = "let";
  }
  switch (starttype) {
    case types$1._break:
    case types$1._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case types$1._debugger:
      return this.parseDebuggerStatement(node);
    case types$1._do:
      return this.parseDoStatement(node);
    case types$1._for:
      return this.parseForStatement(node);
    case types$1._function:
      if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
        this.unexpected();
      }
      return this.parseFunctionStatement(node, false, !context);
    case types$1._class:
      if (context) {
        this.unexpected();
      }
      return this.parseClass(node, true);
    case types$1._if:
      return this.parseIfStatement(node);
    case types$1._return:
      return this.parseReturnStatement(node);
    case types$1._switch:
      return this.parseSwitchStatement(node);
    case types$1._throw:
      return this.parseThrowStatement(node);
    case types$1._try:
      return this.parseTryStatement(node);
    case types$1._const:
    case types$1._var:
      kind = kind || this.value;
      if (context && kind !== "var") {
        this.unexpected();
      }
      return this.parseVarStatement(node, kind);
    case types$1._while:
      return this.parseWhileStatement(node);
    case types$1._with:
      return this.parseWithStatement(node);
    case types$1.braceL:
      return this.parseBlock(true, node);
    case types$1.semi:
      return this.parseEmptyStatement(node);
    case types$1._export:
    case types$1._import:
      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next2 = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next2);
        if (nextCh === 40 || nextCh === 46) {
          return this.parseExpressionStatement(node, this.parseExpression());
        }
      }
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.start, "'import' and 'export' may only appear at the top level");
        }
        if (!this.inModule) {
          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports);
    default:
      if (this.isAsyncFunction()) {
        if (context) {
          this.unexpected();
        }
        this.next();
        return this.parseFunctionStatement(node, true, !context);
      }
      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node, expr);
      }
  }
};
pp$8.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node.label = null;
  } else if (this.type !== types$1.name) {
    this.unexpected();
  } else {
    node.label = this.parseIdent();
    this.semicolon();
  }
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
        break;
      }
      if (node.label && isBreak) {
        break;
      }
    }
  }
  if (i === this.labels.length) {
    this.raise(node.start, "Unsyntactic " + keyword);
  }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) {
    this.eat(types$1.semi);
  } else {
    this.semicolon();
  }
  return this.finishNode(node, "DoWhileStatement");
};
pp$8.parseForStatement = function(node) {
  this.next();
  var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node, null);
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types$1._in) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
        } else {
          node.await = awaitAt > -1;
        }
      }
      return this.parseForIn(node, init$1);
    }
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node, init$1);
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var containsEsc = this.containsEsc;
  var refDestructuringErrors = new DestructuringErrors();
  var initPos = this.start;
  var init3 = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (awaitAt > -1) {
      if (this.type === types$1._in) {
        this.unexpected(awaitAt);
      }
      node.await = true;
    } else if (isForOf && this.options.ecmaVersion >= 8) {
      if (init3.start === initPos && !containsEsc && init3.type === "Identifier" && init3.name === "async") {
        this.unexpected();
      } else if (this.options.ecmaVersion >= 9) {
        node.await = false;
      }
    }
    if (startsWithLet && isForOf) {
      this.raise(init3.start, "The left-hand side of a for-of loop may not start with 'let'.");
    }
    this.toAssignable(init3, false, refDestructuringErrors);
    this.checkLValPattern(init3);
    return this.parseForIn(node, init3);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node, init3);
};
pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};
pp$8.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement");
};
pp$8.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.start, "'return' outside of function");
  }
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node.argument = null;
  } else {
    node.argument = this.parseExpression();
    this.semicolon();
  }
  return this.finishNode(node, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);
  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR; ) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) {
          this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) {
        this.unexpected();
      }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) {
    this.finishNode(cur, "SwitchCase");
  }
  this.next();
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseCatchClauseParam = function() {
  var param = this.parseBindingAtom();
  var simple = param.type === "Identifier";
  this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
  this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
  this.expect(types$1.parenR);
  return param;
};
pp$8.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseCatchClauseParam();
    } else {
      if (this.options.ecmaVersion < 10) {
        this.unexpected();
      }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer) {
    this.raise(node.start, "Missing catch or finally clause");
  }
  return this.finishNode(node, "TryStatement");
};
pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
  this.next();
  this.parseVar(node, false, kind, allowMissingInitializer);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement");
};
pp$8.parseWithStatement = function(node) {
  if (this.strict) {
    this.raise(this.start, "'with' in strict mode");
  }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement");
};
pp$8.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
  for (var i$1 = 0, list3 = this.labels; i$1 < list3.length; i$1 += 1) {
    var label = list3[i$1];
    if (label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node.start) {
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else {
      break;
    }
  }
  this.labels.push({ name: maybeName, kind, statementStart: this.start });
  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
  if (createNewLexicalScope === void 0) createNewLexicalScope = true;
  if (node === void 0) node = this.startNode();
  node.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) {
    this.enterScope(0);
  }
  while (this.type !== types$1.braceR) {
    var stmt2 = this.parseStatement(null);
    node.body.push(stmt2);
  }
  if (exitStrict) {
    this.strict = false;
  }
  this.next();
  if (createNewLexicalScope) {
    this.exitScope();
  }
  return this.finishNode(node, "BlockStatement");
};
pp$8.parseFor = function(node, init3) {
  node.init = init3;
  this.expect(types$1.semi);
  node.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement");
};
pp$8.parseForIn = function(node, init3) {
  var isForIn = this.type === types$1._in;
  this.next();
  if (init3.type === "VariableDeclaration" && init3.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init3.kind !== "var" || init3.declarations[0].id.type !== "Identifier")) {
    this.raise(
      init3.start,
      (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
    );
  }
  node.left = init3;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
  node.declarations = [];
  node.kind = kind;
  for (; ; ) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) {
      break;
    }
  }
  return node;
};
pp$8.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1;
var FUNC_HANGING_STATEMENT = 2;
var FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
      this.unexpected();
    }
    node.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  if (statement & FUNC_STATEMENT) {
    node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
    if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
      this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
    }
  }
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));
  if (!(statement & FUNC_STATEMENT)) {
    node.id = this.type === types$1.name ? this.parseIdent() : null;
  }
  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node) {
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node, isStatement) {
  this.next();
  var oldStrict = this.strict;
  this.strict = true;
  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element2 = this.parseClassElement(node.superClass !== null);
    if (element2) {
      classBody.body.push(element2);
      if (element2.type === "MethodDefinition" && element2.kind === "constructor") {
        if (hadConstructor) {
          this.raiseRecoverable(element2.start, "Duplicate constructor in the same class");
        }
        hadConstructor = true;
      } else if (element2.key && element2.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element2)) {
        this.raiseRecoverable(element2.key.start, "Identifier '#" + element2.key.name + "' has already been declared");
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) {
    return null;
  }
  var ecmaVersion = this.options.ecmaVersion;
  var node = this.startNode();
  var keyName = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;
  if (this.eatContextual("static")) {
    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node);
      return node;
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node.static = isStatic;
  if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }
  if (keyName) {
    node.computed = false;
    node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node.key.name = keyName;
    this.finishNode(node.key, "Identifier");
  } else {
    this.parseClassElementName(node);
  }
  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node.static && checkKeyName(node, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    if (isConstructor && kind !== "method") {
      this.raise(node.key.start, "Constructor can't have get/set modifier");
    }
    node.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node);
  }
  return node;
};
pp$8.isClassElementNameStart = function() {
  return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element2) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element2.computed = false;
    element2.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element2);
  }
};
pp$8.parseClassMethod = function(method2, isGenerator, isAsync, allowsDirectSuper) {
  var key2 = method2.key;
  if (method2.kind === "constructor") {
    if (isGenerator) {
      this.raise(key2.start, "Constructor can't be a generator");
    }
    if (isAsync) {
      this.raise(key2.start, "Constructor can't be an async method");
    }
  } else if (method2.static && checkKeyName(method2, "prototype")) {
    this.raise(key2.start, "Classes may not have a static property named prototype");
  }
  var value = method2.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  if (method2.kind === "get" && value.params.length !== 0) {
    this.raiseRecoverable(value.start, "getter should have no params");
  }
  if (method2.kind === "set" && value.params.length !== 1) {
    this.raiseRecoverable(value.start, "setter should have exactly one param");
  }
  if (method2.kind === "set" && value.params[0].type === "RestElement") {
    this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
  }
  return this.finishNode(method2, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }
  if (this.eat(types$1.eq)) {
    this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);
    field.value = this.parseMaybeAssign();
    this.exitScope();
  } else {
    field.value = null;
  }
  this.semicolon();
  return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node) {
  node.body = [];
  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt2 = this.parseStatement(null);
    node.body.push(stmt2);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;
  return this.finishNode(node, "StaticBlock");
};
pp$8.parseClassId = function(node, isStatement) {
  if (this.type === types$1.name) {
    node.id = this.parseIdent();
    if (isStatement) {
      this.checkLValSimple(node.id, BIND_LEXICAL, false);
    }
  } else {
    if (isStatement === true) {
      this.unexpected();
    }
    node.id = null;
  }
};
pp$8.parseClassSuper = function(node) {
  node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};
pp$8.enterClassBody = function() {
  var element2 = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  this.privateNameStack.push(element2);
  return element2.declared;
};
pp$8.exitClassBody = function() {
  var ref2 = this.privateNameStack.pop();
  var declared = ref2.declared;
  var used = ref2.used;
  if (!this.options.checkPrivateFields) {
    return;
  }
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i = 0; i < used.length; ++i) {
    var id2 = used[i];
    if (!hasOwn(declared, id2.name)) {
      if (parent) {
        parent.used.push(id2);
      } else {
        this.raiseRecoverable(id2.start, "Private field '#" + id2.name + "' must be declared in an enclosing class");
      }
    }
  }
};
function isPrivateNameConflicted(privateNameMap, element2) {
  var name = element2.key.name;
  var curr = privateNameMap[name];
  var next2 = "true";
  if (element2.type === "MethodDefinition" && (element2.kind === "get" || element2.kind === "set")) {
    next2 = (element2.static ? "s" : "i") + element2.kind;
  }
  if (curr === "iget" && next2 === "iset" || curr === "iset" && next2 === "iget" || curr === "sget" && next2 === "sset" || curr === "sset" && next2 === "sget") {
    privateNameMap[name] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name] = next2;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node, name) {
  var computed = node.computed;
  var key2 = node.key;
  return !computed && (key2.type === "Identifier" && key2.name === name || key2.type === "Literal" && key2.value === name);
}
pp$8.parseExportAllDeclaration = function(node, exports) {
  if (this.options.ecmaVersion >= 11) {
    if (this.eatContextual("as")) {
      node.exported = this.parseModuleExportName();
      this.checkExport(exports, node.exported, this.lastTokStart);
    } else {
      node.exported = null;
    }
  }
  this.expectContextual("from");
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node.source = this.parseExprAtom();
  if (this.options.ecmaVersion >= 16) {
    node.attributes = this.parseWithClause();
  }
  this.semicolon();
  return this.finishNode(node, "ExportAllDeclaration");
};
pp$8.parseExport = function(node, exports) {
  this.next();
  if (this.eat(types$1.star)) {
    return this.parseExportAllDeclaration(node, exports);
  }
  if (this.eat(types$1._default)) {
    this.checkExport(exports, "default", this.lastTokStart);
    node.declaration = this.parseExportDefaultDeclaration();
    return this.finishNode(node, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseExportDeclaration(node);
    if (node.declaration.type === "VariableDeclaration") {
      this.checkVariableExport(exports, node.declaration.declarations);
    } else {
      this.checkExport(exports, node.declaration.id, node.declaration.id.start);
    }
    node.specifiers = [];
    node.source = null;
    if (this.options.ecmaVersion >= 16) {
      node.attributes = [];
    }
  } else {
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node.source = this.parseExprAtom();
      if (this.options.ecmaVersion >= 16) {
        node.attributes = this.parseWithClause();
      }
    } else {
      for (var i = 0, list3 = node.specifiers; i < list3.length; i += 1) {
        var spec = list3[i];
        this.checkUnreserved(spec.local);
        this.checkLocalExport(spec.local);
        if (spec.local.type === "Literal") {
          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }
      node.source = null;
      if (this.options.ecmaVersion >= 16) {
        node.attributes = [];
      }
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};
pp$8.parseExportDeclaration = function(node) {
  return this.parseStatement(null);
};
pp$8.parseExportDefaultDeclaration = function() {
  var isAsync;
  if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
    var fNode = this.startNode();
    this.next();
    if (isAsync) {
      this.next();
    }
    return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
  } else if (this.type === types$1._class) {
    var cNode = this.startNode();
    return this.parseClass(cNode, "nullableID");
  } else {
    var declaration2 = this.parseMaybeAssign();
    this.semicolon();
    return declaration2;
  }
};
pp$8.checkExport = function(exports, name, pos) {
  if (!exports) {
    return;
  }
  if (typeof name !== "string") {
    name = name.type === "Identifier" ? name.name : name.value;
  }
  if (hasOwn(exports, name)) {
    this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
  }
  exports[name] = true;
};
pp$8.checkPatternExport = function(exports, pat) {
  var type = pat.type;
  if (type === "Identifier") {
    this.checkExport(exports, pat, pat.start);
  } else if (type === "ObjectPattern") {
    for (var i = 0, list3 = pat.properties; i < list3.length; i += 1) {
      var prop2 = list3[i];
      this.checkPatternExport(exports, prop2);
    }
  } else if (type === "ArrayPattern") {
    for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];
      if (elt) {
        this.checkPatternExport(exports, elt);
      }
    }
  } else if (type === "Property") {
    this.checkPatternExport(exports, pat.value);
  } else if (type === "AssignmentPattern") {
    this.checkPatternExport(exports, pat.left);
  } else if (type === "RestElement") {
    this.checkPatternExport(exports, pat.argument);
  }
};
pp$8.checkVariableExport = function(exports, decls) {
  if (!exports) {
    return;
  }
  for (var i = 0, list3 = decls; i < list3.length; i += 1) {
    var decl = list3[i];
    this.checkPatternExport(exports, decl.id);
  }
};
pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifier = function(exports) {
  var node = this.startNode();
  node.local = this.parseModuleExportName();
  node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
  this.checkExport(
    exports,
    node.exported,
    node.exported.start
  );
  return this.finishNode(node, "ExportSpecifier");
};
pp$8.parseExportSpecifiers = function(exports) {
  var nodes = [], first = true;
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseExportSpecifier(exports));
  }
  return nodes;
};
pp$8.parseImport = function(node) {
  this.next();
  if (this.type === types$1.string) {
    node.specifiers = empty$1;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  if (this.options.ecmaVersion >= 16) {
    node.attributes = this.parseWithClause();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};
pp$8.parseImportSpecifier = function() {
  var node = this.startNode();
  node.imported = this.parseModuleExportName();
  if (this.eatContextual("as")) {
    node.local = this.parseIdent();
  } else {
    this.checkUnreserved(node.imported);
    node.local = node.imported;
  }
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportSpecifier");
};
pp$8.parseImportDefaultSpecifier = function() {
  var node = this.startNode();
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportDefaultSpecifier");
};
pp$8.parseImportNamespaceSpecifier = function() {
  var node = this.startNode();
  this.next();
  this.expectContextual("as");
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportNamespaceSpecifier");
};
pp$8.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types$1.name) {
    nodes.push(this.parseImportDefaultSpecifier());
    if (!this.eat(types$1.comma)) {
      return nodes;
    }
  }
  if (this.type === types$1.star) {
    nodes.push(this.parseImportNamespaceSpecifier());
    return nodes;
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseImportSpecifier());
  }
  return nodes;
};
pp$8.parseWithClause = function() {
  var nodes = [];
  if (!this.eat(types$1._with)) {
    return nodes;
  }
  this.expect(types$1.braceL);
  var attributeKeys = {};
  var first = true;
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var attr = this.parseImportAttribute();
    var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
    if (hasOwn(attributeKeys, keyName)) {
      this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'");
    }
    attributeKeys[keyName] = true;
    nodes.push(attr);
  }
  return nodes;
};
pp$8.parseImportAttribute = function() {
  var node = this.startNode();
  node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
  this.expect(types$1.colon);
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node.value = this.parseExprAtom();
  return this.finishNode(node, "ImportAttribute");
};
pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral;
  }
  return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
  (this.input[statement.start] === '"' || this.input[statement.start] === "'");
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await") {
          this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
        }
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        node.type = "ObjectPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        for (var i = 0, list3 = node.properties; i < list3.length; i += 1) {
          var prop2 = list3[i];
          this.toAssignable(prop2, isBinding);
          if (prop2.type === "RestElement" && (prop2.argument.type === "ArrayPattern" || prop2.argument.type === "ObjectPattern")) {
            this.raise(prop2.argument.start, "Unexpected token");
          }
        }
        break;
      case "Property":
        if (node.kind !== "init") {
          this.raise(node.key.start, "Object pattern can't contain getter or setter");
        }
        this.toAssignable(node.value, isBinding);
        break;
      case "ArrayExpression":
        node.type = "ArrayPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        this.toAssignableList(node.elements, isBinding);
        break;
      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);
        if (node.argument.type === "AssignmentPattern") {
          this.raise(node.argument.start, "Rest elements cannot have a default value");
        }
        break;
      case "AssignmentExpression":
        if (node.operator !== "=") {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
        }
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
        break;
      case "ChainExpression":
        this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!isBinding) {
          break;
        }
      default:
        this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) {
    this.checkPatternErrors(refDestructuringErrors, true);
  }
  return node;
};
pp$7.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) {
      this.toAssignable(elt, isBinding);
    }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
      this.unexpected(last.argument.start);
    }
  }
  return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement");
};
pp$7.parseRestBinding = function() {
  var node = this.startNode();
  this.next();
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
    this.unexpected();
  }
  node.argument = this.parseBindingAtom();
  return this.finishNode(node, "RestElement");
};
pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
      case types$1.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types$1.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern");
      case types$1.braceL:
        return this.parseObj(true);
    }
  }
  return this.parseIdent();
};
pp$7.parseBindingList = function(close2, allowEmpty, allowTrailingComma, allowModifiers) {
  var elts = [], first = true;
  while (!this.eat(close2)) {
    if (first) {
      first = false;
    } else {
      this.expect(types$1.comma);
    }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close2)) {
      break;
    } else if (this.type === types$1.ellipsis) {
      var rest2 = this.parseRestBinding();
      this.parseBindingListItem(rest2);
      elts.push(rest2);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      this.expect(close2);
      break;
    } else {
      elts.push(this.parseAssignableListItem(allowModifiers));
    }
  }
  return elts;
};
pp$7.parseAssignableListItem = function(allowModifiers) {
  var elem = this.parseMaybeDefault(this.start, this.startLoc);
  this.parseBindingListItem(elem);
  return elem;
};
pp$7.parseBindingListItem = function(param) {
  return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
    return left;
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  var isBind = bindingType !== BIND_NONE;
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
        this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }
      if (isBind) {
        if (bindingType === BIND_LEXICAL && expr.name === "let") {
          this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
        }
        if (checkClashes) {
          if (hasOwn(checkClashes, expr.name)) {
            this.raiseRecoverable(expr.start, "Argument name clash");
          }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_OUTSIDE) {
          this.declareName(expr.name, bindingType, expr.start);
        }
      }
      break;
    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding member expression");
      }
      break;
    case "ParenthesizedExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding parenthesized expression");
      }
      return this.checkLValSimple(expr.expression, bindingType, checkClashes);
    default:
      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  switch (expr.type) {
    case "ObjectPattern":
      for (var i = 0, list3 = expr.properties; i < list3.length; i += 1) {
        var prop2 = list3[i];
        this.checkLValInnerPattern(prop2, bindingType, checkClashes);
      }
      break;
    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];
        if (elem) {
          this.checkLValInnerPattern(elem, bindingType, checkClashes);
        }
      }
      break;
    default:
      this.checkLValSimple(expr, bindingType, checkClashes);
  }
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  switch (expr.type) {
    case "Property":
      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(expr.left, bindingType, checkClashes);
      break;
    case "RestElement":
      this.checkLValPattern(expr.argument, bindingType, checkClashes);
      break;
    default:
      this.checkLValPattern(expr, bindingType, checkClashes);
  }
};
var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};
var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function(p) {
    return p.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser.prototype;
pp$6.initialContext = function() {
  return [types.b_stat];
};
pp$6.curContext = function() {
  return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types.f_expr || parent === types.f_stat) {
    return true;
  }
  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
    return !parent.isExpr;
  }
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
    return true;
  }
  if (prevType === types$1.braceL) {
    return parent === types.b_stat;
  }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
    return false;
  }
  return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this.context[i];
    if (context.token === "function") {
      return context.generator;
    }
  }
  return false;
};
pp$6.updateContext = function(prevType) {
  var update2, type = this.type;
  if (type.keyword && prevType === types$1.dot) {
    this.exprAllowed = false;
  } else if (update2 = type.updateContext) {
    update2.call(this, prevType);
  } else {
    this.exprAllowed = type.beforeExpr;
  }
};
pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};
types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};
types$1.dollarBraceL.updateContext = function() {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};
types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};
types$1.incDec.updateContext = function() {
};
types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
    this.context.push(types.f_expr);
  } else {
    this.context.push(types.f_stat);
  }
  this.exprAllowed = false;
};
types$1.colon.updateContext = function() {
  if (this.curContext().token === "function") {
    this.context.pop();
  }
  this.exprAllowed = true;
};
types$1.backQuote.updateContext = function() {
  if (this.curContext() === types.q_tmpl) {
    this.context.pop();
  } else {
    this.context.push(types.q_tmpl);
  }
  this.exprAllowed = false;
};
types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types.f_expr) {
      this.context[index] = types.f_expr_gen;
    } else {
      this.context[index] = types.f_gen;
    }
  }
  this.exprAllowed = true;
};
types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
      allowed = true;
    }
  }
  this.exprAllowed = allowed;
};
var pp$5 = Parser.prototype;
pp$5.checkPropClash = function(prop2, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop2.type === "SpreadElement") {
    return;
  }
  if (this.options.ecmaVersion >= 6 && (prop2.computed || prop2.method || prop2.shorthand)) {
    return;
  }
  var key2 = prop2.key;
  var name;
  switch (key2.type) {
    case "Identifier":
      name = key2.name;
      break;
    case "Literal":
      name = String(key2.value);
      break;
    default:
      return;
  }
  var kind = prop2.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key2.start;
          }
        } else {
          this.raiseRecoverable(key2.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return;
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition) {
      this.raiseRecoverable(key2.start, "Redefinition of property");
    }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types$1.comma)) {
      node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
    }
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) {
      return this.parseYield(forInit);
    } else {
      this.exprAllowed = false;
    }
  }
  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors();
    ownDestructuringErrors = true;
  }
  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) {
    left = afterLeftParse.call(this, left, startPos, startLoc);
  }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    if (this.type === types$1.eq) {
      left = this.toAssignable(left, false, refDestructuringErrors);
    }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left.start) {
      refDestructuringErrors.shorthandAssign = -1;
    }
    if (this.type === types$1.eq) {
      this.checkLValPattern(left);
    } else {
      this.checkLValSimple(left);
    }
    node.left = left;
    this.next();
    node.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) {
      refDestructuringErrors.doubleProto = oldDoubleProto;
    }
    return this.finishNode(node, "AssignmentExpression");
  } else {
    if (ownDestructuringErrors) {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
  }
  if (oldParenAssign > -1) {
    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }
  if (oldTrailingComma > -1) {
    refDestructuringErrors.trailingComma = oldTrailingComma;
  }
  return left;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  if (this.eat(types$1.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec = this.type.binop;
  if (prec != null && (!forInit || this.type !== types$1._in)) {
    if (prec > minPrec) {
      var logical3 = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        prec = types$1.logicalAND.binop;
      }
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical3 || coalesce);
      if (logical3 && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
    }
  }
  return left;
};
pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical3) {
  if (right.type === "PrivateIdentifier") {
    this.raise(right.start, "Private identifier can only be left side of binary expression");
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical3 ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update2 = this.type === types$1.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true, update2, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update2) {
      this.checkLValSimple(node.argument);
    } else if (this.strict && node.operator === "delete" && isLocalVariableAccess(node.argument)) {
      this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
    } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
      this.raiseRecoverable(node.start, "Private fields can not be deleted");
    } else {
      sawUnary = true;
    }
    expr = this.finishNode(node, update2 ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
      this.unexpected();
    }
    expr = this.parsePrivateIdent();
    if (this.type !== types$1._in) {
      this.unexpected();
    }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }
  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary) {
      this.unexpected(this.lastTokStart);
    } else {
      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
    }
  } else {
    return expr;
  }
};
function isLocalVariableAccess(node) {
  return node.type === "Identifier" || node.type === "ParenthesizedExpression" && isLocalVariableAccess(node.expression);
}
function isPrivateFieldAccess(node) {
  return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression) || node.type === "ParenthesizedExpression" && isPrivateFieldAccess(node.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
    return expr;
  }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
      refDestructuringErrors.parenthesizedAssign = -1;
    }
    if (refDestructuringErrors.parenthesizedBind >= result.start) {
      refDestructuringErrors.parenthesizedBind = -1;
    }
    if (refDestructuringErrors.trailingComma >= result.start) {
      refDestructuringErrors.trailingComma = -1;
    }
  }
  return result;
};
pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
  var optionalChained = false;
  while (true) {
    var element2 = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
    if (element2.optional) {
      optionalChained = true;
    }
    if (element2 === base || element2.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element2;
        element2 = this.finishNode(chainNode, "ChainExpression");
      }
      return element2;
    }
    base = element2;
  }
};
pp$5.shouldParseAsyncArrow = function() {
  return !this.canInsertSemicolon() && this.eat(types$1.arrow);
};
pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
};
pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional) {
    this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  }
  var computed = this.eat(types$1.bracketL);
  if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    if (computed) {
      node.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base.type !== "Super") {
      node.property = this.parsePrivateIdent();
    } else {
      node.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node.computed = !!computed;
    if (optionalSupported) {
      node.optional = optional;
    }
    base = this.finishNode(node, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0) {
        this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
      }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (optionalSupported) {
      node$1.optional = optional;
    }
    base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({ isTagged: true });
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
  if (this.type === types$1.slash) {
    this.readRegexp();
  }
  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
    case types$1._super:
      if (!this.allowSuper) {
        this.raise(this.start, "'super' keyword outside a method");
      }
      node = this.startNode();
      this.next();
      if (this.type === types$1.parenL && !this.allowDirectSuper) {
        this.raise(node.start, "super() call outside constructor of a subclass");
      }
      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
        this.unexpected();
      }
      return this.finishNode(node, "Super");
    case types$1._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression");
    case types$1.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id2 = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id2.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
        this.overrideContext(types.f_expr);
        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
      }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types$1.arrow)) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], false, forInit);
        }
        if (this.options.ecmaVersion >= 8 && id2.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
          id2 = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
            this.unexpected();
          }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], true, forInit);
        }
      }
      return id2;
    case types$1.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = { pattern: value.pattern, flags: value.flags };
      return node;
    case types$1.num:
    case types$1.string:
      return this.parseLiteral(this.value);
    case types$1._null:
    case types$1._true:
    case types$1._false:
      node = this.startNode();
      node.value = this.type === types$1._null ? null : this.type === types$1._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");
    case types$1.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
          refDestructuringErrors.parenthesizedAssign = start;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = start;
        }
      }
      return expr;
    case types$1.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression");
    case types$1.braceL:
      this.overrideContext(types.b_expr);
      return this.parseObj(false, refDestructuringErrors);
    case types$1._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, 0);
    case types$1._class:
      return this.parseClass(this.startNode(), false);
    case types$1._new:
      return this.parseNew();
    case types$1.backQuote:
      return this.parseTemplate();
    case types$1._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport(forNew);
      } else {
        return this.unexpected();
      }
    default:
      return this.parseExprAtomDefault();
  }
};
pp$5.parseExprAtomDefault = function() {
  this.unexpected();
};
pp$5.parseExprImport = function(forNew) {
  var node = this.startNode();
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword import");
  }
  this.next();
  if (this.type === types$1.parenL && !forNew) {
    return this.parseDynamicImport(node);
  } else if (this.type === types$1.dot) {
    var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
    meta.name = "import";
    node.meta = this.finishNode(meta, "Identifier");
    return this.parseImportMeta(node);
  } else {
    this.unexpected();
  }
};
pp$5.parseDynamicImport = function(node) {
  this.next();
  node.source = this.parseMaybeAssign();
  if (this.options.ecmaVersion >= 16) {
    if (!this.eat(types$1.parenR)) {
      this.expect(types$1.comma);
      if (!this.afterTrailingComma(types$1.parenR)) {
        node.options = this.parseMaybeAssign();
        if (!this.eat(types$1.parenR)) {
          this.expect(types$1.comma);
          if (!this.afterTrailingComma(types$1.parenR)) {
            this.unexpected();
          }
        }
      } else {
        node.options = null;
      }
    } else {
      node.options = null;
    }
  } else {
    if (!this.eat(types$1.parenR)) {
      var errorPos = this.start;
      if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
        this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
      } else {
        this.unexpected(errorPos);
      }
    }
  }
  return this.finishNode(node, "ImportExpression");
};
pp$5.parseImportMeta = function(node) {
  this.next();
  var containsEsc = this.containsEsc;
  node.property = this.parseIdent(true);
  if (node.property.name !== "meta") {
    this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
  }
  if (containsEsc) {
    this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
  }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
    this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
  }
  return this.finishNode(node, "MetaProperty");
};
pp$5.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
    node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
  }
  this.next();
  return this.finishNode(node, "Literal");
};
pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val;
};
pp$5.shouldParseArrow = function(exprList) {
  return !this.canInsertSemicolon();
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types$1.parenR) {
      first ? first = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break;
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) {
          this.raiseRecoverable(
            this.start,
            "Comma is not permitted after the rest element"
          );
        }
        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);
    if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
    }
    if (!exprList.length || lastIsComma) {
      this.unexpected(this.lastTokStart);
    }
    if (spreadStart) {
      this.unexpected(spreadStart);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }
  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};
pp$5.parseParenItem = function(item) {
  return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty = [];
pp$5.parseNew = function() {
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  }
  var node = this.startNode();
  this.next();
  if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
    var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
    meta.name = "new";
    node.meta = this.finishNode(meta, "Identifier");
    this.next();
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target") {
      this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
    }
    if (containsEsc) {
      this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
    }
    if (!this.allowNewDotTarget) {
      this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
    }
    return this.finishNode(node, "MetaProperty");
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
  if (this.eat(types$1.parenL)) {
    node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
  } else {
    node.arguments = empty;
  }
  return this.finishNode(node, "NewExpression");
};
pp$5.parseTemplateElement = function(ref2) {
  var isTagged = ref2.isTagged;
  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value.replace(/\r\n?/g, "\n"),
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref2) {
  if (ref2 === void 0) ref2 = {};
  var isTagged = ref2.isTagged;
  if (isTagged === void 0) isTagged = false;
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({ isTagged });
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) {
      this.raise(this.pos, "Unterminated template literal");
    }
    this.expect(types$1.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop2) {
  return !prop2.computed && prop2.key.type === "Identifier" && prop2.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var prop2 = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) {
      this.checkPropClash(prop2, propHash, refDestructuringErrors);
    }
    node.properties.push(prop2);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop2 = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop2.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop2, "RestElement");
    }
    prop2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    return this.finishNode(prop2, "SpreadElement");
  }
  if (this.options.ecmaVersion >= 6) {
    prop2.method = false;
    prop2.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern) {
      isGenerator = this.eat(types$1.star);
    }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop2);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop2)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop2);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop2, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop2, "Property");
};
pp$5.parseGetterSetter = function(prop2) {
  var kind = prop2.key.name;
  this.parsePropertyName(prop2);
  prop2.value = this.parseMethod(false);
  prop2.kind = kind;
  var paramCount = prop2.kind === "get" ? 0 : 1;
  if (prop2.value.params.length !== paramCount) {
    var start = prop2.value.start;
    if (prop2.kind === "get") {
      this.raiseRecoverable(start, "getter should have no params");
    } else {
      this.raiseRecoverable(start, "setter should have exactly one param");
    }
  } else {
    if (prop2.kind === "set" && prop2.value.params[0].type === "RestElement") {
      this.raiseRecoverable(prop2.value.params[0].start, "Setter cannot use rest params");
    }
  }
};
pp$5.parsePropertyValue = function(prop2, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon) {
    this.unexpected();
  }
  if (this.eat(types$1.colon)) {
    prop2.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop2.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) {
      this.unexpected();
    }
    prop2.method = true;
    prop2.value = this.parseMethod(isGenerator, isAsync);
    prop2.kind = "init";
  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop2.computed && prop2.key.type === "Identifier" && (prop2.key.name === "get" || prop2.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.parseGetterSetter(prop2);
  } else if (this.options.ecmaVersion >= 6 && !prop2.computed && prop2.key.type === "Identifier") {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.checkUnreserved(prop2.key);
    if (prop2.key.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = startPos;
    }
    if (isPattern) {
      prop2.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop2.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0) {
        refDestructuringErrors.shorthandAssign = this.start;
      }
      prop2.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop2.key));
    } else {
      prop2.value = this.copyNode(prop2.key);
    }
    prop2.kind = "init";
    prop2.shorthand = true;
  } else {
    this.unexpected();
  }
};
pp$5.parsePropertyName = function(prop2) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop2.computed = true;
      prop2.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop2.key;
    } else {
      prop2.computed = false;
    }
  }
  return prop2.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
    node.generator = node.expression = false;
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = false;
  }
};
pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) {
    node.generator = isGenerator;
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true, false);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
  var isExpression = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;
  if (isExpression) {
    node.body = this.parseMaybeAssign(forInit);
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      if (useStrict && nonSimple) {
        this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
    }
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) {
      this.strict = true;
    }
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
    if (this.strict && node.id) {
      this.checkLValSimple(node.id, BIND_OUTSIDE);
    }
    node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
  for (var i = 0, list3 = params; i < list3.length; i += 1) {
    var param = list3[i];
    if (param.type !== "Identifier") {
      return false;
    }
  }
  return true;
};
pp$5.checkParams = function(node, allowDuplicates) {
  var nameHash = /* @__PURE__ */ Object.create(null);
  for (var i = 0, list3 = node.params; i < list3.length; i += 1) {
    var param = list3[i];
    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};
pp$5.parseExprList = function(close2, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close2)) {
    if (!first) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close2)) {
        break;
      }
    } else {
      first = false;
    }
    var elt = void 0;
    if (allowEmpty && this.type === types$1.comma) {
      elt = null;
    } else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts;
};
pp$5.checkUnreserved = function(ref2) {
  var start = ref2.start;
  var end = ref2.end;
  var name = ref2.name;
  if (this.inGenerator && name === "yield") {
    this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
  }
  if (this.inAsync && name === "await") {
    this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
  }
  if (!(this.currentThisScope().flags & SCOPE_VAR) && name === "arguments") {
    this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
  }
  if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
    this.raise(start, "Cannot use " + name + " in class static initialization block");
  }
  if (this.keywords.test(name)) {
    this.raise(start, "Unexpected keyword '" + name + "'");
  }
  if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
    return;
  }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync && name === "await") {
      this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
    }
    this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
  }
};
pp$5.parseIdent = function(liberal) {
  var node = this.parseIdentNode();
  this.next(!!liberal);
  this.finishNode(node, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = node.start;
    }
  }
  return node;
};
pp$5.parseIdentNode = function() {
  var node = this.startNode();
  if (this.type === types$1.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;
    if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
    this.type = types$1.name;
  } else {
    this.unexpected();
  }
  return node;
};
pp$5.parsePrivateIdent = function() {
  var node = this.startNode();
  if (this.type === types$1.privateId) {
    node.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "PrivateIdentifier");
  if (this.options.checkPrivateFields) {
    if (this.privateNameStack.length === 0) {
      this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
    } else {
      this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
    }
  }
  return node;
};
pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) {
    this.yieldPos = this.start;
  }
  var node = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types$1.star);
    node.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) {
    this.awaitPos = this.start;
  }
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  if (this.sourceFile) {
    message += " in " + this.sourceFile;
  }
  var err = new SyntaxError(message);
  err.pos = pos;
  err.loc = loc;
  err.raisedAt = this.pos;
  throw err;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
};
var pp$3 = Parser.prototype;
var Scope = function Scope2(flags) {
  this.flags = flags;
  this.var = [];
  this.lexical = [];
  this.functions = [];
};
pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};
pp$3.exitScope = function() {
  this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope) {
  return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$3.declareName = function(name, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
    scope.lexical.push(name);
    if (this.inModule && scope.flags & SCOPE_TOP) {
      delete this.undefinedExports[name];
    }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar) {
      redeclared = scope$2.lexical.indexOf(name) > -1;
    } else {
      redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
    }
    scope$2.functions.push(name);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
        redeclared = true;
        break;
      }
      scope$3.var.push(name);
      if (this.inModule && scope$3.flags & SCOPE_TOP) {
        delete this.undefinedExports[name];
      }
      if (scope$3.flags & SCOPE_VAR) {
        break;
      }
    }
  }
  if (redeclared) {
    this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
  }
};
pp$3.checkLocalExport = function(id2) {
  if (this.scopeStack[0].lexical.indexOf(id2.name) === -1 && this.scopeStack[0].var.indexOf(id2.name) === -1) {
    this.undefinedExports[id2.name] = id2;
  }
};
pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) {
      return scope;
    }
  }
};
pp$3.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) && !(scope.flags & SCOPE_ARROW)) {
      return scope;
    }
  }
};
var Node = function Node2(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations) {
    this.loc = new SourceLocation(parser, loc);
  }
  if (parser.options.directSourceFile) {
    this.sourceFile = parser.options.directSourceFile;
  }
  if (parser.options.ranges) {
    this.range = [pos, 0];
  }
};
var pp$2 = Parser.prototype;
pp$2.startNode = function() {
  return new Node(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc);
};
function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations) {
    node.loc.end = loc;
  }
  if (this.options.ranges) {
    node.range[1] = pos;
  }
  return node;
}
pp$2.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc);
};
pp$2.copyNode = function(node) {
  var newNode = new Node(this, node.start, this.startLoc);
  for (var prop2 in node) {
    newNode[prop2] = node[prop2];
  }
  return newNode;
};
var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties,
  14: ecma14BinaryProperties
};
var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
var unicodeBinaryPropertiesOfStrings = {
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: ecma14BinaryPropertiesOfStrings
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues,
  14: ecma14ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion) {
  var d = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;
  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
for (i = 0, list3 = [9, 10, 11, 12, 13, 14]; i < list3.length; i += 1) {
  ecmaVersion = list3[i];
  buildUnicodeData(ecmaVersion);
}
var ecmaVersion;
var i;
var list3;
var pp$1 = Parser.prototype;
var BranchID = function BranchID2(parent, base) {
  this.parent = parent;
  this.base = base || this;
};
BranchID.prototype.separatedFrom = function separatedFrom(alt) {
  for (var self2 = this; self2; self2 = self2.parent) {
    for (var other = alt; other; other = other.parent) {
      if (self2.base === other.base && self2 !== other) {
        return true;
      }
    }
  }
  return false;
};
BranchID.prototype.sibling = function sibling() {
  return new BranchID(this.parent, this.base);
};
var RegExpValidationState = function RegExpValidationState2(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
  this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchV = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = /* @__PURE__ */ Object.create(null);
  this.backReferenceNames = [];
  this.branchID = null;
};
RegExpValidationState.prototype.reset = function reset3(start, pattern, flags) {
  var unicodeSets = flags.indexOf("v") !== -1;
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
    this.switchU = true;
    this.switchV = true;
    this.switchN = true;
  } else {
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchV = false;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  }
};
RegExpValidationState.prototype.raise = function raise(message) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
RegExpValidationState.prototype.at = function at(i, forceU) {
  if (forceU === void 0) forceU = false;
  var s = this.source;
  var l2 = s.length;
  if (i >= l2) {
    return -1;
  }
  var c2 = s.charCodeAt(i);
  if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i + 1 >= l2) {
    return c2;
  }
  var next2 = s.charCodeAt(i + 1);
  return next2 >= 56320 && next2 <= 57343 ? (c2 << 10) + next2 - 56613888 : c2;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
  if (forceU === void 0) forceU = false;
  var s = this.source;
  var l2 = s.length;
  if (i >= l2) {
    return l2;
  }
  var c2 = s.charCodeAt(i), next2;
  if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i + 1 >= l2 || (next2 = s.charCodeAt(i + 1)) < 56320 || next2 > 57343) {
    return i + 1;
  }
  return i + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
  if (forceU === void 0) forceU = false;
  return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
  if (forceU === void 0) forceU = false;
  return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
  if (forceU === void 0) forceU = false;
  this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch, forceU) {
  if (forceU === void 0) forceU = false;
  if (this.current(forceU) === ch) {
    this.advance(forceU);
    return true;
  }
  return false;
};
RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
  if (forceU === void 0) forceU = false;
  var pos = this.pos;
  for (var i = 0, list3 = chs; i < list3.length; i += 1) {
    var ch = list3[i];
    var current2 = this.at(pos, forceU);
    if (current2 === -1 || current2 !== ch) {
      return false;
    }
    pos = this.nextIndex(pos, forceU);
  }
  this.pos = pos;
  return true;
};
pp$1.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;
  var u = false;
  var v = false;
  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
    if (flag === "u") {
      u = true;
    }
    if (flag === "v") {
      v = true;
    }
  }
  if (this.options.ecmaVersion >= 15 && u && v) {
    this.raise(state.start, "Invalid regular expression flag");
  }
};
function hasProp(obj) {
  for (var _ in obj) {
    return true;
  }
  return false;
}
pp$1.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);
  if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};
pp$1.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames = /* @__PURE__ */ Object.create(null);
  state.backReferenceNames.length = 0;
  state.branchID = null;
  this.regexp_disjunction(state);
  if (state.pos !== state.source.length) {
    if (state.eat(
      41
      /* ) */
    )) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(
      93
      /* ] */
    ) || state.eat(
      125
      /* } */
    )) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list3 = state.backReferenceNames; i < list3.length; i += 1) {
    var name = list3[i];
    if (!state.groupNames[name]) {
      state.raise("Invalid named capture referenced");
    }
  }
};
pp$1.regexp_disjunction = function(state) {
  var trackDisjunction = this.options.ecmaVersion >= 16;
  if (trackDisjunction) {
    state.branchID = new BranchID(state.branchID, null);
  }
  this.regexp_alternative(state);
  while (state.eat(
    124
    /* | */
  )) {
    if (trackDisjunction) {
      state.branchID = state.branchID.sibling();
    }
    this.regexp_alternative(state);
  }
  if (trackDisjunction) {
    state.branchID = state.branchID.parent;
  }
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(
    123
    /* { */
  )) {
    state.raise("Lone quantifier brackets");
  }
};
pp$1.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
  }
};
pp$1.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true;
  }
  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true;
  }
  return false;
};
pp$1.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;
  if (state.eat(
    94
    /* ^ */
  ) || state.eat(
    36
    /* $ */
  )) {
    return true;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    if (state.eat(
      66
      /* B */
    ) || state.eat(
      98
      /* b */
    )) {
      return true;
    }
    state.pos = start;
  }
  if (state.eat(
    40
    /* ( */
  ) && state.eat(
    63
    /* ? */
  )) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(
        60
        /* < */
      );
    }
    if (state.eat(
      61
      /* = */
    ) || state.eat(
      33
      /* ! */
    )) {
      this.regexp_disjunction(state);
      if (!state.eat(
        41
        /* ) */
      )) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true;
    }
  }
  state.pos = start;
  return false;
};
pp$1.regexp_eatQuantifier = function(state, noError) {
  if (noError === void 0) noError = false;
  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(
      63
      /* ? */
    );
    return true;
  }
  return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
  return state.eat(
    42
    /* * */
  ) || state.eat(
    43
    /* + */
  ) || state.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(
    123
    /* { */
  )) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(
        44
        /* , */
      ) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(
        125
        /* } */
      )) {
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true;
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatAtom = function(state) {
  return this.regexp_eatPatternCharacters(state) || state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(
    40
    /* ( */
  )) {
    if (state.eat(
      63
      /* ? */
    )) {
      if (this.options.ecmaVersion >= 16) {
        var addModifiers = this.regexp_eatModifiers(state);
        var hasHyphen = state.eat(
          45
          /* - */
        );
        if (addModifiers || hasHyphen) {
          for (var i = 0; i < addModifiers.length; i++) {
            var modifier = addModifiers.charAt(i);
            if (addModifiers.indexOf(modifier, i + 1) > -1) {
              state.raise("Duplicate regular expression modifiers");
            }
          }
          if (hasHyphen) {
            var removeModifiers = this.regexp_eatModifiers(state);
            if (!addModifiers && !removeModifiers && state.current() === 58) {
              state.raise("Invalid regular expression modifiers");
            }
            for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {
              var modifier$1 = removeModifiers.charAt(i$1);
              if (removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) {
                state.raise("Duplicate regular expression modifiers");
              }
            }
          }
        }
      }
      if (state.eat(
        58
        /* : */
      )) {
        this.regexp_disjunction(state);
        if (state.eat(
          41
          /* ) */
        )) {
          return true;
        }
        state.raise("Unterminated group");
      }
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatCapturingGroup = function(state) {
  if (state.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 63) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(
      41
      /* ) */
    )) {
      state.numCapturingParens += 1;
      return true;
    }
    state.raise("Unterminated group");
  }
  return false;
};
pp$1.regexp_eatModifiers = function(state) {
  var modifiers2 = "";
  var ch = 0;
  while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
    modifiers2 += codePointToString(ch);
    state.advance();
  }
  return modifiers2;
};
function isRegularExpressionModifier(ch) {
  return ch === 105 || ch === 109 || ch === 115;
}
pp$1.regexp_eatExtendedAtom = function(state) {
  return state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isSyntaxCharacter(ch) {
  return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_groupSpecifier = function(state) {
  if (state.eat(
    63
    /* ? */
  )) {
    if (!this.regexp_eatGroupName(state)) {
      state.raise("Invalid group");
    }
    var trackDisjunction = this.options.ecmaVersion >= 16;
    var known = state.groupNames[state.lastStringValue];
    if (known) {
      if (trackDisjunction) {
        for (var i = 0, list3 = known; i < list3.length; i += 1) {
          var altID = list3[i];
          if (!altID.separatedFrom(state.branchID)) {
            state.raise("Duplicate capture group name");
          }
        }
      } else {
        state.raise("Duplicate capture group name");
      }
    }
    if (trackDisjunction) {
      (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
    } else {
      state.groupNames[state.lastStringValue] = true;
    }
  }
};
pp$1.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
      62
      /* > */
    )) {
      return true;
    }
    state.raise("Invalid capture group name");
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
pp$1.regexp_eatAtomEscape = function(state) {
  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
    return true;
  }
  if (state.switchU) {
    if (state.current() === 99) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false;
};
pp$1.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n2 = state.lastIntValue;
    if (state.switchU) {
      if (n2 > state.maxBackReference) {
        state.maxBackReference = n2;
      }
      return true;
    }
    if (n2 <= state.numCapturingParens) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatKGroupName = function(state) {
  if (state.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true;
    }
    state.raise("Invalid named reference");
  }
  return false;
};
pp$1.regexp_eatCharacterEscape = function(state) {
  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$1.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatZero = function(state) {
  if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 116) {
    state.lastIntValue = 9;
    state.advance();
    return true;
  }
  if (ch === 110) {
    state.lastIntValue = 10;
    state.advance();
    return true;
  }
  if (ch === 118) {
    state.lastIntValue = 11;
    state.advance();
    return true;
  }
  if (ch === 102) {
    state.lastIntValue = 12;
    state.advance();
    return true;
  }
  if (ch === 114) {
    state.lastIntValue = 13;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
function isControlLetter(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
  if (forceU === void 0) forceU = false;
  var start = state.pos;
  var switchU = forceU || state.switchU;
  if (state.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (switchU && lead >= 55296 && lead <= 56319) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(
          92
          /* \ */
        ) && state.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 56320 && trail <= 57343) {
            state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
            return true;
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true;
    }
    if (switchU && state.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(state) && state.eat(
      125
      /* } */
    ) && isValidUnicode(state.lastIntValue)) {
      return true;
    }
    if (switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }
  return false;
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true;
    }
    if (state.eat(
      47
      /* / */
    )) {
      state.lastIntValue = 47;
      return true;
    }
    return false;
  }
  var ch = state.current();
  if (ch !== 99 && (!state.switchN || ch !== 107)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 49 && ch <= 57) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
      state.advance();
    } while ((ch = state.current()) >= 48 && ch <= 57);
    return true;
  }
  return false;
};
var CharSetNone = 0;
var CharSetOk = 1;
var CharSetString = 2;
pp$1.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();
  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return CharSetOk;
  }
  var negate = false;
  if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
    state.lastIntValue = -1;
    state.advance();
    var result;
    if (state.eat(
      123
      /* { */
    ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(
      125
      /* } */
    )) {
      if (negate && result === CharSetString) {
        state.raise("Invalid property name");
      }
      return result;
    }
    state.raise("Invalid property name");
  }
  return CharSetNone;
};
function isCharacterClassEscape(ch) {
  return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(
    61
    /* = */
  )) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return CharSetOk;
    }
  }
  state.pos = start;
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
  }
  return CharSetNone;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!hasOwn(state.unicodeProperties.nonBinary, name)) {
    state.raise("Invalid property name");
  }
  if (!state.unicodeProperties.nonBinary[name].test(value)) {
    state.raise("Invalid property value");
  }
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (state.unicodeProperties.binary.test(nameOrValue)) {
    return CharSetOk;
  }
  if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
    return CharSetString;
  }
  state.raise("Invalid property name");
};
pp$1.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state);
};
pp$1.regexp_eatCharacterClass = function(state) {
  if (state.eat(
    91
    /* [ */
  )) {
    var negate = state.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state);
    if (!state.eat(
      93
      /* ] */
    )) {
      state.raise("Unterminated character class");
    }
    if (negate && result === CharSetString) {
      state.raise("Negated character class may contain strings");
    }
    return true;
  }
  return false;
};
pp$1.regexp_classContents = function(state) {
  if (state.current() === 93) {
    return CharSetOk;
  }
  if (state.switchV) {
    return this.regexp_classSetExpression(state);
  }
  this.regexp_nonEmptyClassRanges(state);
  return CharSetOk;
};
pp$1.regexp_nonEmptyClassRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};
pp$1.regexp_eatClassAtom = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(state)) {
      return true;
    }
    if (state.switchU) {
      var ch$1 = state.current();
      if (ch$1 === 99 || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  var ch = state.current();
  if (ch !== 93) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatClassEscape = function(state) {
  var start = state.pos;
  if (state.eat(
    98
    /* b */
  )) {
    state.lastIntValue = 8;
    return true;
  }
  if (state.switchU && state.eat(
    45
    /* - */
  )) {
    state.lastIntValue = 45;
    return true;
  }
  if (!state.switchU && state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
pp$1.regexp_classSetExpression = function(state) {
  var result = CharSetOk, subResult;
  if (this.regexp_eatClassSetRange(state)) ;
  else if (subResult = this.regexp_eatClassSetOperand(state)) {
    if (subResult === CharSetString) {
      result = CharSetString;
    }
    var start = state.pos;
    while (state.eatChars(
      [38, 38]
      /* && */
    )) {
      if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
        if (subResult !== CharSetString) {
          result = CharSetOk;
        }
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) {
      return result;
    }
    while (state.eatChars(
      [45, 45]
      /* -- */
    )) {
      if (this.regexp_eatClassSetOperand(state)) {
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) {
      return result;
    }
  } else {
    state.raise("Invalid character in character class");
  }
  for (; ; ) {
    if (this.regexp_eatClassSetRange(state)) {
      continue;
    }
    subResult = this.regexp_eatClassSetOperand(state);
    if (!subResult) {
      return result;
    }
    if (subResult === CharSetString) {
      result = CharSetString;
    }
  }
};
pp$1.regexp_eatClassSetRange = function(state) {
  var start = state.pos;
  if (this.regexp_eatClassSetCharacter(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassSetCharacter(state)) {
      var right = state.lastIntValue;
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatClassSetOperand = function(state) {
  if (this.regexp_eatClassSetCharacter(state)) {
    return CharSetOk;
  }
  return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
};
pp$1.regexp_eatNestedClass = function(state) {
  var start = state.pos;
  if (state.eat(
    91
    /* [ */
  )) {
    var negate = state.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state);
    if (state.eat(
      93
      /* ] */
    )) {
      if (negate && result === CharSetString) {
        state.raise("Negated character class may contain strings");
      }
      return result;
    }
    state.pos = start;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    var result$1 = this.regexp_eatCharacterClassEscape(state);
    if (result$1) {
      return result$1;
    }
    state.pos = start;
  }
  return null;
};
pp$1.regexp_eatClassStringDisjunction = function(state) {
  var start = state.pos;
  if (state.eatChars(
    [92, 113]
    /* \q */
  )) {
    if (state.eat(
      123
      /* { */
    )) {
      var result = this.regexp_classStringDisjunctionContents(state);
      if (state.eat(
        125
        /* } */
      )) {
        return result;
      }
    } else {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return null;
};
pp$1.regexp_classStringDisjunctionContents = function(state) {
  var result = this.regexp_classString(state);
  while (state.eat(
    124
    /* | */
  )) {
    if (this.regexp_classString(state) === CharSetString) {
      result = CharSetString;
    }
  }
  return result;
};
pp$1.regexp_classString = function(state) {
  var count = 0;
  while (this.regexp_eatClassSetCharacter(state)) {
    count++;
  }
  return count === 1 ? CharSetOk : CharSetString;
};
pp$1.regexp_eatClassSetCharacter = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
      return true;
    }
    if (state.eat(
      98
      /* b */
    )) {
      state.lastIntValue = 8;
      return true;
    }
    state.pos = start;
    return false;
  }
  var ch = state.current();
  if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
    return false;
  }
  if (isClassSetSyntaxCharacter(ch)) {
    return false;
  }
  state.advance();
  state.lastIntValue = ch;
  return true;
};
function isClassSetReservedDoublePunctuatorCharacter(ch) {
  return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
}
function isClassSetSyntaxCharacter(ch) {
  return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
  var ch = state.current();
  if (isClassSetReservedPunctuator(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isClassSetReservedPunctuator(ch) {
  return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
}
pp$1.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 95) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true;
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
    state.advance();
  }
  return state.pos !== start;
};
function isDecimalDigit(ch) {
  return ch >= 48 && ch <= 57;
}
pp$1.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start;
};
function isHexDigit(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
  if (ch >= 65 && ch <= 70) {
    return 10 + (ch - 65);
  }
  if (ch >= 97 && ch <= 102) {
    return 10 + (ch - 97);
  }
  return ch - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 48;
    state.advance();
    return true;
  }
  state.lastIntValue = 0;
  return false;
};
function isOctalDigit(ch) {
  return ch >= 48 && ch <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false;
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true;
};
var Token = function Token2(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations) {
    this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
  }
  if (p.options.ranges) {
    this.range = [p.start, p.end];
  }
};
var pp = Parser.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
  }
  if (this.options.onToken) {
    this.options.onToken(new Token(this));
  }
  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};
pp.getToken = function() {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") {
  pp[Symbol.iterator] = function() {
    var this$1$1 = this;
    return {
      next: function() {
        var token = this$1$1.getToken();
        return {
          done: token.type === types$1.eof,
          value: token
        };
      }
    };
  };
}
pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) {
    this.skipSpace();
  }
  this.start = this.pos;
  if (this.options.locations) {
    this.startLoc = this.curPosition();
  }
  if (this.pos >= this.input.length) {
    return this.finishToken(types$1.eof);
  }
  if (curContext.override) {
    return curContext.override(this);
  } else {
    this.readToken(this.fullCharCodeAtPos());
  }
};
pp.readToken = function(code) {
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
    return this.readWord();
  }
  return this.getTokenFromCode(code);
};
pp.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 55295 || code >= 56320) {
    return code;
  }
  var next2 = this.input.charCodeAt(this.pos + 1);
  return next2 <= 56319 || next2 >= 57344 ? code : (code << 10) + next2 - 56613888;
};
pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) {
    this.raise(this.pos - 2, "Unterminated comment");
  }
  this.pos = end + 2;
  if (this.options.locations) {
    for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
      ++this.curLine;
      pos = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment) {
    this.options.onComment(
      true,
      this.input.slice(start + 2, end),
      start,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipLineComment = function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment) {
    this.options.onComment(
      false,
      this.input.slice(start + startSkip, this.pos),
      start,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipSpace = function() {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
      case 32:
      case 160:
        ++this.pos;
        break;
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10:
      case 8232:
      case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break;
      case 47:
        switch (this.input.charCodeAt(this.pos + 1)) {
          case 42:
            this.skipBlockComment();
            break;
          case 47:
            this.skipLineComment(2);
            break;
          default:
            break loop;
        }
        break;
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop;
        }
    }
  }
};
pp.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) {
    this.endLoc = this.curPosition();
  }
  var prevType = this.type;
  this.type = type;
  this.value = val;
  this.updateContext(prevType);
};
pp.readToken_dot = function() {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 >= 48 && next2 <= 57) {
    return this.readNumber(true);
  }
  var next22 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next2 === 46 && next22 === 46) {
    this.pos += 3;
    return this.finishToken(types$1.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot);
  }
};
pp.readToken_slash = function() {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;
    return this.readRegexp();
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types$1.star : types$1.modulo;
  if (this.options.ecmaVersion >= 7 && code === 42 && next2 === 42) {
    ++size;
    tokentype = types$1.starstar;
    next2 = this.input.charCodeAt(this.pos + 2);
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, size + 1);
  }
  return this.finishOp(tokentype, size);
};
pp.readToken_pipe_amp = function(code) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === code) {
    if (this.options.ecmaVersion >= 12) {
      var next22 = this.input.charCodeAt(this.pos + 2);
      if (next22 === 61) {
        return this.finishOp(types$1.assign, 3);
      }
    }
    return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === code) {
    if (next2 === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(types$1.incDec, 2);
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next2 === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) {
      return this.finishOp(types$1.assign, size + 1);
    }
    return this.finishOp(types$1.bitShift, size);
  }
  if (next2 === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next2 === 61) {
    size = 2;
  }
  return this.finishOp(types$1.relational, size);
};
pp.readToken_eq_excl = function(code) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === 61) {
    return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }
  if (code === 61 && next2 === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(types$1.arrow);
  }
  return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
  var ecmaVersion = this.options.ecmaVersion;
  if (ecmaVersion >= 11) {
    var next2 = this.input.charCodeAt(this.pos + 1);
    if (next2 === 46) {
      var next22 = this.input.charCodeAt(this.pos + 2);
      if (next22 < 48 || next22 > 57) {
        return this.finishOp(types$1.questionDot, 2);
      }
    }
    if (next2 === 63) {
      if (ecmaVersion >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) {
          return this.finishOp(types$1.assign, 3);
        }
      }
      return this.finishOp(types$1.coalesce, 2);
    }
  }
  return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
  var ecmaVersion = this.options.ecmaVersion;
  var code = 35;
  if (ecmaVersion >= 13) {
    ++this.pos;
    code = this.fullCharCodeAtPos();
    if (isIdentifierStart(code, true) || code === 92) {
      return this.finishToken(types$1.privateId, this.readWord1());
    }
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.getTokenFromCode = function(code) {
  switch (code) {
    case 46:
      return this.readToken_dot();
    case 40:
      ++this.pos;
      return this.finishToken(types$1.parenL);
    case 41:
      ++this.pos;
      return this.finishToken(types$1.parenR);
    case 59:
      ++this.pos;
      return this.finishToken(types$1.semi);
    case 44:
      ++this.pos;
      return this.finishToken(types$1.comma);
    case 91:
      ++this.pos;
      return this.finishToken(types$1.bracketL);
    case 93:
      ++this.pos;
      return this.finishToken(types$1.bracketR);
    case 123:
      ++this.pos;
      return this.finishToken(types$1.braceL);
    case 125:
      ++this.pos;
      return this.finishToken(types$1.braceR);
    case 58:
      ++this.pos;
      return this.finishToken(types$1.colon);
    case 96:
      if (this.options.ecmaVersion < 6) {
        break;
      }
      ++this.pos;
      return this.finishToken(types$1.backQuote);
    case 48:
      var next2 = this.input.charCodeAt(this.pos + 1);
      if (next2 === 120 || next2 === 88) {
        return this.readRadixNumber(16);
      }
      if (this.options.ecmaVersion >= 6) {
        if (next2 === 111 || next2 === 79) {
          return this.readRadixNumber(8);
        }
        if (next2 === 98 || next2 === 66) {
          return this.readRadixNumber(2);
        }
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(false);
    case 34:
    case 39:
      return this.readString(code);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(code);
    case 124:
    case 38:
      return this.readToken_pipe_amp(code);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(code);
    case 60:
    case 62:
      return this.readToken_lt_gt(code);
    case 61:
    case 33:
      return this.readToken_eq_excl(code);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(types$1.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str);
};
pp.readRegexp = function() {
  var escaped, inClass, start = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(start, "Unterminated regular expression");
    }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) {
      this.raise(start, "Unterminated regular expression");
    }
    if (!escaped) {
      if (ch === "[") {
        inClass = true;
      } else if (ch === "]" && inClass) {
        inClass = false;
      } else if (ch === "/" && !inClass) {
        break;
      }
      escaped = ch === "\\";
    } else {
      escaped = false;
    }
    ++this.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) {
    this.unexpected(flagsStart);
  }
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e2) {
  }
  return this.finishToken(types$1.regexp, { pattern, flags, value });
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
  var start = this.pos, total = 0, lastCode = 0;
  for (var i = 0, e2 = len == null ? Infinity : len; i < e2; ++i, ++this.pos) {
    var code = this.input.charCodeAt(this.pos), val = void 0;
    if (allowSeparators && code === 95) {
      if (isLegacyOctalNumericLiteral) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
      }
      if (lastCode === 95) {
        this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
      }
      if (i === 0) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
      }
      lastCode = code;
      continue;
    }
    if (code >= 97) {
      val = code - 97 + 10;
    } else if (code >= 65) {
      val = code - 65 + 10;
    } else if (code >= 48 && code <= 57) {
      val = code - 48;
    } else {
      val = Infinity;
    }
    if (val >= radix) {
      break;
    }
    lastCode = code;
    total = total * radix + val;
  }
  if (allowSeparators && lastCode === 95) {
    this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
  }
  if (this.pos === start || len != null && this.pos - start !== len) {
    return null;
  }
  return total;
};
function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8);
  }
  return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2;
  var val = this.readInt(radix);
  if (val == null) {
    this.raise(this.start + 2, "Expected number in radix " + radix);
  }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  return this.finishToken(types$1.num, val);
};
pp.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10, void 0, true) === null) {
    this.raise(start, "Invalid number");
  }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) {
    this.raise(start, "Invalid number");
  }
  var next2 = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next2 === 110) {
    var val$1 = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types$1.num, val$1);
  }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
    octal = false;
  }
  if (next2 === 46 && !octal) {
    ++this.pos;
    this.readInt(10);
    next2 = this.input.charCodeAt(this.pos);
  }
  if ((next2 === 69 || next2 === 101) && !octal) {
    next2 = this.input.charCodeAt(++this.pos);
    if (next2 === 43 || next2 === 45) {
      ++this.pos;
    }
    if (this.readInt(10) === null) {
      this.raise(start, "Invalid number");
    }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  var val = stringToNumber(this.input.slice(start, this.pos), octal);
  return this.finishToken(types$1.num, val);
};
pp.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;
  if (ch === 123) {
    if (this.options.ecmaVersion < 6) {
      this.unexpected();
    }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 1114111) {
      this.invalidStringToken(codePos, "Code point out of bounds");
    }
  } else {
    code = this.readHexChar(4);
  }
  return code;
};
pp.readString = function(quote2) {
  var out = "", chunkStart = ++this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated string constant");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote2) {
      break;
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch === 8232 || ch === 8233) {
      if (this.options.ecmaVersion < 10) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine(ch)) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err;
    }
  }
  this.inTemplateElement = false;
};
pp.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
    this.raise(position, message);
  }
};
pp.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated template");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out);
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          out += "\n";
          break;
        default:
          out += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};
pp.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break;
        }
      case "`":
        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
      case "\r":
        if (this.input[this.pos + 1] === "\n") {
          ++this.pos;
        }
      case "\n":
      case "\u2028":
      case "\u2029":
        ++this.curLine;
        this.lineStart = this.pos + 1;
        break;
    }
  }
  this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
    case 110:
      return "\n";
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return codePointToString(this.readCodePoint());
    case 116:
      return "	";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
      }
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;
        ++this.curLine;
      }
      return "";
    case 56:
    case 57:
      if (this.strict) {
        this.invalidStringToken(
          this.pos - 1,
          "Invalid escape sequence"
        );
      }
      if (inTemplate) {
        var codePos = this.pos - 1;
        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal);
      }
      if (isNewLine(ch)) {
        if (this.options.locations) {
          this.lineStart = this.pos;
          ++this.curLine;
        }
        return "";
      }
      return String.fromCharCode(ch);
  }
};
pp.readHexChar = function(len) {
  var codePos = this.pos;
  var n2 = this.readInt(16, len);
  if (n2 === null) {
    this.invalidStringToken(codePos, "Bad character escape sequence");
  }
  return n2;
};
pp.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 65535 ? 1 : 2;
    } else if (ch === 92) {
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) {
        this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
        this.invalidStringToken(escStart, "Invalid Unicode escape");
      }
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
  var word = this.readWord1();
  var type = types$1.name;
  if (this.keywords.test(word)) {
    type = keywords[word];
  }
  return this.finishToken(type, word);
};
var version = "8.14.1";
Parser.acorn = {
  Parser,
  version,
  defaultOptions,
  Position,
  SourceLocation,
  getLineInfo,
  Node,
  TokenType,
  tokTypes: types$1,
  keywordTypes: keywords,
  TokContext,
  tokContexts: types,
  isIdentifierChar,
  isIdentifierStart,
  Token,
  isNewLine,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace
};
function parse3(input, options) {
  return Parser.parse(input, options);
}
function parseExpressionAt2(input, pos, options) {
  return Parser.parseExpressionAt(input, pos, options);
}
function tokenizer2(input, options) {
  return Parser.tokenizer(input, options);
}

// node_modules/@sveltejs/acorn-typescript/index.js
var startsExpr2 = true;
function kwLike(_name, options = {}) {
  return new TokenType("name", options);
}
var acornTypeScriptMap = /* @__PURE__ */ new WeakMap();
function generateAcornTypeScript(_acorn) {
  const acorn = _acorn.Parser.acorn || _acorn;
  let acornTypeScript = acornTypeScriptMap.get(acorn);
  if (!acornTypeScript) {
    let tokenIsLiteralPropertyName = function(token) {
      return [
        ...[types$1.name, types$1.string, types$1.num],
        ...Object.values(keywords),
        ...Object.values(tsKwTokenType)
      ].includes(token);
    }, tokenIsKeywordOrIdentifier = function(token) {
      return [
        ...[types$1.name],
        ...Object.values(keywords),
        ...Object.values(tsKwTokenType)
      ].includes(token);
    }, tokenIsIdentifier = function(token) {
      return [...Object.values(tsKwTokenType), types$1.name].includes(token);
    }, tokenIsTSDeclarationStart = function(token) {
      return [
        tsKwTokenType.abstract,
        tsKwTokenType.declare,
        tsKwTokenType.enum,
        tsKwTokenType.module,
        tsKwTokenType.namespace,
        tsKwTokenType.interface,
        tsKwTokenType.type
      ].includes(token);
    }, tokenIsTSTypeOperator = function(token) {
      return [tsKwTokenType.keyof, tsKwTokenType.readonly, tsKwTokenType.unique].includes(token);
    }, tokenIsTemplate = function(token) {
      return token === types$1.invalidTemplate;
    };
    const tsKwTokenType = generateTsKwTokenType();
    const tsTokenType = generateTsTokenType();
    const tsTokenContext = generateTsTokenContext();
    const tsKeywordsRegExp = new RegExp(`^(?:${Object.keys(tsKwTokenType).join("|")})$`);
    tsTokenType.jsxTagStart.updateContext = function() {
      this.context.push(tsTokenContext.tc_expr);
      this.context.push(tsTokenContext.tc_oTag);
      this.exprAllowed = false;
    };
    tsTokenType.jsxTagEnd.updateContext = function(prevType) {
      let out = this.context.pop();
      if (out === tsTokenContext.tc_oTag && prevType === types$1.slash || out === tsTokenContext.tc_cTag) {
        this.context.pop();
        this.exprAllowed = this.curContext() === tsTokenContext.tc_expr;
      } else {
        this.exprAllowed = true;
      }
    };
    acornTypeScript = {
      tokTypes: {
        ...tsKwTokenType,
        ...tsTokenType
      },
      tokContexts: {
        ...tsTokenContext
      },
      keywordsRegExp: tsKeywordsRegExp,
      tokenIsLiteralPropertyName,
      tokenIsKeywordOrIdentifier,
      tokenIsIdentifier,
      tokenIsTSDeclarationStart,
      tokenIsTSTypeOperator,
      tokenIsTemplate
    };
  }
  return acornTypeScript;
}
function generateTsTokenContext() {
  return {
    tc_oTag: new TokContext("<tag", false, false),
    tc_cTag: new TokContext("</tag", false, false),
    tc_expr: new TokContext("<tag>...</tag>", true, true)
  };
}
function generateTsTokenType() {
  return {
    // @ts-expect-error
    at: new TokenType("@"),
    // @ts-expect-error
    jsxName: new TokenType("jsxName"),
    // @ts-expect-error
    jsxText: new TokenType("jsxText", { beforeExpr: true }),
    // @ts-expect-error
    jsxTagStart: new TokenType("jsxTagStart", { startsExpr: true }),
    // @ts-expect-error
    jsxTagEnd: new TokenType("jsxTagEnd")
  };
}
function generateTsKwTokenType() {
  return {
    assert: kwLike("assert", { startsExpr: startsExpr2 }),
    asserts: kwLike("asserts", { startsExpr: startsExpr2 }),
    global: kwLike("global", { startsExpr: startsExpr2 }),
    keyof: kwLike("keyof", { startsExpr: startsExpr2 }),
    readonly: kwLike("readonly", { startsExpr: startsExpr2 }),
    unique: kwLike("unique", { startsExpr: startsExpr2 }),
    abstract: kwLike("abstract", { startsExpr: startsExpr2 }),
    declare: kwLike("declare", { startsExpr: startsExpr2 }),
    enum: kwLike("enum", { startsExpr: startsExpr2 }),
    module: kwLike("module", { startsExpr: startsExpr2 }),
    namespace: kwLike("namespace", { startsExpr: startsExpr2 }),
    interface: kwLike("interface", { startsExpr: startsExpr2 }),
    type: kwLike("type", { startsExpr: startsExpr2 })
  };
}
var TS_SCOPE_OTHER = 512;
var TS_SCOPE_TS_MODULE = 1024;
var BIND_KIND_VALUE = 1;
var BIND_KIND_TYPE = 2;
var BIND_SCOPE_VAR = 4;
var BIND_SCOPE_LEXICAL = 8;
var BIND_SCOPE_FUNCTION = 16;
var BIND_FLAGS_NONE = 64;
var BIND_FLAGS_CLASS = 128;
var BIND_FLAGS_TS_ENUM = 256;
var BIND_FLAGS_TS_CONST_ENUM = 512;
var BIND_FLAGS_TS_EXPORT_ONLY = 1024;
var BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS;
var BIND_LEXICAL2 = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0;
var BIND_VAR2 = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0;
var BIND_FUNCTION2 = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0;
var BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS;
var BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0;
var BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM;
var BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
var BIND_NONE2 = 0 | 0 | 0 | BIND_FLAGS_NONE;
var BIND_OUTSIDE2 = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE;
var BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM;
var BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
var CLASS_ELEMENT_FLAG_STATIC = 4;
var CLASS_ELEMENT_KIND_GETTER = 2;
var CLASS_ELEMENT_KIND_SETTER = 1;
var CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
var CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC;
var CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC;
var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y;
var skipWhiteSpaceToLineBreak = new RegExp(
  // Unfortunately JS doesn't support Perl's atomic /(?>pattern)/ or
  // possessive quantifiers, so we use a trick to prevent backtracking
  // when the look-ahead for line terminator fails.
  "(?=(" + // Capture the whitespace and comments that should be skipped inside
  // a look-ahead assertion, and then re-match the group as a unit.
  skipWhiteSpaceInLine.source + "))\\1" + // Look-ahead for either line terminator, start of multi-line comment,
  // or end of string.
  /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source,
  "y"
  // sticky
);
var DestructuringErrors3 = class {
  constructor() {
    this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
  }
};
function isPrivateNameConflicted2(privateNameMap, element2) {
  const name = element2.key.name;
  const curr = privateNameMap[name];
  let next2 = "true";
  if (element2.type === "MethodDefinition" && (element2.kind === "get" || element2.kind === "set")) {
    next2 = (element2.static ? "s" : "i") + element2.kind;
  }
  if (curr === "iget" && next2 === "iset" || curr === "iset" && next2 === "iget" || curr === "sget" && next2 === "sset" || curr === "sset" && next2 === "sget") {
    privateNameMap[name] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name] = next2;
    return false;
  } else {
    return true;
  }
}
function checkKeyName2(node, name) {
  const { computed, key: key2 } = node;
  return !computed && (key2.type === "Identifier" && key2.name === name || key2.type === "Literal" && key2.value === name);
}
var TypeScriptError = {
  AbstractMethodHasImplementation: ({ methodName }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
  AbstractPropertyHasInitializer: ({ propertyName }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
  AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
  AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
  CannotFindName: ({ name }) => `Cannot find name '${name}'.`,
  ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
  ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
  ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
  DeclareAccessor: ({ kind }) => `'declare' is not allowed in ${kind}ters.`,
  DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
  DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
  DuplicateAccessibilityModifier: (
    // `Accessibility modifier already seen: ${modifier}` would be more helpful.
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    () => `Accessibility modifier already seen.`
  ),
  DuplicateModifier: ({ modifier }) => `Duplicate modifier: '${modifier}'.`,
  // `token` matches the terminology used by typescript:
  // https://github.com/microsoft/TypeScript/blob/main/src/compiler/types.ts#L2915
  EmptyHeritageClauseType: ({ token }) => `'${token}' list cannot be empty.`,
  EmptyTypeArguments: "Type argument list cannot be empty.",
  EmptyTypeParameters: "Type parameter list cannot be empty.",
  ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
  ImportAliasHasImportType: "An import alias can not use 'import type'.",
  IncompatibleModifiers: ({ modifiers: modifiers2 }) => `'${modifiers2[0]}' modifier cannot be used with '${modifiers2[1]}' modifier.`,
  IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
  IndexSignatureHasAccessibility: ({ modifier }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
  IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
  IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
  IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
  InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
  InvalidModifierOnTypeMember: ({ modifier }) => `'${modifier}' modifier cannot appear on a type member.`,
  InvalidModifierOnTypeParameter: ({ modifier }) => `'${modifier}' modifier cannot appear on a type parameter.`,
  InvalidModifierOnTypeParameterPositions: ({ modifier }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
  InvalidModifiersOrder: ({ orderedModifiers }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
  InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
  InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
  MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
  MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
  NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
  NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
  OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
  OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
  PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
  PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
  PrivateElementHasAccessibility: ({ modifier }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
  PrivateMethodsHasAccessibility: ({ modifier }) => `Private methods cannot have an accessibility modifier ('${modifier}').`,
  ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
  ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
  ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
  SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
  SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
  SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
  SingleTypeParameterWithoutTrailingComma: ({ typeParameterName }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
  StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
  TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
  TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
  TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
  TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
  UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
  UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
  GenericsEndWithComma: `Trailing comma is not allowed at the end of generics.`,
  UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
  UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
  UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
  UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
  UnsupportedSignatureParameterKind: ({ type }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`,
  LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations."
};
var DecoratorsError = {
  UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
  DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
  TrailingDecorator: "Decorators must be attached to a class element.",
  SpreadElementDecorator: `Decorators can't be used with SpreadElement`
};
function generateParseDecorators(Parse, acornTypeScript, acorn) {
  const { tokTypes: tt } = acorn;
  const { tokTypes: tokTypes2 } = acornTypeScript;
  return class ParseDecorators extends Parse {
    takeDecorators(node) {
      const decorators = this.decoratorStack[this.decoratorStack.length - 1];
      if (decorators.length) {
        node.decorators = decorators;
        this.resetStartLocationFromNode(node, decorators[0]);
        this.decoratorStack[this.decoratorStack.length - 1] = [];
      }
    }
    parseDecorators(allowExport) {
      const currentContextDecorators = this.decoratorStack[this.decoratorStack.length - 1];
      while (this.match(tokTypes2.at)) {
        const decorator = this.parseDecorator();
        currentContextDecorators.push(decorator);
      }
      if (this.match(tt._export)) {
        if (!allowExport) {
          this.unexpected();
        }
      } else if (!this.canHaveLeadingDecorator()) {
        this.raise(this.start, DecoratorsError.UnexpectedLeadingDecorator);
      }
    }
    parseDecorator() {
      const node = this.startNode();
      this.next();
      this.decoratorStack.push([]);
      const startPos = this.start;
      const startLoc = this.startLoc;
      let expr;
      if (this.match(tt.parenL)) {
        const startPos2 = this.start;
        const startLoc2 = this.startLoc;
        this.next();
        expr = this.parseExpression();
        this.expect(tt.parenR);
        if (this.options.preserveParens) {
          let par = this.startNodeAt(startPos2, startLoc2);
          par.expression = expr;
          expr = this.finishNode(par, "ParenthesizedExpression");
        }
      } else {
        expr = this.parseIdent(false);
        while (this.eat(tt.dot)) {
          const node2 = this.startNodeAt(startPos, startLoc);
          node2.object = expr;
          node2.property = this.parseIdent(true);
          node2.computed = false;
          expr = this.finishNode(node2, "MemberExpression");
        }
      }
      node.expression = this.parseMaybeDecoratorArguments(expr);
      this.decoratorStack.pop();
      return this.finishNode(node, "Decorator");
    }
    parseMaybeDecoratorArguments(expr) {
      if (this.eat(tt.parenL)) {
        const node = this.startNodeAtNode(expr);
        node.callee = expr;
        node.arguments = this.parseExprList(tt.parenR, false);
        return this.finishNode(node, "CallExpression");
      }
      return expr;
    }
  };
}
var xhtml_default = {
  quot: '"',
  amp: "&",
  apos: "'",
  lt: "<",
  gt: ">",
  nbsp: " ",
  iexcl: "¡",
  cent: "¢",
  pound: "£",
  curren: "¤",
  yen: "¥",
  brvbar: "¦",
  sect: "§",
  uml: "¨",
  copy: "©",
  ordf: "ª",
  laquo: "«",
  not: "¬",
  shy: "­",
  reg: "®",
  macr: "¯",
  deg: "°",
  plusmn: "±",
  sup2: "²",
  sup3: "³",
  acute: "´",
  micro: "µ",
  para: "¶",
  middot: "·",
  cedil: "¸",
  sup1: "¹",
  ordm: "º",
  raquo: "»",
  frac14: "¼",
  frac12: "½",
  frac34: "¾",
  iquest: "¿",
  Agrave: "À",
  Aacute: "Á",
  Acirc: "Â",
  Atilde: "Ã",
  Auml: "Ä",
  Aring: "Å",
  AElig: "Æ",
  Ccedil: "Ç",
  Egrave: "È",
  Eacute: "É",
  Ecirc: "Ê",
  Euml: "Ë",
  Igrave: "Ì",
  Iacute: "Í",
  Icirc: "Î",
  Iuml: "Ï",
  ETH: "Ð",
  Ntilde: "Ñ",
  Ograve: "Ò",
  Oacute: "Ó",
  Ocirc: "Ô",
  Otilde: "Õ",
  Ouml: "Ö",
  times: "×",
  Oslash: "Ø",
  Ugrave: "Ù",
  Uacute: "Ú",
  Ucirc: "Û",
  Uuml: "Ü",
  Yacute: "Ý",
  THORN: "Þ",
  szlig: "ß",
  agrave: "à",
  aacute: "á",
  acirc: "â",
  atilde: "ã",
  auml: "ä",
  aring: "å",
  aelig: "æ",
  ccedil: "ç",
  egrave: "è",
  eacute: "é",
  ecirc: "ê",
  euml: "ë",
  igrave: "ì",
  iacute: "í",
  icirc: "î",
  iuml: "ï",
  eth: "ð",
  ntilde: "ñ",
  ograve: "ò",
  oacute: "ó",
  ocirc: "ô",
  otilde: "õ",
  ouml: "ö",
  divide: "÷",
  oslash: "ø",
  ugrave: "ù",
  uacute: "ú",
  ucirc: "û",
  uuml: "ü",
  yacute: "ý",
  thorn: "þ",
  yuml: "ÿ",
  OElig: "Œ",
  oelig: "œ",
  Scaron: "Š",
  scaron: "š",
  Yuml: "Ÿ",
  fnof: "ƒ",
  circ: "ˆ",
  tilde: "˜",
  Alpha: "Α",
  Beta: "Β",
  Gamma: "Γ",
  Delta: "Δ",
  Epsilon: "Ε",
  Zeta: "Ζ",
  Eta: "Η",
  Theta: "Θ",
  Iota: "Ι",
  Kappa: "Κ",
  Lambda: "Λ",
  Mu: "Μ",
  Nu: "Ν",
  Xi: "Ξ",
  Omicron: "Ο",
  Pi: "Π",
  Rho: "Ρ",
  Sigma: "Σ",
  Tau: "Τ",
  Upsilon: "Υ",
  Phi: "Φ",
  Chi: "Χ",
  Psi: "Ψ",
  Omega: "Ω",
  alpha: "α",
  beta: "β",
  gamma: "γ",
  delta: "δ",
  epsilon: "ε",
  zeta: "ζ",
  eta: "η",
  theta: "θ",
  iota: "ι",
  kappa: "κ",
  lambda: "λ",
  mu: "μ",
  nu: "ν",
  xi: "ξ",
  omicron: "ο",
  pi: "π",
  rho: "ρ",
  sigmaf: "ς",
  sigma: "σ",
  tau: "τ",
  upsilon: "υ",
  phi: "φ",
  chi: "χ",
  psi: "ψ",
  omega: "ω",
  thetasym: "ϑ",
  upsih: "ϒ",
  piv: "ϖ",
  ensp: " ",
  emsp: " ",
  thinsp: " ",
  zwnj: "‌",
  zwj: "‍",
  lrm: "‎",
  rlm: "‏",
  ndash: "–",
  mdash: "—",
  lsquo: "‘",
  rsquo: "’",
  sbquo: "‚",
  ldquo: "“",
  rdquo: "”",
  bdquo: "„",
  dagger: "†",
  Dagger: "‡",
  bull: "•",
  hellip: "…",
  permil: "‰",
  prime: "′",
  Prime: "″",
  lsaquo: "‹",
  rsaquo: "›",
  oline: "‾",
  frasl: "⁄",
  euro: "€",
  image: "ℑ",
  weierp: "℘",
  real: "ℜ",
  trade: "™",
  alefsym: "ℵ",
  larr: "←",
  uarr: "↑",
  rarr: "→",
  darr: "↓",
  harr: "↔",
  crarr: "↵",
  lArr: "⇐",
  uArr: "⇑",
  rArr: "⇒",
  dArr: "⇓",
  hArr: "⇔",
  forall: "∀",
  part: "∂",
  exist: "∃",
  empty: "∅",
  nabla: "∇",
  isin: "∈",
  notin: "∉",
  ni: "∋",
  prod: "∏",
  sum: "∑",
  minus: "−",
  lowast: "∗",
  radic: "√",
  prop: "∝",
  infin: "∞",
  ang: "∠",
  and: "∧",
  or: "∨",
  cap: "∩",
  cup: "∪",
  int: "∫",
  there4: "∴",
  sim: "∼",
  cong: "≅",
  asymp: "≈",
  ne: "≠",
  equiv: "≡",
  le: "≤",
  ge: "≥",
  sub: "⊂",
  sup: "⊃",
  nsub: "⊄",
  sube: "⊆",
  supe: "⊇",
  oplus: "⊕",
  otimes: "⊗",
  perp: "⊥",
  sdot: "⋅",
  lceil: "⌈",
  rceil: "⌉",
  lfloor: "⌊",
  rfloor: "⌋",
  lang: "〈",
  rang: "〉",
  loz: "◊",
  spades: "♠",
  clubs: "♣",
  hearts: "♥",
  diams: "♦"
};
var hexNumber = /^[\da-fA-F]+$/;
var decimalNumber = /^\d+$/;
function getQualifiedJSXName(object4) {
  if (!object4) return object4;
  if (object4.type === "JSXIdentifier") return object4.name;
  if (object4.type === "JSXNamespacedName") return object4.namespace.name + ":" + object4.name.name;
  if (object4.type === "JSXMemberExpression")
    return getQualifiedJSXName(object4.object) + "." + getQualifiedJSXName(object4.property);
}
function generateJsxParser(acorn, acornTypeScript, Parser4, jsxOptions) {
  const tt = acorn.tokTypes;
  const tok = acornTypeScript.tokTypes;
  const isNewLine2 = acorn.isNewLine;
  const isIdentifierChar2 = acorn.isIdentifierChar;
  const options = Object.assign(
    {
      allowNamespaces: true,
      allowNamespacedObjects: true
    },
    jsxOptions || {}
  );
  return class JsxParser extends Parser4 {
    // Reads inline JSX contents token.
    jsx_readToken() {
      let out = "", chunkStart = this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) this.raise(this.start, "Unterminated JSX contents");
        let ch = this.input.charCodeAt(this.pos);
        switch (ch) {
          case 60:
          case 123:
            if (this.pos === this.start) {
              if (ch === 60 && this.exprAllowed) {
                ++this.pos;
                return this.finishToken(tok.jsxTagStart);
              }
              return this.getTokenFromCode(ch);
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(tok.jsxText, out);
          case 38:
            out += this.input.slice(chunkStart, this.pos);
            out += this.jsx_readEntity();
            chunkStart = this.pos;
            break;
          case 62:
          case 125:
            this.raise(
              this.pos,
              "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (ch === 62 ? "&gt;" : "&rbrace;") + '` or `{"' + this.input[this.pos] + '"}`?'
            );
          default:
            if (isNewLine2(ch)) {
              out += this.input.slice(chunkStart, this.pos);
              out += this.jsx_readNewLine(true);
              chunkStart = this.pos;
            } else {
              ++this.pos;
            }
        }
      }
    }
    jsx_readNewLine(normalizeCRLF) {
      let ch = this.input.charCodeAt(this.pos);
      let out;
      ++this.pos;
      if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
        out = normalizeCRLF ? "\n" : "\r\n";
      } else {
        out = String.fromCharCode(ch);
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      return out;
    }
    jsx_readString(quote2) {
      let out = "", chunkStart = ++this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
        let ch = this.input.charCodeAt(this.pos);
        if (ch === quote2) break;
        if (ch === 38) {
          out += this.input.slice(chunkStart, this.pos);
          out += this.jsx_readEntity();
          chunkStart = this.pos;
        } else if (isNewLine2(ch)) {
          out += this.input.slice(chunkStart, this.pos);
          out += this.jsx_readNewLine(false);
          chunkStart = this.pos;
        } else {
          ++this.pos;
        }
      }
      out += this.input.slice(chunkStart, this.pos++);
      return this.finishToken(tt.string, out);
    }
    jsx_readEntity() {
      let str = "", count = 0, entity;
      let ch = this.input[this.pos];
      if (ch !== "&") this.raise(this.pos, "Entity must start with an ampersand");
      let startPos = ++this.pos;
      while (this.pos < this.input.length && count++ < 10) {
        ch = this.input[this.pos++];
        if (ch === ";") {
          if (str[0] === "#") {
            if (str[1] === "x") {
              str = str.substr(2);
              if (hexNumber.test(str)) entity = String.fromCharCode(parseInt(str, 16));
            } else {
              str = str.substr(1);
              if (decimalNumber.test(str)) entity = String.fromCharCode(parseInt(str, 10));
            }
          } else {
            entity = xhtml_default[str];
          }
          break;
        }
        str += ch;
      }
      if (!entity) {
        this.pos = startPos;
        return "&";
      }
      return entity;
    }
    // Read a JSX identifier (valid tag or attribute name).
    //
    // Optimized version since JSX identifiers can't contain
    // escape characters and so can be read as single slice.
    // Also assumes that first character was already checked
    // by isIdentifierStart in readToken.
    jsx_readWord() {
      let ch, start = this.pos;
      do {
        ch = this.input.charCodeAt(++this.pos);
      } while (isIdentifierChar2(ch) || ch === 45);
      return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));
    }
    // Parse next token as JSX identifier
    jsx_parseIdentifier() {
      let node = this.startNode();
      if (this.type === tok.jsxName) node.name = this.value;
      else if (this.type.keyword) node.name = this.type.keyword;
      else this.unexpected();
      this.next();
      return this.finishNode(node, "JSXIdentifier");
    }
    // Parse namespaced identifier.
    jsx_parseNamespacedName() {
      let startPos = this.start, startLoc = this.startLoc;
      let name = this.jsx_parseIdentifier();
      if (!options.allowNamespaces || !this.eat(tt.colon)) return name;
      var node = this.startNodeAt(startPos, startLoc);
      node.namespace = name;
      node.name = this.jsx_parseIdentifier();
      return this.finishNode(node, "JSXNamespacedName");
    }
    // Parses element name in any form - namespaced, member
    // or single identifier.
    jsx_parseElementName() {
      if (this.type === tok.jsxTagEnd) return "";
      let startPos = this.start, startLoc = this.startLoc;
      let node = this.jsx_parseNamespacedName();
      if (this.type === tt.dot && node.type === "JSXNamespacedName" && !options.allowNamespacedObjects) {
        this.unexpected();
      }
      while (this.eat(tt.dot)) {
        let newNode = this.startNodeAt(startPos, startLoc);
        newNode.object = node;
        newNode.property = this.jsx_parseIdentifier();
        node = this.finishNode(newNode, "JSXMemberExpression");
      }
      return node;
    }
    // Parses any type of JSX attribute value.
    jsx_parseAttributeValue() {
      switch (this.type) {
        case tt.braceL:
          let node = this.jsx_parseExpressionContainer();
          if (node.expression.type === "JSXEmptyExpression")
            this.raise(node.start, "JSX attributes must only be assigned a non-empty expression");
          return node;
        case tok.jsxTagStart:
        case tt.string:
          return this.parseExprAtom();
        default:
          this.raise(this.start, "JSX value should be either an expression or a quoted JSX text");
      }
    }
    // JSXEmptyExpression is unique type since it doesn't actually parse anything,
    // and so it should start at the end of last read token (left brace) and finish
    // at the beginning of the next one (right brace).
    jsx_parseEmptyExpression() {
      let node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
      return this.finishNodeAt(node, "JSXEmptyExpression", this.start, this.startLoc);
    }
    // Parses JSX expression enclosed into curly brackets.
    jsx_parseExpressionContainer() {
      let node = this.startNode();
      this.next();
      node.expression = this.type === tt.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression();
      this.expect(tt.braceR);
      return this.finishNode(node, "JSXExpressionContainer");
    }
    // Parses following JSX attribute name-value pair.
    jsx_parseAttribute() {
      let node = this.startNode();
      if (this.eat(tt.braceL)) {
        this.expect(tt.ellipsis);
        node.argument = this.parseMaybeAssign();
        this.expect(tt.braceR);
        return this.finishNode(node, "JSXSpreadAttribute");
      }
      node.name = this.jsx_parseNamespacedName();
      node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;
      return this.finishNode(node, "JSXAttribute");
    }
    // Parses JSX opening tag starting after '<'.
    jsx_parseOpeningElementAt(startPos, startLoc) {
      let node = this.startNodeAt(startPos, startLoc);
      node.attributes = [];
      let nodeName = this.jsx_parseElementName();
      if (nodeName) node.name = nodeName;
      while (this.type !== tt.slash && this.type !== tok.jsxTagEnd)
        node.attributes.push(this.jsx_parseAttribute());
      node.selfClosing = this.eat(tt.slash);
      this.expect(tok.jsxTagEnd);
      return this.finishNode(node, nodeName ? "JSXOpeningElement" : "JSXOpeningFragment");
    }
    // Parses JSX closing tag starting after '</'.
    jsx_parseClosingElementAt(startPos, startLoc) {
      let node = this.startNodeAt(startPos, startLoc);
      let nodeName = this.jsx_parseElementName();
      if (nodeName) node.name = nodeName;
      this.expect(tok.jsxTagEnd);
      return this.finishNode(node, nodeName ? "JSXClosingElement" : "JSXClosingFragment");
    }
    // Parses entire JSX element, including it's opening tag
    // (starting after '<'), attributes, contents and closing tag.
    jsx_parseElementAt(startPos, startLoc) {
      let node = this.startNodeAt(startPos, startLoc);
      let children = [];
      let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
      let closingElement = null;
      if (!openingElement.selfClosing) {
        contents: for (; ; ) {
          switch (this.type) {
            case tok.jsxTagStart:
              startPos = this.start;
              startLoc = this.startLoc;
              this.next();
              if (this.eat(tt.slash)) {
                closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
                break contents;
              }
              children.push(this.jsx_parseElementAt(startPos, startLoc));
              break;
            case tok.jsxText:
              children.push(this.parseExprAtom());
              break;
            case tt.braceL:
              children.push(this.jsx_parseExpressionContainer());
              break;
            default:
              this.unexpected();
          }
        }
        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
          this.raise(
            closingElement.start,
            "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">"
          );
        }
      }
      let fragmentOrElement = openingElement.name ? "Element" : "Fragment";
      node["opening" + fragmentOrElement] = openingElement;
      node["closing" + fragmentOrElement] = closingElement;
      node.children = children;
      if (this.type === tt.relational && this.value === "<") {
        this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
      }
      return this.finishNode(node, "JSX" + fragmentOrElement);
    }
    // Parse JSX text
    jsx_parseText() {
      let node = this.parseLiteral(this.value);
      node.type = "JSXText";
      return node;
    }
    // Parses entire JSX element from current position.
    jsx_parseElement() {
      let startPos = this.start, startLoc = this.startLoc;
      this.next();
      return this.jsx_parseElementAt(startPos, startLoc);
    }
  };
}
function generateParseImportAssertions(Parse, acornTypeScript, acorn) {
  const { tokTypes: tokTypes2 } = acornTypeScript;
  const { tokTypes: tt } = acorn;
  return class ImportAttributes extends Parse {
    parseMaybeImportAttributes(node) {
      if (this.type === tt._with || this.type === tokTypes2.assert) {
        this.next();
        const attributes = this.parseImportAttributes();
        if (attributes) {
          node.attributes = attributes;
        }
      }
    }
    parseImportAttributes() {
      this.expect(tt.braceL);
      const attrs = this.parseWithEntries();
      this.expect(tt.braceR);
      return attrs;
    }
    parseWithEntries() {
      const attrs = [];
      const attrNames = /* @__PURE__ */ new Set();
      do {
        if (this.type === tt.braceR) {
          break;
        }
        const node = this.startNode();
        let withionKeyNode;
        if (this.type === tt.string) {
          withionKeyNode = this.parseLiteral(this.value);
        } else {
          withionKeyNode = this.parseIdent(true);
        }
        this.next();
        node.key = withionKeyNode;
        if (attrNames.has(node.key.name)) {
          this.raise(this.pos, "Duplicated key in attributes");
        }
        attrNames.add(node.key.name);
        if (this.type !== tt.string) {
          this.raise(this.pos, "Only string is supported as an attribute value");
        }
        node.value = this.parseLiteral(this.value);
        attrs.push(this.finishNode(node, "ImportAttribute"));
      } while (this.eat(tt.comma));
      return attrs;
    }
  };
}
var skipWhiteSpace2 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
function assert(x) {
  if (!x) {
    throw new Error("Assert fail");
  }
}
function tsIsClassAccessor(modifier) {
  return modifier === "accessor";
}
function tsIsVarianceAnnotations(modifier) {
  return modifier === "in" || modifier === "out";
}
var FUNC_STATEMENT2 = 1;
var FUNC_HANGING_STATEMENT2 = 2;
var FUNC_NULLABLE_ID2 = 4;
var acornScope = {
  SCOPE_TOP: 1,
  SCOPE_FUNCTION: 2,
  SCOPE_ASYNC: 4,
  SCOPE_GENERATOR: 8,
  SCOPE_ARROW: 16,
  SCOPE_SIMPLE_CATCH: 32,
  SCOPE_SUPER: 64,
  SCOPE_DIRECT_SUPER: 128,
  SCOPE_CLASS_STATIC_BLOCK: 256,
  SCOPE_VAR: 256,
  BIND_NONE: 0,
  // Not a binding
  BIND_VAR: 1,
  // Var-style binding
  BIND_LEXICAL: 2,
  // Let- or const-style binding
  BIND_FUNCTION: 3,
  // Function declaration
  BIND_SIMPLE_CATCH: 4,
  // Simple (identifier pattern) catch binding
  BIND_OUTSIDE: 5,
  // Special case for function names as bound inside the
  BIND_TS_TYPE: 6,
  BIND_TS_INTERFACE: 7,
  BIND_TS_NAMESPACE: 8,
  BIND_FLAGS_TS_EXPORT_ONLY: 1024,
  BIND_FLAGS_TS_IMPORT: 4096,
  BIND_FLAGS_TS_ENUM: 256,
  BIND_FLAGS_TS_CONST_ENUM: 512,
  BIND_FLAGS_CLASS: 128
  // function
};
function functionFlags2(async2, generator) {
  return acornScope.SCOPE_FUNCTION | (async2 ? acornScope.SCOPE_ASYNC : 0) | (generator ? acornScope.SCOPE_GENERATOR : 0);
}
function isPossiblyLiteralEnum(expression) {
  if (expression.type !== "MemberExpression") return false;
  const { computed, property } = expression;
  if (computed && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
    return false;
  }
  return isUncomputedMemberExpressionChain(expression.object);
}
function isUncomputedMemberExpressionChain(expression) {
  if (expression.type === "Identifier") return true;
  if (expression.type !== "MemberExpression") return false;
  if (expression.computed) return false;
  return isUncomputedMemberExpressionChain(expression.object);
}
function tsIsAccessModifier(modifier) {
  return modifier === "private" || modifier === "public" || modifier === "protected";
}
function tokenCanStartExpression(token) {
  return Boolean(token.startsExpr);
}
function nonNull(x) {
  if (x == null) {
    throw new Error(`Unexpected ${x} value.`);
  }
  return x;
}
function keywordTypeFromName(value) {
  switch (value) {
    case "any":
      return "TSAnyKeyword";
    case "boolean":
      return "TSBooleanKeyword";
    case "bigint":
      return "TSBigIntKeyword";
    case "never":
      return "TSNeverKeyword";
    case "number":
      return "TSNumberKeyword";
    case "object":
      return "TSObjectKeyword";
    case "string":
      return "TSStringKeyword";
    case "symbol":
      return "TSSymbolKeyword";
    case "undefined":
      return "TSUndefinedKeyword";
    case "unknown":
      return "TSUnknownKeyword";
    default:
      return void 0;
  }
}
function tsPlugin(options) {
  const { dts = false } = options || {};
  const disallowAmbiguousJSXLike = !!(options == null ? void 0 : options.jsx);
  return function(Parser4) {
    const _acorn = Parser4.acorn || acorn_exports;
    const acornTypeScript = generateAcornTypeScript(_acorn);
    const tt = _acorn.tokTypes;
    const keywordTypes2 = _acorn.keywordTypes;
    const isIdentifierStart2 = _acorn.isIdentifierStart;
    const lineBreak2 = _acorn.lineBreak;
    const isNewLine2 = _acorn.isNewLine;
    const tokContexts = _acorn.tokContexts;
    const isIdentifierChar2 = _acorn.isIdentifierChar;
    const {
      tokTypes: tokTypes2,
      tokContexts: tsTokContexts,
      keywordsRegExp,
      tokenIsLiteralPropertyName,
      tokenIsTemplate,
      tokenIsTSDeclarationStart,
      tokenIsIdentifier,
      tokenIsKeywordOrIdentifier,
      tokenIsTSTypeOperator
    } = acornTypeScript;
    function nextLineBreak2(code, from, end = code.length) {
      for (let i = from; i < end; i++) {
        let next2 = code.charCodeAt(i);
        if (isNewLine2(next2))
          return i < end - 1 && next2 === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
      }
      return -1;
    }
    Parser4 = generateParseDecorators(Parser4, acornTypeScript, _acorn);
    if (options == null ? void 0 : options.jsx) {
      Parser4 = generateJsxParser(
        _acorn,
        acornTypeScript,
        Parser4,
        typeof options.jsx === "boolean" ? {} : options.jsx
      );
    }
    Parser4 = generateParseImportAssertions(Parser4, acornTypeScript, _acorn);
    class TypeScriptParser extends Parser4 {
      constructor(options2, input, startPos) {
        super(options2, input, startPos);
        this.preValue = null;
        this.preToken = null;
        this.isLookahead = false;
        this.isAmbientContext = false;
        this.inAbstractClass = false;
        this.inType = false;
        this.inDisallowConditionalTypesContext = false;
        this.maybeInArrowParameters = false;
        this.shouldParseArrowReturnType = void 0;
        this.shouldParseAsyncArrowReturnType = void 0;
        this.decoratorStack = [[]];
        this.importsStack = [[]];
        this.importOrExportOuterKind = void 0;
        this.tsParseConstModifier = (node) => {
          this.tsParseModifiers({
            modified: node,
            allowedModifiers: ["const"],
            // for better error recovery
            disallowedModifiers: ["in", "out"],
            errorTemplate: TypeScriptError.InvalidModifierOnTypeParameterPositions
          });
        };
        this.ecmaVersion = this.options.ecmaVersion;
      }
      // support in Class static
      static get acornTypeScript() {
        return acornTypeScript;
      }
      // support in runtime, get acornTypeScript be this
      get acornTypeScript() {
        return acornTypeScript;
      }
      getTokenFromCodeInType(code) {
        if (code === 62) {
          return this.finishOp(tt.relational, 1);
        }
        if (code === 60) {
          return this.finishOp(tt.relational, 1);
        }
        return super.getTokenFromCode(code);
      }
      readToken(code) {
        if (!this.inType) {
          let context = this.curContext();
          if (context === tsTokContexts.tc_expr) return this.jsx_readToken();
          if (context === tsTokContexts.tc_oTag || context === tsTokContexts.tc_cTag) {
            if (isIdentifierStart2(code)) return this.jsx_readWord();
            if (code == 62) {
              ++this.pos;
              return this.finishToken(tokTypes2.jsxTagEnd);
            }
            if ((code === 34 || code === 39) && context == tsTokContexts.tc_oTag)
              return this.jsx_readString(code);
          }
          if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {
            ++this.pos;
            if (options == null ? void 0 : options.jsx) {
              return this.finishToken(tokTypes2.jsxTagStart);
            } else {
              return this.finishToken(tt.relational, "<");
            }
          }
        }
        return super.readToken(code);
      }
      getTokenFromCode(code) {
        if (this.inType) {
          return this.getTokenFromCodeInType(code);
        }
        if (code === 64) {
          ++this.pos;
          return this.finishToken(tokTypes2.at);
        }
        return super.getTokenFromCode(code);
      }
      isAbstractClass() {
        return this.ts_isContextual(tokTypes2.abstract) && this.lookahead().type === tt._class;
      }
      finishNode(node, type) {
        if (node.type !== "" && node.end !== 0) {
          return node;
        }
        return super.finishNode(node, type);
      }
      // tryParse will clone parser state.
      // It is expensive and should be used with cautions
      tryParse(fn, oldState = this.cloneCurLookaheadState()) {
        const abortSignal = { node: null };
        try {
          const node = fn((node2 = null) => {
            abortSignal.node = node2;
            throw abortSignal;
          });
          return {
            node,
            error: null,
            thrown: false,
            aborted: false,
            failState: null
          };
        } catch (error) {
          const failState = this.getCurLookaheadState();
          this.setLookaheadState(oldState);
          if (error instanceof SyntaxError) {
            return {
              node: null,
              error,
              thrown: true,
              aborted: false,
              failState
            };
          }
          if (error === abortSignal) {
            return {
              node: abortSignal.node,
              error: null,
              thrown: false,
              aborted: true,
              failState
            };
          }
          throw error;
        }
      }
      setOptionalParametersError(refExpressionErrors, resultError) {
        refExpressionErrors.optionalParametersLoc = (resultError == null ? void 0 : resultError.loc) ?? this.startLoc;
      }
      // used after we have finished parsing types
      reScan_lt_gt() {
        if (this.type === tt.relational) {
          this.pos -= 1;
          this.readToken_lt_gt(this.fullCharCodeAtPos());
        }
      }
      reScan_lt() {
        const { type } = this;
        if (type === tt.bitShift) {
          this.pos -= 2;
          this.finishOp(tt.relational, 1);
          return tt.relational;
        }
        return type;
      }
      resetEndLocation(node, endPos = this.lastTokEnd, endLoc = this.lastTokEndLoc) {
        node.end = endPos;
        node.loc.end = endLoc;
        if (this.options.ranges) node.range[1] = endPos;
      }
      startNodeAtNode(type) {
        return super.startNodeAt(type.start, type.loc.start);
      }
      nextTokenStart() {
        return this.nextTokenStartSince(this.pos);
      }
      tsHasSomeModifiers(member2, modifiers2) {
        return modifiers2.some((modifier) => {
          if (tsIsAccessModifier(modifier)) {
            return member2.accessibility === modifier;
          }
          return !!member2[modifier];
        });
      }
      tsIsStartOfStaticBlocks() {
        return this.isContextual("static") && this.lookaheadCharCode() === 123;
      }
      tsCheckForInvalidTypeCasts(items) {
        items.forEach((node) => {
          if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
            this.raise(node.typeAnnotation.start, TypeScriptError.UnexpectedTypeAnnotation);
          }
        });
      }
      atPossibleAsyncArrow(base) {
        return base.type === "Identifier" && base.name === "async" && this.lastTokEndLoc.column === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.potentialArrowAt;
      }
      tsIsIdentifier() {
        return tokenIsIdentifier(this.type);
      }
      tsTryParseTypeOrTypePredicateAnnotation() {
        return this.match(tt.colon) ? this.tsParseTypeOrTypePredicateAnnotation(tt.colon) : void 0;
      }
      tsTryParseGenericAsyncArrowFunction(startPos, startLoc, forInit) {
        if (!this.tsMatchLeftRelational()) {
          return void 0;
        }
        const oldMaybeInArrowParameters = this.maybeInArrowParameters;
        this.maybeInArrowParameters = true;
        const res = this.tsTryParseAndCatch(() => {
          const node = this.startNodeAt(startPos, startLoc);
          node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
          super.parseFunctionParams(node);
          node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
          this.expect(tt.arrow);
          return node;
        });
        this.maybeInArrowParameters = oldMaybeInArrowParameters;
        if (!res) {
          return void 0;
        }
        return super.parseArrowExpression(
          res,
          /* params are already set */
          null,
          /* async */
          true,
          /* forInit */
          forInit
        );
      }
      // Used when parsing type arguments from ES productions, where the first token
      // has been created without state.inType. Thus we need to rescan the lt token.
      tsParseTypeArgumentsInExpression() {
        if (this.reScan_lt() !== tt.relational) {
          return void 0;
        }
        return this.tsParseTypeArguments();
      }
      tsInNoContext(cb) {
        const oldContext = this.context;
        this.context = [oldContext[0]];
        try {
          return cb();
        } finally {
          this.context = oldContext;
        }
      }
      tsTryParseTypeAnnotation() {
        return this.match(tt.colon) ? this.tsParseTypeAnnotation() : void 0;
      }
      isUnparsedContextual(nameStart, name) {
        const nameEnd = nameStart + name.length;
        if (this.input.slice(nameStart, nameEnd) === name) {
          const nextCh = this.input.charCodeAt(nameEnd);
          return !(isIdentifierChar2(nextCh) || // check if `nextCh is between 0xd800 - 0xdbff,
          // if `nextCh` is NaN, `NaN & 0xfc00` is 0, the function
          // returns true
          (nextCh & 64512) === 55296);
        }
        return false;
      }
      isAbstractConstructorSignature() {
        return this.ts_isContextual(tokTypes2.abstract) && this.lookahead().type === tt._new;
      }
      nextTokenStartSince(pos) {
        skipWhiteSpace2.lastIndex = pos;
        return skipWhiteSpace2.test(this.input) ? skipWhiteSpace2.lastIndex : pos;
      }
      lookaheadCharCode() {
        return this.input.charCodeAt(this.nextTokenStart());
      }
      compareLookaheadState(state, state2) {
        for (const key2 of Object.keys(state)) {
          if (state[key2] !== state2[key2]) return false;
        }
        return true;
      }
      createLookaheadState() {
        this.value = null;
        this.context = [this.curContext()];
      }
      getCurLookaheadState() {
        return {
          endLoc: this.endLoc,
          lastTokEnd: this.lastTokEnd,
          lastTokStart: this.lastTokStart,
          lastTokStartLoc: this.lastTokStartLoc,
          pos: this.pos,
          value: this.value,
          type: this.type,
          start: this.start,
          end: this.end,
          context: this.context,
          startLoc: this.startLoc,
          lastTokEndLoc: this.lastTokEndLoc,
          curLine: this.curLine,
          lineStart: this.lineStart,
          curPosition: this.curPosition,
          containsEsc: this.containsEsc
        };
      }
      cloneCurLookaheadState() {
        return {
          pos: this.pos,
          value: this.value,
          type: this.type,
          start: this.start,
          end: this.end,
          context: this.context && this.context.slice(),
          startLoc: this.startLoc,
          lastTokEndLoc: this.lastTokEndLoc,
          endLoc: this.endLoc,
          lastTokEnd: this.lastTokEnd,
          lastTokStart: this.lastTokStart,
          lastTokStartLoc: this.lastTokStartLoc,
          curLine: this.curLine,
          lineStart: this.lineStart,
          curPosition: this.curPosition,
          containsEsc: this.containsEsc
        };
      }
      setLookaheadState(state) {
        this.pos = state.pos;
        this.value = state.value;
        this.endLoc = state.endLoc;
        this.lastTokEnd = state.lastTokEnd;
        this.lastTokStart = state.lastTokStart;
        this.lastTokStartLoc = state.lastTokStartLoc;
        this.type = state.type;
        this.start = state.start;
        this.end = state.end;
        this.context = state.context;
        this.startLoc = state.startLoc;
        this.lastTokEndLoc = state.lastTokEndLoc;
        this.curLine = state.curLine;
        this.lineStart = state.lineStart;
        this.curPosition = state.curPosition;
        this.containsEsc = state.containsEsc;
      }
      // Utilities
      tsLookAhead(f) {
        const state = this.getCurLookaheadState();
        const res = f();
        this.setLookaheadState(state);
        return res;
      }
      lookahead(number) {
        const oldState = this.getCurLookaheadState();
        this.createLookaheadState();
        this.isLookahead = true;
        if (number !== void 0) {
          for (let i = 0; i < number; i++) {
            this.nextToken();
          }
        } else {
          this.nextToken();
        }
        this.isLookahead = false;
        const curState = this.getCurLookaheadState();
        this.setLookaheadState(oldState);
        return curState;
      }
      readWord() {
        let word = this.readWord1();
        let type = tt.name;
        if (this.keywords.test(word)) {
          type = keywordTypes2[word];
        } else if (new RegExp(keywordsRegExp).test(word)) {
          type = tokTypes2[word];
        }
        return this.finishToken(type, word);
      }
      skipBlockComment() {
        let startLoc;
        if (!this.isLookahead) startLoc = this.options.onComment && this.curPosition();
        let start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
        this.pos = end + 2;
        if (this.options.locations) {
          for (let nextBreak, pos = start; (nextBreak = nextLineBreak2(this.input, pos, this.pos)) > -1; ) {
            ++this.curLine;
            pos = this.lineStart = nextBreak;
          }
        }
        if (this.isLookahead) return;
        if (this.options.onComment) {
          this.options.onComment(
            true,
            this.input.slice(start + 2, end),
            start,
            this.pos,
            startLoc,
            this.curPosition()
          );
        }
      }
      skipLineComment(startSkip) {
        let start = this.pos;
        let startLoc;
        if (!this.isLookahead) startLoc = this.options.onComment && this.curPosition();
        let ch = this.input.charCodeAt(this.pos += startSkip);
        while (this.pos < this.input.length && !isNewLine2(ch)) {
          ch = this.input.charCodeAt(++this.pos);
        }
        if (this.isLookahead) return;
        if (this.options.onComment)
          this.options.onComment(
            false,
            this.input.slice(start + startSkip, this.pos),
            start,
            this.pos,
            startLoc,
            this.curPosition()
          );
      }
      finishToken(type, val) {
        this.preValue = this.value;
        this.preToken = this.type;
        this.end = this.pos;
        if (this.options.locations) this.endLoc = this.curPosition();
        let prevType = this.type;
        this.type = type;
        this.value = val;
        if (!this.isLookahead) {
          this.updateContext(prevType);
        }
      }
      resetStartLocation(node, start, startLoc) {
        node.start = start;
        node.loc.start = startLoc;
        if (this.options.ranges) node.range[0] = start;
      }
      isLineTerminator() {
        return this.eat(tt.semi) || super.canInsertSemicolon();
      }
      hasFollowingLineBreak() {
        skipWhiteSpaceToLineBreak.lastIndex = this.end;
        return skipWhiteSpaceToLineBreak.test(this.input);
      }
      addExtra(node, key2, value, enumerable = true) {
        if (!node) return;
        const extra = node.extra = node.extra || {};
        if (enumerable) {
          extra[key2] = value;
        } else {
          Object.defineProperty(extra, key2, { enumerable, value });
        }
      }
      /**
       * Test if current token is a literal property name
       * https://tc39.es/ecma262/#prod-LiteralPropertyName
       * LiteralPropertyName:
       *   IdentifierName
       *   StringLiteral
       *   NumericLiteral
       *   BigIntLiteral
       */
      isLiteralPropertyName() {
        return tokenIsLiteralPropertyName(this.type);
      }
      hasPrecedingLineBreak() {
        return lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
      }
      createIdentifier(node, name) {
        node.name = name;
        return this.finishNode(node, "Identifier");
      }
      /**
       * Reset the start location of node to the start location of locationNode
       */
      resetStartLocationFromNode(node, locationNode) {
        this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
      }
      // This is used in flow and typescript plugin
      // Determine whether a parameter is a this param
      isThisParam(param) {
        return param.type === "Identifier" && param.name === "this";
      }
      isLookaheadContextual(name) {
        const next2 = this.nextTokenStart();
        return this.isUnparsedContextual(next2, name);
      }
      /**
       * ts type isContextual
       * @param {TokenType} type
       * @param {TokenType} token
       * @returns {boolean}
       * */
      ts_type_isContextual(type, token) {
        return type === token && !this.containsEsc;
      }
      /**
       * ts isContextual
       * @param {TokenType} token
       * @returns {boolean}
       * */
      ts_isContextual(token) {
        return this.type === token && !this.containsEsc;
      }
      ts_isContextualWithState(state, token) {
        return state.type === token && !state.containsEsc;
      }
      isContextualWithState(keyword, state) {
        return state.type === tt.name && state.value === keyword && !state.containsEsc;
      }
      tsIsStartOfMappedType() {
        this.next();
        if (this.eat(tt.plusMin)) {
          return this.ts_isContextual(tokTypes2.readonly);
        }
        if (this.ts_isContextual(tokTypes2.readonly)) {
          this.next();
        }
        if (!this.match(tt.bracketL)) {
          return false;
        }
        this.next();
        if (!this.tsIsIdentifier()) {
          return false;
        }
        this.next();
        return this.match(tt._in);
      }
      tsInDisallowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.inDisallowConditionalTypesContext;
        this.inDisallowConditionalTypesContext = true;
        try {
          return cb();
        } finally {
          this.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsTryParseType() {
        return this.tsEatThenParseType(tt.colon);
      }
      /**
       * Whether current token matches given type
       *
       * @param {TokenType} type
       * @returns {boolean}
       * @memberof Tokenizer
       */
      match(type) {
        return this.type === type;
      }
      matchJsx(type) {
        return this.type === acornTypeScript.tokTypes[type];
      }
      ts_eatWithState(type, nextCount, state) {
        const targetType = state.type;
        if (type === targetType) {
          for (let i = 0; i < nextCount; i++) {
            this.next();
          }
          return true;
        } else {
          return false;
        }
      }
      ts_eatContextualWithState(name, nextCount, state) {
        if (keywordsRegExp.test(name)) {
          if (this.ts_isContextualWithState(state, tokTypes2[name])) {
            for (let i = 0; i < nextCount; i++) {
              this.next();
            }
            return true;
          }
          return false;
        } else {
          if (!this.isContextualWithState(name, state)) return false;
          for (let i = 0; i < nextCount; i++) {
            this.next();
          }
          return true;
        }
      }
      canHaveLeadingDecorator() {
        return this.match(tt._class);
      }
      eatContextual(name) {
        if (keywordsRegExp.test(name)) {
          if (this.ts_isContextual(tokTypes2[name])) {
            this.next();
            return true;
          }
          return false;
        } else {
          return super.eatContextual(name);
        }
      }
      tsIsExternalModuleReference() {
        return this.isContextual("require") && this.lookaheadCharCode() === 40;
      }
      tsParseExternalModuleReference() {
        const node = this.startNode();
        this.expectContextual("require");
        this.expect(tt.parenL);
        if (!this.match(tt.string)) {
          this.unexpected();
        }
        node.expression = this.parseExprAtom();
        this.expect(tt.parenR);
        return this.finishNode(node, "TSExternalModuleReference");
      }
      tsParseEntityName(allowReservedWords = true) {
        let entity = this.parseIdent(allowReservedWords);
        while (this.eat(tt.dot)) {
          const node = this.startNodeAtNode(entity);
          node.left = entity;
          node.right = this.parseIdent(allowReservedWords);
          entity = this.finishNode(node, "TSQualifiedName");
        }
        return entity;
      }
      tsParseEnumMember() {
        const node = this.startNode();
        node.id = this.match(tt.string) ? this.parseLiteral(this.value) : this.parseIdent(
          /* liberal */
          true
        );
        if (this.eat(tt.eq)) {
          node.initializer = this.parseMaybeAssign();
        }
        return this.finishNode(node, "TSEnumMember");
      }
      tsParseEnumDeclaration(node, properties = {}) {
        if (properties.const) node.const = true;
        if (properties.declare) node.declare = true;
        this.expectContextual("enum");
        node.id = this.parseIdent();
        this.checkLValSimple(node.id);
        this.expect(tt.braceL);
        node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
        this.expect(tt.braceR);
        return this.finishNode(node, "TSEnumDeclaration");
      }
      tsParseModuleBlock() {
        const node = this.startNode();
        this.enterScope(TS_SCOPE_OTHER);
        this.expect(tt.braceL);
        node.body = [];
        while (this.type !== tt.braceR) {
          let stmt2 = this.parseStatement(null, true);
          node.body.push(stmt2);
        }
        this.next();
        super.exitScope();
        return this.finishNode(node, "TSModuleBlock");
      }
      tsParseAmbientExternalModuleDeclaration(node) {
        if (this.ts_isContextual(tokTypes2.global)) {
          node.global = true;
          node.id = this.parseIdent();
        } else if (this.match(tt.string)) {
          node.id = this.parseLiteral(this.value);
        } else {
          this.unexpected();
        }
        if (this.match(tt.braceL)) {
          this.enterScope(TS_SCOPE_TS_MODULE);
          node.body = this.tsParseModuleBlock();
          super.exitScope();
        } else {
          super.semicolon();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      }
      tsTryParseDeclare(nany) {
        if (this.isLineTerminator()) {
          return;
        }
        let starttype = this.type;
        let kind;
        if (this.isContextual("let")) {
          starttype = tt._var;
          kind = "let";
        }
        return this.tsInAmbientContext(() => {
          if (starttype === tt._function) {
            nany.declare = true;
            return this.parseFunctionStatement(
              nany,
              /* async */
              false,
              /* declarationPosition */
              true
            );
          }
          if (starttype === tt._class) {
            nany.declare = true;
            return this.parseClass(nany, true);
          }
          if (starttype === tokTypes2.enum) {
            return this.tsParseEnumDeclaration(nany, { declare: true });
          }
          if (starttype === tokTypes2.global) {
            return this.tsParseAmbientExternalModuleDeclaration(nany);
          }
          if (starttype === tt._const || starttype === tt._var) {
            if (!this.match(tt._const) || !this.isLookaheadContextual("enum")) {
              nany.declare = true;
              return this.parseVarStatement(nany, kind || this.value, true);
            }
            this.expect(tt._const);
            return this.tsParseEnumDeclaration(nany, {
              const: true,
              declare: true
            });
          }
          if (starttype === tokTypes2.interface) {
            const result = this.tsParseInterfaceDeclaration(nany, {
              declare: true
            });
            if (result) return result;
          }
          if (tokenIsIdentifier(starttype)) {
            return this.tsParseDeclaration(
              nany,
              this.value,
              /* next */
              true
            );
          }
        });
      }
      tsIsListTerminator(kind) {
        switch (kind) {
          case "EnumMembers":
          case "TypeMembers":
            return this.match(tt.braceR);
          case "HeritageClauseElement":
            return this.match(tt.braceL);
          case "TupleElementTypes":
            return this.match(tt.bracketR);
          case "TypeParametersOrArguments":
            return this.tsMatchRightRelational();
        }
      }
      /**
       * If !expectSuccess, returns undefined instead of failing to parse.
       * If expectSuccess, parseElement should always return a defined value.
       */
      tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
        const result = [];
        let trailingCommaPos = -1;
        for (; ; ) {
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          trailingCommaPos = -1;
          const element2 = parseElement();
          if (element2 == null) {
            return void 0;
          }
          result.push(element2);
          if (this.eat(tt.comma)) {
            trailingCommaPos = this.lastTokStart;
            continue;
          }
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          if (expectSuccess) {
            this.expect(tt.comma);
          }
          return void 0;
        }
        if (refTrailingCommaPos) {
          refTrailingCommaPos.value = trailingCommaPos;
        }
        return result;
      }
      tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
        return nonNull(
          this.tsParseDelimitedListWorker(
            kind,
            parseElement,
            /* expectSuccess */
            true,
            refTrailingCommaPos
          )
        );
      }
      tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
        if (!skipFirstToken) {
          if (bracket) {
            this.expect(tt.bracketL);
          } else {
            this.expect(tt.relational);
          }
        }
        const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
        if (bracket) {
          this.expect(tt.bracketR);
        } else {
          this.expect(tt.relational);
        }
        return result;
      }
      tsParseTypeParameterName() {
        const typeName = this.parseIdent();
        return typeName.name;
      }
      tsEatThenParseType(token) {
        return !this.match(token) ? void 0 : this.tsNextThenParseType();
      }
      tsExpectThenParseType(token) {
        return this.tsDoThenParseType(() => this.expect(token));
      }
      tsNextThenParseType() {
        return this.tsDoThenParseType(() => this.next());
      }
      tsDoThenParseType(cb) {
        return this.tsInType(() => {
          cb();
          return this.tsParseType();
        });
      }
      tsSkipParameterStart() {
        if (tokenIsIdentifier(this.type) || this.match(tt._this)) {
          this.next();
          return true;
        }
        if (this.match(tt.braceL)) {
          try {
            this.parseObj(true);
            return true;
          } catch {
            return false;
          }
        }
        if (this.match(tt.bracketL)) {
          this.next();
          try {
            this.parseBindingList(tt.bracketR, true, true);
            return true;
          } catch {
            return false;
          }
        }
        return false;
      }
      tsIsUnambiguouslyStartOfFunctionType() {
        this.next();
        if (this.match(tt.parenR) || this.match(tt.ellipsis)) {
          return true;
        }
        if (this.tsSkipParameterStart()) {
          if (this.match(tt.colon) || this.match(tt.comma) || this.match(tt.question) || this.match(tt.eq)) {
            return true;
          }
          if (this.match(tt.parenR)) {
            this.next();
            if (this.match(tt.arrow)) {
              return true;
            }
          }
        }
        return false;
      }
      tsIsStartOfFunctionType() {
        if (this.tsMatchLeftRelational()) {
          return true;
        }
        return this.match(tt.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
      }
      tsInAllowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.inDisallowConditionalTypesContext;
        this.inDisallowConditionalTypesContext = false;
        try {
          return cb();
        } finally {
          this.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsParseBindingListForSignature() {
        return super.parseBindingList(tt.parenR, true, true).map((pattern) => {
          if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
            this.raise(
              pattern.start,
              TypeScriptError.UnsupportedSignatureParameterKind(pattern.type)
            );
          }
          return pattern;
        });
      }
      tsParseTypePredicateAsserts() {
        if (this.type !== tokTypes2.asserts) {
          return false;
        }
        const containsEsc = this.containsEsc;
        this.next();
        if (!tokenIsIdentifier(this.type) && !this.match(tt._this)) {
          return false;
        }
        if (containsEsc) {
          this.raise(this.lastTokStart, "Escape sequence in keyword asserts");
        }
        return true;
      }
      tsParseThisTypeNode() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, "TSThisType");
      }
      tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
        this.tsInType(() => {
          if (eatColon) this.expect(tt.colon);
          t.typeAnnotation = this.tsParseType();
        });
        return this.finishNode(t, "TSTypeAnnotation");
      }
      tsParseThisTypePredicate(lhs) {
        this.next();
        const node = this.startNodeAtNode(lhs);
        node.parameterName = lhs;
        node.typeAnnotation = this.tsParseTypeAnnotation(
          /* eatColon */
          false
        );
        node.asserts = false;
        return this.finishNode(node, "TSTypePredicate");
      }
      tsParseThisTypeOrThisTypePredicate() {
        const thisKeyword = this.tsParseThisTypeNode();
        if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
          return this.tsParseThisTypePredicate(thisKeyword);
        } else {
          return thisKeyword;
        }
      }
      tsParseTypePredicatePrefix() {
        const id2 = this.parseIdent();
        if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
          this.next();
          return id2;
        }
      }
      tsParseTypeOrTypePredicateAnnotation(returnToken) {
        return this.tsInType(() => {
          const t = this.startNode();
          this.expect(returnToken);
          const node = this.startNode();
          const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
          if (asserts && this.match(tt._this)) {
            let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
            if (thisTypePredicate.type === "TSThisType") {
              node.parameterName = thisTypePredicate;
              node.asserts = true;
              node.typeAnnotation = null;
              thisTypePredicate = this.finishNode(node, "TSTypePredicate");
            } else {
              this.resetStartLocationFromNode(thisTypePredicate, node);
              thisTypePredicate.asserts = true;
            }
            t.typeAnnotation = thisTypePredicate;
            return this.finishNode(t, "TSTypeAnnotation");
          }
          const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
          if (!typePredicateVariable) {
            if (!asserts) {
              return this.tsParseTypeAnnotation(
                /* eatColon */
                false,
                t
              );
            }
            node.parameterName = this.parseIdent();
            node.asserts = asserts;
            node.typeAnnotation = null;
            t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
            return this.finishNode(t, "TSTypeAnnotation");
          }
          const type = this.tsParseTypeAnnotation(
            /* eatColon */
            false
          );
          node.parameterName = typePredicateVariable;
          node.typeAnnotation = type;
          node.asserts = asserts;
          t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
          return this.finishNode(t, "TSTypeAnnotation");
        });
      }
      // Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,
      // but here it's always false, because this is only used for types.
      tsFillSignature(returnToken, signature) {
        const returnTokenRequired = returnToken === tt.arrow;
        const paramsKey = "parameters";
        const returnTypeKey = "typeAnnotation";
        signature.typeParameters = this.tsTryParseTypeParameters();
        this.expect(tt.parenL);
        signature[paramsKey] = this.tsParseBindingListForSignature();
        if (returnTokenRequired) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        } else if (this.match(returnToken)) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        }
      }
      tsTryNextParseConstantContext() {
        if (this.lookahead().type !== tt._const) return null;
        this.next();
        const typeReference = this.tsParseTypeReference();
        if (typeReference.typeParameters || typeReference.typeArguments) {
          this.raise(
            typeReference.typeName.start,
            TypeScriptError.CannotFindName({
              name: "const"
            })
          );
        }
        return typeReference;
      }
      tsParseFunctionOrConstructorType(type, abstract) {
        const node = this.startNode();
        if (type === "TSConstructorType") {
          node.abstract = !!abstract;
          if (abstract) this.next();
          this.next();
        }
        this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(tt.arrow, node));
        return this.finishNode(node, type);
      }
      tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
        const node = this.startNode();
        const hasLeadingOperator = this.eat(operator);
        const types2 = [];
        do {
          types2.push(parseConstituentType());
        } while (this.eat(operator));
        if (types2.length === 1 && !hasLeadingOperator) {
          return types2[0];
        }
        node.types = types2;
        return this.finishNode(node, kind);
      }
      tsCheckTypeAnnotationForReadOnly(node) {
        switch (node.typeAnnotation.type) {
          case "TSTupleType":
          case "TSArrayType":
            return;
          default:
            this.raise(node.start, TypeScriptError.UnexpectedReadonly);
        }
      }
      tsParseTypeOperator() {
        const node = this.startNode();
        const operator = this.value;
        this.next();
        node.operator = operator;
        node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
        if (operator === "readonly") {
          this.tsCheckTypeAnnotationForReadOnly(node);
        }
        return this.finishNode(node, "TSTypeOperator");
      }
      tsParseConstraintForInferType() {
        if (this.eat(tt._extends)) {
          const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
          if (this.inDisallowConditionalTypesContext || !this.match(tt.question)) {
            return constraint;
          }
        }
      }
      tsParseInferType() {
        const node = this.startNode();
        this.expectContextual("infer");
        const typeParameter = this.startNode();
        typeParameter.name = this.tsParseTypeParameterName();
        typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
        node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        return this.finishNode(node, "TSInferType");
      }
      tsParseLiteralTypeNode() {
        const node = this.startNode();
        node.literal = (() => {
          switch (this.type) {
            case tt.num:
            case tt.string:
            case tt._true:
            case tt._false:
              return this.parseExprAtom();
            default:
              this.unexpected();
          }
        })();
        return this.finishNode(node, "TSLiteralType");
      }
      tsParseImportType() {
        const node = this.startNode();
        this.expect(tt._import);
        this.expect(tt.parenL);
        if (!this.match(tt.string)) {
          this.raise(this.start, TypeScriptError.UnsupportedImportTypeArgument);
        }
        node.argument = this.parseExprAtom();
        this.expect(tt.parenR);
        if (this.eat(tt.dot)) {
          node.qualifier = this.tsParseEntityName();
        }
        if (this.tsMatchLeftRelational()) {
          node.typeArguments = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSImportType");
      }
      tsParseTypeQuery() {
        const node = this.startNode();
        this.expect(tt._typeof);
        if (this.match(tt._import)) {
          node.exprName = this.tsParseImportType();
        } else {
          node.exprName = this.tsParseEntityName();
        }
        if (!this.hasPrecedingLineBreak() && this.tsMatchLeftRelational()) {
          node.typeArguments = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSTypeQuery");
      }
      tsParseMappedTypeParameter() {
        const node = this.startNode();
        node.name = this.tsParseTypeParameterName();
        node.constraint = this.tsExpectThenParseType(tt._in);
        return this.finishNode(node, "TSTypeParameter");
      }
      tsParseMappedType() {
        const node = this.startNode();
        this.expect(tt.braceL);
        if (this.match(tt.plusMin)) {
          node.readonly = this.value;
          this.next();
          this.expectContextual("readonly");
        } else if (this.eatContextual("readonly")) {
          node.readonly = true;
        }
        this.expect(tt.bracketL);
        node.typeParameter = this.tsParseMappedTypeParameter();
        node.nameType = this.eatContextual("as") ? this.tsParseType() : null;
        this.expect(tt.bracketR);
        if (this.match(tt.plusMin)) {
          node.optional = this.value;
          this.next();
          this.expect(tt.question);
        } else if (this.eat(tt.question)) {
          node.optional = true;
        }
        node.typeAnnotation = this.tsTryParseType();
        this.semicolon();
        this.expect(tt.braceR);
        return this.finishNode(node, "TSMappedType");
      }
      tsParseTypeLiteral() {
        const node = this.startNode();
        node.members = this.tsParseObjectTypeMembers();
        return this.finishNode(node, "TSTypeLiteral");
      }
      tsParseTupleElementType() {
        const startLoc = this.startLoc;
        const startPos = this["start"];
        const rest2 = this.eat(tt.ellipsis);
        let type = this.tsParseType();
        const optional = this.eat(tt.question);
        const labeled2 = this.eat(tt.colon);
        if (labeled2) {
          const labeledNode = this.startNodeAtNode(type);
          labeledNode.optional = optional;
          if (type.type === "TSTypeReference" && !type.typeArguments && type.typeName.type === "Identifier") {
            labeledNode.label = type.typeName;
          } else {
            this.raise(type.start, TypeScriptError.InvalidTupleMemberLabel);
            labeledNode.label = type;
          }
          labeledNode.elementType = this.tsParseType();
          type = this.finishNode(labeledNode, "TSNamedTupleMember");
        } else if (optional) {
          const optionalTypeNode = this.startNodeAtNode(type);
          optionalTypeNode.typeAnnotation = type;
          type = this.finishNode(optionalTypeNode, "TSOptionalType");
        }
        if (rest2) {
          const restNode = this.startNodeAt(startPos, startLoc);
          restNode.typeAnnotation = type;
          type = this.finishNode(restNode, "TSRestType");
        }
        return type;
      }
      tsParseTupleType() {
        const node = this.startNode();
        node.elementTypes = this.tsParseBracketedList(
          "TupleElementTypes",
          this.tsParseTupleElementType.bind(this),
          /* bracket */
          true,
          /* skipFirstToken */
          false
        );
        let seenOptionalElement = false;
        let labeledElements = null;
        node.elementTypes.forEach((elementNode) => {
          const { type } = elementNode;
          if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
            this.raise(elementNode.start, TypeScriptError.OptionalTypeBeforeRequired);
          }
          seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
          let checkType = type;
          if (type === "TSRestType") {
            elementNode = elementNode.typeAnnotation;
            checkType = elementNode.type;
          }
          const isLabeled = checkType === "TSNamedTupleMember";
          labeledElements ?? (labeledElements = isLabeled);
          if (labeledElements !== isLabeled) {
            this.raise(elementNode.start, TypeScriptError.MixedLabeledAndUnlabeledElements);
          }
        });
        return this.finishNode(node, "TSTupleType");
      }
      tsParseTemplateLiteralType() {
        const node = this.startNode();
        node.literal = this.parseTemplate({ isTagged: false });
        return this.finishNode(node, "TSLiteralType");
      }
      tsParseTypeReference() {
        const node = this.startNode();
        node.typeName = this.tsParseEntityName();
        if (!this.hasPrecedingLineBreak() && this.tsMatchLeftRelational()) {
          node.typeArguments = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSTypeReference");
      }
      tsMatchLeftRelational() {
        return this.match(tt.relational) && this.value === "<";
      }
      tsMatchRightRelational() {
        return this.match(tt.relational) && this.value === ">";
      }
      tsParseParenthesizedType() {
        const node = this.startNode();
        this.expect(tt.parenL);
        node.typeAnnotation = this.tsParseType();
        this.expect(tt.parenR);
        return this.finishNode(node, "TSParenthesizedType");
      }
      tsParseNonArrayType() {
        switch (this.type) {
          case tt.string:
          case tt.num:
          case tt._true:
          case tt._false:
            return this.tsParseLiteralTypeNode();
          case tt.plusMin:
            if (this.value === "-") {
              const node = this.startNode();
              const nextToken = this.lookahead();
              if (nextToken.type !== tt.num) {
                this.unexpected();
              }
              node.literal = this.parseMaybeUnary();
              return this.finishNode(node, "TSLiteralType");
            }
            break;
          case tt._this:
            return this.tsParseThisTypeOrThisTypePredicate();
          case tt._typeof:
            return this.tsParseTypeQuery();
          case tt._import:
            return this.tsParseImportType();
          case tt.braceL:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
          case tt.bracketL:
            return this.tsParseTupleType();
          case tt.parenL:
            return this.tsParseParenthesizedType();
          case tt.backQuote:
          case tt.dollarBraceL:
            return this.tsParseTemplateLiteralType();
          default: {
            const { type } = this;
            if (tokenIsIdentifier(type) || type === tt._void || type === tt._null) {
              const nodeType = type === tt._void ? "TSVoidKeyword" : type === tt._null ? "TSNullKeyword" : keywordTypeFromName(this.value);
              if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                const node = this.startNode();
                this.next();
                return this.finishNode(node, nodeType);
              }
              return this.tsParseTypeReference();
            }
          }
        }
        this.unexpected();
      }
      tsParseArrayTypeOrHigher() {
        let type = this.tsParseNonArrayType();
        while (!this.hasPrecedingLineBreak() && this.eat(tt.bracketL)) {
          if (this.match(tt.bracketR)) {
            const node = this.startNodeAtNode(type);
            node.elementType = type;
            this.expect(tt.bracketR);
            type = this.finishNode(node, "TSArrayType");
          } else {
            const node = this.startNodeAtNode(type);
            node.objectType = type;
            node.indexType = this.tsParseType();
            this.expect(tt.bracketR);
            type = this.finishNode(node, "TSIndexedAccessType");
          }
        }
        return type;
      }
      tsParseTypeOperatorOrHigher() {
        const isTypeOperator = tokenIsTSTypeOperator(this.type) && !this.containsEsc;
        return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual("infer") ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
      }
      tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType(
          "TSIntersectionType",
          this.tsParseTypeOperatorOrHigher.bind(this),
          tt.bitwiseAND
        );
      }
      tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType(
          "TSUnionType",
          this.tsParseIntersectionTypeOrHigher.bind(this),
          tt.bitwiseOR
        );
      }
      tsParseNonConditionalType() {
        if (this.tsIsStartOfFunctionType()) {
          return this.tsParseFunctionOrConstructorType("TSFunctionType");
        }
        if (this.match(tt._new)) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType");
        } else if (this.isAbstractConstructorSignature()) {
          return this.tsParseFunctionOrConstructorType(
            "TSConstructorType",
            /* abstract */
            true
          );
        }
        return this.tsParseUnionTypeOrHigher();
      }
      /** Be sure to be in a type context before calling this, using `tsInType`. */
      tsParseType() {
        assert(this.inType);
        const type = this.tsParseNonConditionalType();
        if (this.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(tt._extends)) {
          return type;
        }
        const node = this.startNodeAtNode(type);
        node.checkType = type;
        node.extendsType = this.tsInDisallowConditionalTypesContext(
          () => this.tsParseNonConditionalType()
        );
        this.expect(tt.question);
        node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        this.expect(tt.colon);
        node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        return this.finishNode(node, "TSConditionalType");
      }
      tsIsUnambiguouslyIndexSignature() {
        this.next();
        if (tokenIsIdentifier(this.type)) {
          this.next();
          return this.match(tt.colon);
        }
        return false;
      }
      /**
       * Runs `cb` in a type context.
       * This should be called one token *before* the first type token,
       * so that the call to `next()` is run in type context.
       */
      tsInType(cb) {
        const oldInType = this.inType;
        this.inType = true;
        try {
          return cb();
        } finally {
          this.inType = oldInType;
        }
      }
      tsTryParseIndexSignature(node) {
        if (!(this.match(tt.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
          return void 0;
        }
        this.expect(tt.bracketL);
        const id2 = this.parseIdent();
        id2.typeAnnotation = this.tsParseTypeAnnotation();
        this.resetEndLocation(id2);
        this.expect(tt.bracketR);
        node.parameters = [id2];
        const type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, "TSIndexSignature");
      }
      // for better error recover
      tsParseNoneModifiers(node) {
        this.tsParseModifiers({
          modified: node,
          allowedModifiers: [],
          disallowedModifiers: ["in", "out"],
          errorTemplate: TypeScriptError.InvalidModifierOnTypeParameterPositions
        });
      }
      tsParseTypeParameter(parseModifiers = this.tsParseNoneModifiers.bind(this)) {
        const node = this.startNode();
        parseModifiers(node);
        node.name = this.tsParseTypeParameterName();
        node.constraint = this.tsEatThenParseType(tt._extends);
        node.default = this.tsEatThenParseType(tt.eq);
        return this.finishNode(node, "TSTypeParameter");
      }
      tsParseTypeParameters(parseModifiers) {
        const node = this.startNode();
        if (this.tsMatchLeftRelational() || this.matchJsx("jsxTagStart")) {
          this.next();
        } else {
          this.unexpected();
        }
        const refTrailingCommaPos = { value: -1 };
        node.params = this.tsParseBracketedList(
          "TypeParametersOrArguments",
          this.tsParseTypeParameter.bind(this, parseModifiers),
          /* bracket */
          false,
          /* skipFirstToken */
          true,
          refTrailingCommaPos
        );
        if (node.params.length === 0) {
          this.raise(this.start, TypeScriptError.EmptyTypeParameters);
        }
        if (refTrailingCommaPos.value !== -1) {
          this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
        }
        return this.finishNode(node, "TSTypeParameterDeclaration");
      }
      tsTryParseTypeParameters(parseModifiers) {
        if (this.tsMatchLeftRelational()) {
          return this.tsParseTypeParameters(parseModifiers);
        }
      }
      tsTryParse(f) {
        const state = this.getCurLookaheadState();
        const result = f();
        if (result !== void 0 && result !== false) {
          return result;
        } else {
          this.setLookaheadState(state);
          return void 0;
        }
      }
      tsTokenCanFollowModifier() {
        return (this.match(tt.bracketL) || this.match(tt.braceL) || this.match(tt.star) || this.match(tt.ellipsis) || this.match(tt.privateId) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
      }
      tsNextTokenCanFollowModifier() {
        this.next(true);
        return this.tsTokenCanFollowModifier();
      }
      /** Parses a modifier matching one the given modifier names. */
      tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
        const modifier = this.value;
        if (allowedModifiers.indexOf(modifier) !== -1 && !this.containsEsc) {
          if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
            return void 0;
          }
          if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
            return modifier;
          }
        }
        return void 0;
      }
      tsParseModifiersByMap({
        modified,
        map
      }) {
        for (const key2 of Object.keys(map)) {
          modified[key2] = map[key2];
        }
      }
      /** Parses a list of modifiers, in any order.
       *  If you need a specific order, you must call this function multiple times:
       *    this.tsParseModifiers({ modified: node, allowedModifiers: ['public'] });
       *    this.tsParseModifiers({ modified: node, allowedModifiers: ["abstract", "readonly"] });
       */
      tsParseModifiers({
        modified,
        allowedModifiers,
        disallowedModifiers,
        stopOnStartOfClassStaticBlock,
        errorTemplate = TypeScriptError.InvalidModifierOnTypeMember
      }) {
        const modifiedMap = {};
        const enforceOrder = (loc, modifier, before, after) => {
          if (modifier === before && modified[after]) {
            this.raise(
              loc.column,
              TypeScriptError.InvalidModifiersOrder({ orderedModifiers: [before, after] })
            );
          }
        };
        const incompatible = (loc, modifier, mod1, mod2) => {
          if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
            this.raise(
              loc.column,
              TypeScriptError.IncompatibleModifiers({ modifiers: [mod1, mod2] })
            );
          }
        };
        for (; ; ) {
          const startLoc = this.startLoc;
          const modifier = this.tsParseModifier(
            allowedModifiers.concat(disallowedModifiers ?? []),
            stopOnStartOfClassStaticBlock
          );
          if (!modifier) break;
          if (tsIsAccessModifier(modifier)) {
            if (modified.accessibility) {
              this.raise(this.start, TypeScriptError.DuplicateAccessibilityModifier());
            } else {
              enforceOrder(startLoc, modifier, modifier, "override");
              enforceOrder(startLoc, modifier, modifier, "static");
              enforceOrder(startLoc, modifier, modifier, "readonly");
              enforceOrder(startLoc, modifier, modifier, "accessor");
              modifiedMap.accessibility = modifier;
              modified["accessibility"] = modifier;
            }
          } else if (tsIsVarianceAnnotations(modifier)) {
            if (modified[modifier]) {
              this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));
            } else {
              enforceOrder(startLoc, modifier, "in", "out");
              modifiedMap[modifier] = modifier;
              modified[modifier] = true;
            }
          } else if (tsIsClassAccessor(modifier)) {
            if (modified[modifier]) {
              this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));
            } else {
              incompatible(startLoc, modifier, "accessor", "readonly");
              incompatible(startLoc, modifier, "accessor", "static");
              incompatible(startLoc, modifier, "accessor", "override");
              modifiedMap[modifier] = modifier;
              modified[modifier] = true;
            }
          } else if (modifier === "const") {
            if (modified[modifier]) {
              this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));
            } else {
              modifiedMap[modifier] = modifier;
              modified[modifier] = true;
            }
          } else {
            if (Object.hasOwnProperty.call(modified, modifier)) {
              this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));
            } else {
              enforceOrder(startLoc, modifier, "static", "readonly");
              enforceOrder(startLoc, modifier, "static", "override");
              enforceOrder(startLoc, modifier, "override", "readonly");
              enforceOrder(startLoc, modifier, "abstract", "override");
              incompatible(startLoc, modifier, "declare", "override");
              incompatible(startLoc, modifier, "static", "abstract");
              modifiedMap[modifier] = modifier;
              modified[modifier] = true;
            }
          }
          if (disallowedModifiers == null ? void 0 : disallowedModifiers.includes(modifier)) {
            this.raise(this.start, errorTemplate);
          }
        }
        return modifiedMap;
      }
      tsParseInOutModifiers(node) {
        this.tsParseModifiers({
          modified: node,
          allowedModifiers: ["in", "out"],
          disallowedModifiers: [
            "public",
            "private",
            "protected",
            "readonly",
            "declare",
            "abstract",
            "override"
          ],
          errorTemplate: TypeScriptError.InvalidModifierOnTypeParameter
        });
      }
      // Handle type assertions
      parseMaybeUnary(refExpressionErrors, sawUnary, incDec, forInit) {
        if (!(options == null ? void 0 : options.jsx) && this.tsMatchLeftRelational()) {
          return this.tsParseTypeAssertion();
        } else {
          return super.parseMaybeUnary(refExpressionErrors, sawUnary, incDec, forInit);
        }
      }
      tsParseTypeAssertion() {
        if (disallowAmbiguousJSXLike) {
          this.raise(this.start, TypeScriptError.ReservedTypeAssertion);
        }
        const result = this.tryParse(() => {
          const node = this.startNode();
          const _const = this.tsTryNextParseConstantContext();
          node.typeAnnotation = _const || this.tsNextThenParseType();
          this.expect(tt.relational);
          node.expression = this.parseMaybeUnary();
          return this.finishNode(node, "TSTypeAssertion");
        });
        if (result.error) {
          return this.tsParseTypeParameters(this.tsParseConstModifier);
        } else {
          return result.node;
        }
      }
      tsParseTypeArguments() {
        const node = this.startNode();
        node.params = this.tsInType(
          () => (
            // Temporarily remove a JSX parsing context, which makes us scan different tokens.
            this.tsInNoContext(() => {
              this.expect(tt.relational);
              return this.tsParseDelimitedList(
                "TypeParametersOrArguments",
                this.tsParseType.bind(this)
              );
            })
          )
        );
        if (node.params.length === 0) {
          this.raise(this.start, TypeScriptError.EmptyTypeArguments);
        }
        this.exprAllowed = false;
        this.expect(tt.relational);
        return this.finishNode(node, "TSTypeParameterInstantiation");
      }
      tsParseHeritageClause(token) {
        const originalStart = this.start;
        const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
          const node = this.startNode();
          node.expression = this.tsParseEntityName();
          if (this.tsMatchLeftRelational()) {
            node.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node, "TSExpressionWithTypeArguments");
        });
        if (!delimitedList.length) {
          this.raise(originalStart, TypeScriptError.EmptyHeritageClauseType({ token }));
        }
        return delimitedList;
      }
      tsParseTypeMemberSemicolon() {
        if (!this.eat(tt.comma) && !this.isLineTerminator()) {
          this.expect(tt.semi);
        }
      }
      tsTryParseAndCatch(f) {
        const result = this.tryParse(
          (abort) => (
            // @ts-expect-error todo(flow->ts)
            f() || abort()
          )
        );
        if (result.aborted || !result.node) return void 0;
        if (result.error) this.setLookaheadState(result.failState);
        return result.node;
      }
      tsParseSignatureMember(kind, node) {
        this.tsFillSignature(tt.colon, node);
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, kind);
      }
      tsParsePropertyOrMethodSignature(node, readonly) {
        if (this.eat(tt.question)) node.optional = true;
        const nodeAny = node;
        if (this.match(tt.parenL) || this.tsMatchLeftRelational()) {
          if (readonly) {
            this.raise(node.start, TypeScriptError.ReadonlyForMethodSignature);
          }
          const method2 = nodeAny;
          if (method2.kind && this.tsMatchLeftRelational()) {
            this.raise(this.start, TypeScriptError.AccesorCannotHaveTypeParameters);
          }
          this.tsFillSignature(tt.colon, method2);
          this.tsParseTypeMemberSemicolon();
          const paramsKey = "parameters";
          const returnTypeKey = "typeAnnotation";
          if (method2.kind === "get") {
            if (method2[paramsKey].length > 0) {
              this.raise(this.start, "A 'get' accesor must not have any formal parameters.");
              if (this.isThisParam(method2[paramsKey][0])) {
                this.raise(this.start, TypeScriptError.AccesorCannotDeclareThisParameter);
              }
            }
          } else if (method2.kind === "set") {
            if (method2[paramsKey].length !== 1) {
              this.raise(this.start, "A 'get' accesor must not have any formal parameters.");
            } else {
              const firstParameter = method2[paramsKey][0];
              if (this.isThisParam(firstParameter)) {
                this.raise(this.start, TypeScriptError.AccesorCannotDeclareThisParameter);
              }
              if (firstParameter.type === "Identifier" && firstParameter.optional) {
                this.raise(this.start, TypeScriptError.SetAccesorCannotHaveOptionalParameter);
              }
              if (firstParameter.type === "RestElement") {
                this.raise(this.start, TypeScriptError.SetAccesorCannotHaveRestParameter);
              }
            }
            if (method2[returnTypeKey]) {
              this.raise(
                method2[returnTypeKey].start,
                TypeScriptError.SetAccesorCannotHaveReturnType
              );
            }
          } else {
            method2.kind = "method";
          }
          return this.finishNode(method2, "TSMethodSignature");
        } else {
          const property = nodeAny;
          if (readonly) property.readonly = true;
          const type = this.tsTryParseTypeAnnotation();
          if (type) property.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(property, "TSPropertySignature");
        }
      }
      tsParseTypeMember() {
        const node = this.startNode();
        if (this.match(tt.parenL) || this.tsMatchLeftRelational()) {
          return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
        }
        if (this.match(tt._new)) {
          const id2 = this.startNode();
          this.next();
          if (this.match(tt.parenL) || this.tsMatchLeftRelational()) {
            return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
          } else {
            node.key = this.createIdentifier(id2, "new");
            return this.tsParsePropertyOrMethodSignature(node, false);
          }
        }
        this.tsParseModifiers({
          modified: node,
          allowedModifiers: ["readonly"],
          disallowedModifiers: [
            "declare",
            "abstract",
            "private",
            "protected",
            "public",
            "static",
            "override"
          ]
        });
        const idx = this.tsTryParseIndexSignature(node);
        if (idx) {
          return idx;
        }
        this.parsePropertyName(node);
        if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
          node.kind = node.key.name;
          this.parsePropertyName(node);
        }
        return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
      }
      tsParseList(kind, parseElement) {
        const result = [];
        while (!this.tsIsListTerminator(kind)) {
          result.push(parseElement());
        }
        return result;
      }
      tsParseObjectTypeMembers() {
        this.expect(tt.braceL);
        const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
        this.expect(tt.braceR);
        return members;
      }
      tsParseInterfaceDeclaration(node, properties = {}) {
        if (this.hasFollowingLineBreak()) return null;
        this.expectContextual("interface");
        if (properties.declare) node.declare = true;
        if (tokenIsIdentifier(this.type)) {
          node.id = this.parseIdent();
          this.checkLValSimple(node.id, acornScope.BIND_TS_INTERFACE);
        } else {
          node.id = null;
          this.raise(this.start, TypeScriptError.MissingInterfaceName);
        }
        node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
        if (this.eat(tt._extends)) {
          node.extends = this.tsParseHeritageClause("extends");
        }
        const body = this.startNode();
        body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
        node.body = this.finishNode(body, "TSInterfaceBody");
        return this.finishNode(node, "TSInterfaceDeclaration");
      }
      tsParseAbstractDeclaration(node) {
        if (this.match(tt._class)) {
          node.abstract = true;
          return this.parseClass(node, true);
        } else if (this.ts_isContextual(tokTypes2.interface)) {
          if (!this.hasFollowingLineBreak()) {
            node.abstract = true;
            return this.tsParseInterfaceDeclaration(node);
          }
        } else {
          this.unexpected(node.start);
        }
      }
      tsIsDeclarationStart() {
        return tokenIsTSDeclarationStart(this.type);
      }
      tsParseExpressionStatement(node, expr) {
        switch (expr.name) {
          case "declare": {
            const declaration2 = this.tsTryParseDeclare(node);
            if (declaration2) {
              declaration2.declare = true;
              return declaration2;
            }
            break;
          }
          case "global":
            if (this.match(tt.braceL)) {
              this.enterScope(TS_SCOPE_TS_MODULE);
              const mod = node;
              mod.global = true;
              mod.id = expr;
              mod.body = this.tsParseModuleBlock();
              super.exitScope();
              return this.finishNode(mod, "TSModuleDeclaration");
            }
            break;
          default:
            return this.tsParseDeclaration(
              node,
              expr.name,
              /* next */
              false
            );
        }
      }
      tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(
          /* allowReservedWords */
          false
        );
      }
      tsIsExportDefaultSpecifier() {
        const { type } = this;
        const isAsync = this.isAsyncFunction();
        const isLet = this.isLet();
        if (tokenIsIdentifier(type)) {
          if (isAsync && !this.containsEsc || isLet) {
            return false;
          }
          if ((type === tokTypes2.type || type === tokTypes2.interface) && !this.containsEsc) {
            const ahead = this.lookahead();
            if (tokenIsIdentifier(ahead.type) && !this.isContextualWithState("from", ahead) || ahead.type === tt.braceL) {
              return false;
            }
          }
        } else if (!this.match(tt._default)) {
          return false;
        }
        const next2 = this.nextTokenStart();
        const hasFrom = this.isUnparsedContextual(next2, "from");
        if (this.input.charCodeAt(next2) === 44 || tokenIsIdentifier(this.type) && hasFrom) {
          return true;
        }
        if (this.match(tt._default) && hasFrom) {
          const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next2 + 4));
          return nextAfterFrom === 34 || nextAfterFrom === 39;
        }
        return false;
      }
      tsInAmbientContext(cb) {
        const oldIsAmbientContext = this.isAmbientContext;
        this.isAmbientContext = true;
        try {
          return cb();
        } finally {
          this.isAmbientContext = oldIsAmbientContext;
        }
      }
      tsCheckLineTerminator(next2) {
        if (next2) {
          if (this.hasFollowingLineBreak()) return false;
          this.next();
          return true;
        }
        return !this.isLineTerminator();
      }
      tsParseModuleOrNamespaceDeclaration(node, nested = false) {
        node.id = this.parseIdent();
        if (!nested) {
          this.checkLValSimple(node.id, acornScope.BIND_TS_NAMESPACE);
        }
        if (this.eat(tt.dot)) {
          const inner = this.startNode();
          this.tsParseModuleOrNamespaceDeclaration(inner, true);
          node.body = inner;
        } else {
          this.enterScope(TS_SCOPE_TS_MODULE);
          node.body = this.tsParseModuleBlock();
          super.exitScope();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      }
      checkLValSimple(expr, bindingType = acornScope.BIND_NONE, checkClashes) {
        if (expr.type === "TSNonNullExpression" || expr.type === "TSAsExpression") {
          expr = expr.expression;
        }
        return super.checkLValSimple(expr, bindingType, checkClashes);
      }
      tsParseTypeAliasDeclaration(node) {
        node.id = this.parseIdent();
        this.checkLValSimple(node.id, acornScope.BIND_TS_TYPE);
        node.typeAnnotation = this.tsInType(() => {
          node.typeParameters = this.tsTryParseTypeParameters(
            this.tsParseInOutModifiers.bind(this)
          );
          this.expect(tt.eq);
          if (this.ts_isContextual(tokTypes2.interface) && this.lookahead().type !== tt.dot) {
            const node2 = this.startNode();
            this.next();
            return this.finishNode(node2, "TSIntrinsicKeyword");
          }
          return this.tsParseType();
        });
        this.semicolon();
        return this.finishNode(node, "TSTypeAliasDeclaration");
      }
      // Common to tsTryParseDeclare, tsTryParseExportDeclaration, and tsParseExpressionStatement.
      tsParseDeclaration(node, value, next2) {
        switch (value) {
          case "abstract":
            if (this.tsCheckLineTerminator(next2) && (this.match(tt._class) || tokenIsIdentifier(this.type))) {
              return this.tsParseAbstractDeclaration(node);
            }
            break;
          case "module":
            if (this.tsCheckLineTerminator(next2)) {
              if (this.match(tt.string)) {
                return this.tsParseAmbientExternalModuleDeclaration(node);
              } else if (tokenIsIdentifier(this.type)) {
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }
            }
            break;
          case "namespace":
            if (this.tsCheckLineTerminator(next2) && tokenIsIdentifier(this.type)) {
              return this.tsParseModuleOrNamespaceDeclaration(node);
            }
            break;
          case "type":
            if (this.tsCheckLineTerminator(next2) && tokenIsIdentifier(this.type)) {
              return this.tsParseTypeAliasDeclaration(node);
            }
            break;
        }
      }
      // Note: this won't b·e called unless the keyword is allowed in
      // `shouldParseExportDeclaration`.
      tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(
          this.startNode(),
          this.value,
          /* next */
          true
        );
      }
      tsParseImportEqualsDeclaration(node, isExport) {
        node.isExport = isExport || false;
        node.id = this.parseIdent();
        this.checkLValSimple(node.id, acornScope.BIND_LEXICAL);
        super.expect(tt.eq);
        const moduleReference = this.tsParseModuleReference();
        if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
          this.raise(moduleReference.start, TypeScriptError.ImportAliasHasImportType);
        }
        node.moduleReference = moduleReference;
        super.semicolon();
        return this.finishNode(node, "TSImportEqualsDeclaration");
      }
      isExportDefaultSpecifier() {
        if (this.tsIsDeclarationStart()) return false;
        const { type } = this;
        if (tokenIsIdentifier(type)) {
          if (this.isContextual("async") || this.isContextual("let")) {
            return false;
          }
          if ((type === tokTypes2.type || type === tokTypes2.interface) && !this.containsEsc) {
            const ahead = this.lookahead();
            if (tokenIsIdentifier(ahead.type) && !this.isContextualWithState("from", ahead) || ahead.type === tt.braceL) {
              return false;
            }
          }
        } else if (!this.match(tt._default)) {
          return false;
        }
        const next2 = this.nextTokenStart();
        const hasFrom = this.isUnparsedContextual(next2, "from");
        if (this.input.charCodeAt(next2) === 44 || tokenIsIdentifier(this.type) && hasFrom) {
          return true;
        }
        if (this.match(tt._default) && hasFrom) {
          const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next2 + 4));
          return nextAfterFrom === 34 || nextAfterFrom === 39;
        }
        return false;
      }
      parseTemplate({ isTagged = false } = {}) {
        let node = this.startNode();
        this.next();
        node.expressions = [];
        let curElt = this.parseTemplateElement({ isTagged });
        node.quasis = [curElt];
        while (!curElt.tail) {
          if (this.type === tt.eof) this.raise(this.pos, "Unterminated template literal");
          this.expect(tt.dollarBraceL);
          node.expressions.push(this.inType ? this.tsParseType() : this.parseExpression());
          this.expect(tt.braceR);
          node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
        }
        this.next();
        return this.finishNode(node, "TemplateLiteral");
      }
      parseFunction(node, statement, allowExpressionBody, isAsync, forInit) {
        this.initFunction(node);
        if (this.ecmaVersion >= 9 || this.ecmaVersion >= 6 && !isAsync) {
          if (this.type === tt.star && statement & FUNC_HANGING_STATEMENT2) {
            this.unexpected();
          }
          node.generator = this.eat(tt.star);
        }
        if (this.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        if (statement & FUNC_STATEMENT2) {
          node.id = statement & FUNC_NULLABLE_ID2 && this.type !== tt.name ? null : this.parseIdent();
        }
        let oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        const oldMaybeInArrowParameters = this.maybeInArrowParameters;
        this.maybeInArrowParameters = false;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags2(node.async, node.generator));
        if (!(statement & FUNC_STATEMENT2)) {
          node.id = this.type === tt.name ? this.parseIdent() : null;
        }
        this.parseFunctionParams(node);
        const isDeclaration = statement & FUNC_STATEMENT2;
        this.parseFunctionBody(node, allowExpressionBody, false, forInit, {
          isFunctionDeclaration: isDeclaration
        });
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        if (statement & FUNC_STATEMENT2 && node.id && !(statement & FUNC_HANGING_STATEMENT2)) {
          if (node.body) {
            this.checkLValSimple(
              node.id,
              this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? acornScope.BIND_VAR : acornScope.BIND_LEXICAL : acornScope.BIND_FUNCTION
            );
          } else {
            this.checkLValSimple(node.id, acornScope.BIND_NONE);
          }
        }
        this.maybeInArrowParameters = oldMaybeInArrowParameters;
        return this.finishNode(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
      }
      parseFunctionBody(node, isArrowFunction = false, isMethod = false, forInit = false, tsConfig) {
        if (this.match(tt.colon)) {
          node.returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);
        }
        const bodilessType = (tsConfig == null ? void 0 : tsConfig.isFunctionDeclaration) ? "TSDeclareFunction" : (tsConfig == null ? void 0 : tsConfig.isClassMethod) ? "TSDeclareMethod" : void 0;
        if (bodilessType && !this.match(tt.braceL) && this.isLineTerminator()) {
          return this.finishNode(node, bodilessType);
        }
        if (bodilessType === "TSDeclareFunction" && this.isAmbientContext) {
          this.raise(node.start, TypeScriptError.DeclareFunctionHasImplementation);
          if (node.declare) {
            super.parseFunctionBody(node, isArrowFunction, isMethod, false);
            return this.finishNode(node, bodilessType);
          }
        }
        super.parseFunctionBody(node, isArrowFunction, isMethod, forInit);
        return node;
      }
      parseNew() {
        var _a2;
        if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        let node = this.startNode();
        let meta = this.parseIdent(true);
        if (this.ecmaVersion >= 6 && this.eat(tt.dot)) {
          node.meta = meta;
          let containsEsc = this.containsEsc;
          node.property = this.parseIdent(true);
          if (node.property.name !== "target")
            this.raiseRecoverable(
              node.property.start,
              "The only valid meta property for new is 'new.target'"
            );
          if (containsEsc)
            this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
          if (!this["allowNewDotTarget"])
            this.raiseRecoverable(
              node.start,
              "'new.target' can only be used in functions and class static block"
            );
          return this.finishNode(node, "MetaProperty");
        }
        let startPos = this.start, startLoc = this.startLoc, isImport = this.type === tt._import;
        node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
        if (isImport && node.callee.type === "ImportExpression") {
          this.raise(startPos, "Cannot use new with import()");
        }
        const { callee } = node;
        if (callee.type === "TSInstantiationExpression" && !((_a2 = callee.extra) == null ? void 0 : _a2.parenthesized)) {
          node.typeArguments = callee.typeArguments;
          node.callee = callee.expression;
        }
        if (this.eat(tt.parenL))
          node.arguments = this.parseExprList(tt.parenR, this.ecmaVersion >= 8, false);
        else node.arguments = [];
        return this.finishNode(node, "NewExpression");
      }
      parseExprOp(left, leftStartPos, leftStartLoc, minPrec, forInit) {
        if (tt._in.binop > minPrec && !this.hasPrecedingLineBreak()) {
          let nodeType;
          if (this.isContextual("as")) {
            nodeType = "TSAsExpression";
          }
          if (this.isContextual("satisfies")) {
            nodeType = "TSSatisfiesExpression";
          }
          if (nodeType) {
            const node = this.startNodeAt(leftStartPos, leftStartLoc);
            node.expression = left;
            const _const = this.tsTryNextParseConstantContext();
            if (_const) {
              node.typeAnnotation = _const;
            } else {
              node.typeAnnotation = this.tsNextThenParseType();
            }
            this.finishNode(node, nodeType);
            this.reScan_lt_gt();
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
          }
        }
        return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec, forInit);
      }
      parseImportSpecifiers() {
        let nodes = [], first = true;
        if (acornTypeScript.tokenIsIdentifier(this.type)) {
          nodes.push(this.parseImportDefaultSpecifier());
          if (!this.eat(tt.comma)) return nodes;
        }
        if (this.type === tt.star) {
          nodes.push(this.parseImportNamespaceSpecifier());
          return nodes;
        }
        this.expect(tt.braceL);
        while (!this.eat(tt.braceR)) {
          if (!first) {
            this.expect(tt.comma);
            if (this.afterTrailingComma(tt.braceR)) break;
          } else first = false;
          nodes.push(this.parseImportSpecifier());
        }
        return nodes;
      }
      /**
       * @param {Node} node this may be ImportDeclaration |
       * TsImportEqualsDeclaration
       * @returns AnyImport
       * */
      parseImport(node) {
        let enterHead = this.lookahead();
        node.importKind = "value";
        this.importOrExportOuterKind = "value";
        if (tokenIsIdentifier(enterHead.type) || this.match(tt.star) || this.match(tt.braceL)) {
          let ahead = this.lookahead(2);
          if (
            // import type, { a } from "b";
            ahead.type !== tt.comma && // import type from "a";
            !this.isContextualWithState("from", ahead) && // import type = require("a");
            ahead.type !== tt.eq && this.ts_eatContextualWithState("type", 1, enterHead)
          ) {
            this.importOrExportOuterKind = "type";
            node.importKind = "type";
            enterHead = this.lookahead();
            ahead = this.lookahead(2);
          }
          if (tokenIsIdentifier(enterHead.type) && ahead.type === tt.eq) {
            this.next();
            const importNode = this.tsParseImportEqualsDeclaration(node);
            this.importOrExportOuterKind = "value";
            return importNode;
          }
        }
        this.next();
        if (this.type === tt.string) {
          node.specifiers = [];
          node.source = this.parseExprAtom();
        } else {
          node.specifiers = this.parseImportSpecifiers();
          this.expectContextual("from");
          node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();
        }
        this.parseMaybeImportAttributes(node);
        this.semicolon();
        this.finishNode(node, "ImportDeclaration");
        this.importOrExportOuterKind = "value";
        if (node.importKind === "type" && node.specifiers.length > 1 && node.specifiers[0].type === "ImportDefaultSpecifier") {
          this.raise(node.start, TypeScriptError.TypeImportCannotSpecifyDefaultAndNamed);
        }
        return node;
      }
      parseExportDefaultDeclaration() {
        if (this.isAbstractClass()) {
          const cls = this.startNode();
          this.next();
          cls.abstract = true;
          return this.parseClass(cls, true);
        }
        if (this.match(tokTypes2.interface)) {
          const result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result) return result;
        }
        return super.parseExportDefaultDeclaration();
      }
      parseExportAllDeclaration(node, exports) {
        if (this.ecmaVersion >= 11) {
          if (this.eatContextual("as")) {
            node.exported = this.parseModuleExportName();
            this.checkExport(exports, node.exported, this.lastTokStart);
          } else {
            node.exported = null;
          }
        }
        this.expectContextual("from");
        if (this.type !== tt.string) this.unexpected();
        node.source = this.parseExprAtom();
        this.parseMaybeImportAttributes(node);
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration");
      }
      parseDynamicImport(node) {
        this.next();
        node.source = this.parseMaybeAssign();
        if (this.eat(tt.comma)) {
          const expr = this.parseExpression();
          node.arguments = [expr];
        }
        if (!this.eat(tt.parenR)) {
          const errorPos = this.start;
          if (this.eat(tt.comma) && this.eat(tt.parenR)) {
            this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
          } else {
            this.unexpected(errorPos);
          }
        }
        return this.finishNode(node, "ImportExpression");
      }
      parseExport(node, exports) {
        let enterHead = this.lookahead();
        if (this.ts_eatWithState(tt._import, 2, enterHead)) {
          if (this.ts_isContextual(tokTypes2.type) && this.lookaheadCharCode() !== 61) {
            node.importKind = "type";
            this.importOrExportOuterKind = "type";
            this.next();
          } else {
            node.importKind = "value";
            this.importOrExportOuterKind = "value";
          }
          const exportEqualsNode = this.tsParseImportEqualsDeclaration(
            node,
            /* isExport */
            true
          );
          this.importOrExportOuterKind = void 0;
          return exportEqualsNode;
        } else if (this.ts_eatWithState(tt.eq, 2, enterHead)) {
          const assign = node;
          assign.expression = this.parseExpression();
          this.semicolon();
          this.importOrExportOuterKind = void 0;
          return this.finishNode(assign, "TSExportAssignment");
        } else if (this.ts_eatContextualWithState("as", 2, enterHead)) {
          const decl = node;
          this.expectContextual("namespace");
          decl.id = this.parseIdent();
          this.semicolon();
          this.importOrExportOuterKind = void 0;
          return this.finishNode(decl, "TSNamespaceExportDeclaration");
        } else {
          if (this.ts_isContextualWithState(enterHead, tokTypes2.type) && this.lookahead(2).type === tt.braceL) {
            this.next();
            this.importOrExportOuterKind = "type";
            node.exportKind = "type";
          } else {
            this.importOrExportOuterKind = "value";
            node.exportKind = "value";
          }
          this.next();
          if (this.eat(tt.star)) {
            return this.parseExportAllDeclaration(node, exports);
          }
          if (this.eat(tt._default)) {
            this.checkExport(exports, "default", this.lastTokStart);
            node.declaration = this.parseExportDefaultDeclaration();
            return this.finishNode(node, "ExportDefaultDeclaration");
          }
          if (this.shouldParseExportStatement()) {
            node.declaration = this.parseExportDeclaration(node);
            if (node.declaration.type === "VariableDeclaration")
              this.checkVariableExport(exports, node.declaration.declarations);
            else this.checkExport(exports, node.declaration.id, node.declaration.id.start);
            node.specifiers = [];
            node.source = null;
          } else {
            node.declaration = null;
            node.specifiers = this.parseExportSpecifiers(exports);
            if (this.eatContextual("from")) {
              if (this.type !== tt.string) this.unexpected();
              node.source = this.parseExprAtom();
              this.parseMaybeImportAttributes(node);
            } else {
              for (let spec of node.specifiers) {
                this.checkUnreserved(spec.local);
                this.checkLocalExport(spec.local);
                if (spec.local.type === "Literal") {
                  this.raise(
                    spec.local.start,
                    "A string literal cannot be used as an exported binding without `from`."
                  );
                }
              }
              node.source = null;
            }
            this.semicolon();
          }
          return this.finishNode(node, "ExportNamedDeclaration");
        }
      }
      checkExport(exports, name, _) {
        if (!exports) {
          return;
        }
        if (typeof name !== "string") {
          name = name.type === "Identifier" ? name.name : name.value;
        }
        exports[name] = true;
      }
      parseMaybeDefault(startPos, startLoc, left) {
        const node = super.parseMaybeDefault(startPos, startLoc, left);
        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(node.typeAnnotation.start, TypeScriptError.TypeAnnotationAfterAssign);
        }
        return node;
      }
      typeCastToParameter(node) {
        var _a2;
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(
          node.expression,
          node.typeAnnotation.end,
          (_a2 = node.typeAnnotation.loc) == null ? void 0 : _a2.end
        );
        return node.expression;
      }
      toAssignableList(exprList, isBinding) {
        for (let i = 0; i < exprList.length; i++) {
          const expr = exprList[i];
          if ((expr == null ? void 0 : expr.type) === "TSTypeCastExpression") {
            exprList[i] = this.typeCastToParameter(expr);
          }
        }
        return super.toAssignableList(exprList, isBinding);
      }
      reportReservedArrowTypeParam(node) {
        var _a2;
        if (node.params.length === 1 && !((_a2 = node.extra) == null ? void 0 : _a2.trailingComma) && disallowAmbiguousJSXLike) {
          this.raise(node.start, TypeScriptError.ReservedArrowTypeParam);
        }
      }
      parseExprAtom(refDestructuringErrors, forInit, forNew) {
        if (this.type === tokTypes2.jsxText) {
          return this.jsx_parseText();
        } else if (this.type === tokTypes2.jsxTagStart) {
          return this.jsx_parseElement();
        } else if (this.type === tokTypes2.at) {
          this.parseDecorators();
          return this.parseExprAtom();
        } else if (tokenIsIdentifier(this.type)) {
          let canBeArrow = this.potentialArrowAt === this.start;
          let startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
          let id2 = this.parseIdent(false);
          if (this.ecmaVersion >= 8 && !containsEsc && id2.name === "async" && !this.canInsertSemicolon() && this.eat(tt._function)) {
            this.overrideContext(tokContexts.f_expr);
            return this.parseFunction(
              this.startNodeAt(startPos, startLoc),
              0,
              false,
              true,
              forInit
            );
          }
          if (canBeArrow && !this.canInsertSemicolon()) {
            if (this.eat(tt.arrow))
              return this.parseArrowExpression(
                this.startNodeAt(startPos, startLoc),
                [id2],
                false,
                forInit
              );
            if (this.ecmaVersion >= 8 && id2.name === "async" && this.type === tt.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
              id2 = this.parseIdent(false);
              if (this.canInsertSemicolon() || !this.eat(tt.arrow)) this.unexpected();
              return this.parseArrowExpression(
                this.startNodeAt(startPos, startLoc),
                [id2],
                true,
                forInit
              );
            }
          }
          return id2;
        } else {
          return super.parseExprAtom(refDestructuringErrors, forInit, forNew);
        }
      }
      parseExprAtomDefault() {
        if (tokenIsIdentifier(this.type)) {
          const canBeArrow = this["potentialArrowAt"] === this.start;
          const containsEsc = this.containsEsc;
          const id2 = this.parseIdent();
          if (!containsEsc && id2.name === "async" && !this.canInsertSemicolon()) {
            const { type } = this;
            if (type === tt._function) {
              this.next();
              return this.parseFunction(this.startNodeAtNode(id2), void 0, true, true);
            } else if (tokenIsIdentifier(type)) {
              if (this.lookaheadCharCode() === 61) {
                const paramId = this.parseIdent(false);
                if (this.canInsertSemicolon() || !this.eat(tt.arrow)) this.unexpected();
                return this.parseArrowExpression(this.startNodeAtNode(id2), [paramId], true);
              } else {
                return id2;
              }
            }
          }
          if (canBeArrow && this.match(tt.arrow) && !this.canInsertSemicolon()) {
            this.next();
            return this.parseArrowExpression(this.startNodeAtNode(id2), [id2], false);
          }
          return id2;
        } else {
          this.unexpected();
        }
      }
      parseIdentNode() {
        let node = this.startNode();
        if (tokenIsKeywordOrIdentifier(this.type) && // Taken from super-class method
        !((this.type.keyword === "class" || this.type.keyword === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46))) {
          node.name = this.value;
        } else {
          return super.parseIdentNode();
        }
        return node;
      }
      parseVarStatement(node, kind, allowMissingInitializer = false) {
        const { isAmbientContext } = this;
        this.next();
        super.parseVar(node, false, kind, allowMissingInitializer || isAmbientContext);
        this.semicolon();
        const declaration2 = this.finishNode(node, "VariableDeclaration");
        if (!isAmbientContext) return declaration2;
        for (const { id: id2, init: init3 } of declaration2.declarations) {
          if (!init3) continue;
          if (kind !== "const" || !!id2.typeAnnotation) {
            this.raise(init3.start, TypeScriptError.InitializerNotAllowedInAmbientContext);
          } else if (init3.type !== "StringLiteral" && init3.type !== "BooleanLiteral" && init3.type !== "NumericLiteral" && init3.type !== "BigIntLiteral" && (init3.type !== "TemplateLiteral" || init3.expressions.length > 0) && !isPossiblyLiteralEnum(init3)) {
            this.raise(
              init3.start,
              TypeScriptError.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference
            );
          }
        }
        return declaration2;
      }
      parseStatement(context, topLevel, exports) {
        if (this.match(tokTypes2.at)) {
          this.parseDecorators(true);
        }
        if (this.match(tt._const) && this.isLookaheadContextual("enum")) {
          const node = this.startNode();
          this.expect(tt._const);
          return this.tsParseEnumDeclaration(node, { const: true });
        }
        if (this.ts_isContextual(tokTypes2.enum)) {
          return this.tsParseEnumDeclaration(this.startNode());
        }
        if (this.ts_isContextual(tokTypes2.interface)) {
          const result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result) return result;
        }
        return super.parseStatement(context, topLevel, exports);
      }
      // NOTE: unused function
      parseAccessModifier() {
        return this.tsParseModifier(["public", "protected", "private"]);
      }
      parsePostMemberNameModifiers(methodOrProp) {
        const optional = this.eat(tt.question);
        if (optional) methodOrProp.optional = true;
        if (methodOrProp.readonly && this.match(tt.parenL)) {
          this.raise(methodOrProp.start, TypeScriptError.ClassMethodHasReadonly);
        }
        if (methodOrProp.declare && this.match(tt.parenL)) {
          this.raise(methodOrProp.start, TypeScriptError.ClassMethodHasDeclare);
        }
      }
      // Note: The reason we do this in `parseExpressionStatement` and not `parseStatement`
      // is that e.g. `type()` is valid JS, so we must try parsing that first.
      // If it's really a type, we will parse `type` as the statement, and can correct it here
      // by parsing the rest.
      parseExpressionStatement(node, expr) {
        const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : void 0;
        return decl || super.parseExpressionStatement(node, expr);
      }
      shouldParseExportStatement() {
        if (this.tsIsDeclarationStart()) return true;
        if (this.match(tokTypes2.at)) {
          return true;
        }
        return super.shouldParseExportStatement();
      }
      parseConditional(expr, startPos, startLoc, forInit, refDestructuringErrors) {
        if (this.eat(tt.question)) {
          let node = this.startNodeAt(startPos, startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssign();
          this.expect(tt.colon);
          node.alternate = this.parseMaybeAssign(forInit);
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      }
      parseMaybeConditional(forInit, refDestructuringErrors) {
        let startPos = this.start, startLoc = this.startLoc;
        let expr = this.parseExprOps(forInit, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
        if (!this.maybeInArrowParameters || !this.match(tt.question)) {
          return this.parseConditional(expr, startPos, startLoc, forInit, refDestructuringErrors);
        }
        const result = this.tryParse(
          () => this.parseConditional(expr, startPos, startLoc, forInit, refDestructuringErrors)
        );
        if (!result.node) {
          if (result.error) {
            this.setOptionalParametersError(refDestructuringErrors, result.error);
          }
          return expr;
        }
        if (result.error) this.setLookaheadState(result.failState);
        return result.node;
      }
      parseParenItem(node) {
        const startPos = this.start;
        const startLoc = this.startLoc;
        node = super.parseParenItem(node);
        if (this.eat(tt.question)) {
          node.optional = true;
          this.resetEndLocation(node);
        }
        if (this.match(tt.colon)) {
          const typeCastNode = this.startNodeAt(startPos, startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TSTypeCastExpression");
        }
        return node;
      }
      parseExportDeclaration(node) {
        if (!this.isAmbientContext && this.ts_isContextual(tokTypes2.declare)) {
          return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
        }
        const startPos = this.start;
        const startLoc = this.startLoc;
        const isDeclare = this.eatContextual("declare");
        if (isDeclare && (this.ts_isContextual(tokTypes2.declare) || !this.shouldParseExportStatement())) {
          this.raise(this.start, TypeScriptError.ExpectedAmbientAfterExportDeclare);
        }
        const isIdentifier = tokenIsIdentifier(this.type);
        const declaration2 = isIdentifier && this.tsTryParseExportDeclaration() || this.parseStatement(null);
        if (!declaration2) return null;
        if (declaration2.type === "TSInterfaceDeclaration" || declaration2.type === "TSTypeAliasDeclaration" || isDeclare) {
          node.exportKind = "type";
        }
        if (isDeclare) {
          this.resetStartLocation(declaration2, startPos, startLoc);
          declaration2.declare = true;
        }
        return declaration2;
      }
      parseClassId(node, isStatement) {
        if (!isStatement && this.isContextual("implements")) {
          return;
        }
        super.parseClassId(node, isStatement);
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
        if (typeParameters) node.typeParameters = typeParameters;
      }
      parseClassPropertyAnnotation(node) {
        if (!node.optional) {
          if (this.value === "!" && this.eat(tt.prefix)) {
            node.definite = true;
          } else if (this.eat(tt.question)) {
            node.optional = true;
          }
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
      }
      parseClassField(field) {
        const isPrivate = field.key.type === "PrivateIdentifier";
        if (isPrivate) {
          if (field.abstract) {
            this.raise(field.start, TypeScriptError.PrivateElementHasAbstract);
          }
          if (field.accessibility) {
            this.raise(
              field.start,
              TypeScriptError.PrivateElementHasAccessibility({
                modifier: field.accessibility
              })
            );
          }
          this.parseClassPropertyAnnotation(field);
        } else {
          this.parseClassPropertyAnnotation(field);
          if (this.isAmbientContext && !(field.readonly && !field.typeAnnotation) && this.match(tt.eq)) {
            this.raise(this.start, TypeScriptError.DeclareClassFieldHasInitializer);
          }
          if (field.abstract && this.match(tt.eq)) {
            const { key: key2 } = field;
            this.raise(
              this.start,
              TypeScriptError.AbstractPropertyHasInitializer({
                propertyName: key2.type === "Identifier" && !field.computed ? key2.name : `[${this.input.slice(key2.start, key2.end)}]`
              })
            );
          }
        }
        return super.parseClassField(field);
      }
      parseClassMethod(method2, isGenerator, isAsync, allowsDirectSuper) {
        const isConstructor = method2.kind === "constructor";
        const isPrivate = method2.key.type === "PrivateIdentifier";
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (isPrivate) {
          if (typeParameters) method2.typeParameters = typeParameters;
          if (method2.accessibility) {
            this.raise(
              method2.start,
              TypeScriptError.PrivateMethodsHasAccessibility({
                modifier: method2.accessibility
              })
            );
          }
        } else {
          if (typeParameters && isConstructor) {
            this.raise(typeParameters.start, TypeScriptError.ConstructorHasTypeParameters);
          }
        }
        const { declare = false, kind } = method2;
        if (declare && (kind === "get" || kind === "set")) {
          this.raise(method2.start, TypeScriptError.DeclareAccessor({ kind }));
        }
        if (typeParameters) method2.typeParameters = typeParameters;
        const key2 = method2.key;
        if (method2.kind === "constructor") {
          if (isGenerator) this.raise(key2.start, "Constructor can't be a generator");
          if (isAsync) this.raise(key2.start, "Constructor can't be an async method");
        } else if (method2.static && checkKeyName2(method2, "prototype")) {
          this.raise(key2.start, "Classes may not have a static property named prototype");
        }
        const value = method2.value = this.parseMethod(
          isGenerator,
          isAsync,
          allowsDirectSuper,
          true,
          method2
        );
        if (method2.kind === "get" && value["params"].length !== 0)
          this.raiseRecoverable(value.start, "getter should have no params");
        if (method2.kind === "set" && value["params"].length !== 1)
          this.raiseRecoverable(value.start, "setter should have exactly one param");
        if (method2.kind === "set" && value["params"][0].type === "RestElement")
          this.raiseRecoverable(value["params"][0].start, "Setter cannot use rest params");
        return this.finishNode(method2, "MethodDefinition");
      }
      isClassMethod() {
        return this.match(tt.relational);
      }
      parseClassElement(constructorAllowsSuper) {
        if (this.eat(tt.semi)) return null;
        let node = this.startNode();
        let keyName = "";
        let isGenerator = false;
        let isAsync = false;
        let kind = "method";
        let isStatic = false;
        const modifiers2 = [
          "declare",
          "private",
          "public",
          "protected",
          "accessor",
          "override",
          "abstract",
          "readonly",
          "static"
        ];
        const modifierMap = this.tsParseModifiers({
          modified: node,
          allowedModifiers: modifiers2,
          disallowedModifiers: ["in", "out"],
          stopOnStartOfClassStaticBlock: true,
          errorTemplate: TypeScriptError.InvalidModifierOnTypeParameterPositions
        });
        isStatic = Boolean(modifierMap.static);
        const callParseClassMemberWithIsStatic = () => {
          if (this.tsIsStartOfStaticBlocks()) {
            this.next();
            this.next();
            if (this.tsHasSomeModifiers(node, modifiers2)) {
              this.raise(this.start, TypeScriptError.StaticBlockCannotHaveModifier);
            }
            if (this.ecmaVersion >= 13) {
              super.parseClassStaticBlock(node);
              return node;
            }
          } else {
            const idx = this.tsTryParseIndexSignature(node);
            if (idx) {
              if (node.abstract) {
                this.raise(node.start, TypeScriptError.IndexSignatureHasAbstract);
              }
              if (node.accessibility) {
                this.raise(
                  node.start,
                  TypeScriptError.IndexSignatureHasAccessibility({
                    modifier: node.accessibility
                  })
                );
              }
              if (node.declare) {
                this.raise(node.start, TypeScriptError.IndexSignatureHasDeclare);
              }
              if (node.override) {
                this.raise(node.start, TypeScriptError.IndexSignatureHasOverride);
              }
              return idx;
            }
            if (!this.inAbstractClass && node.abstract) {
              this.raise(node.start, TypeScriptError.NonAbstractClassHasAbstractMethod);
            }
            if (node.override) {
              if (!constructorAllowsSuper) {
                this.raise(node.start, TypeScriptError.OverrideNotInSubClass);
              }
            }
            node.static = isStatic;
            if (isStatic) {
              if (!(this.isClassElementNameStart() || this.type === tt.star)) {
                keyName = "static";
              }
            }
            if (!keyName && this.ecmaVersion >= 8 && this.eatContextual("async")) {
              if ((this.isClassElementNameStart() || this.type === tt.star) && !this.canInsertSemicolon()) {
                isAsync = true;
              } else {
                keyName = "async";
              }
            }
            if (!keyName && (this.ecmaVersion >= 9 || !isAsync) && this.eat(tt.star)) {
              isGenerator = true;
            }
            if (!keyName && !isAsync && !isGenerator) {
              const lastValue = this.value;
              if (this.eatContextual("get") || this.eatContextual("set")) {
                if (this.isClassElementNameStart()) {
                  kind = lastValue;
                } else {
                  keyName = lastValue;
                }
              }
            }
            if (keyName) {
              node.computed = false;
              node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
              node.key.name = keyName;
              this.finishNode(node.key, "Identifier");
            } else {
              this.parseClassElementName(node);
            }
            this.parsePostMemberNameModifiers(node);
            if (this.isClassMethod() || this.ecmaVersion < 13 || this.type === tt.parenL || kind !== "method" || isGenerator || isAsync) {
              const isConstructor = !node.static && checkKeyName2(node, "constructor");
              const allowsDirectSuper = isConstructor && constructorAllowsSuper;
              if (isConstructor && kind !== "method")
                this.raise(node.key.start, "Constructor can't have get/set modifier");
              node.kind = isConstructor ? "constructor" : kind;
              this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
            } else {
              this.parseClassField(node);
            }
            return node;
          }
        };
        if (node.declare) {
          this.tsInAmbientContext(callParseClassMemberWithIsStatic);
        } else {
          callParseClassMemberWithIsStatic();
        }
        return node;
      }
      isClassElementNameStart() {
        if (this.tsIsIdentifier()) {
          return true;
        }
        return super.isClassElementNameStart();
      }
      parseClassSuper(node) {
        super.parseClassSuper(node);
        if (node.superClass && (this.tsMatchLeftRelational() || this.match(tt.bitShift))) {
          node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
        }
        if (this.eatContextual("implements")) {
          node.implements = this.tsParseHeritageClause("implements");
        }
      }
      parseFunctionParams(node) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters) node.typeParameters = typeParameters;
        super.parseFunctionParams(node);
      }
      // `let x: number;`
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind);
        if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.value === "!" && this.eat(tt.prefix)) {
          decl.definite = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          decl.id.typeAnnotation = type;
          this.resetEndLocation(decl.id);
        }
      }
      // parse the return type of an async arrow function - let foo = (async (): number => {});
      parseArrowExpression(node, params, isAsync, forInit) {
        if (this.match(tt.colon)) {
          node.returnType = this.tsParseTypeAnnotation();
        }
        let oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.enterScope(functionFlags2(isAsync, false) | acornScope.SCOPE_ARROW);
        this.initFunction(node);
        const oldMaybeInArrowParameters = this.maybeInArrowParameters;
        if (this.ecmaVersion >= 8) node.async = !!isAsync;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.maybeInArrowParameters = true;
        node.params = this.toAssignableList(params, true);
        this.maybeInArrowParameters = false;
        this.parseFunctionBody(node, true, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        this.maybeInArrowParameters = oldMaybeInArrowParameters;
        return this.finishNode(node, "ArrowFunctionExpression");
      }
      parseMaybeAssignOrigin(forInit, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
          if (this.inGenerator) return this.parseYield(forInit);
          else this.exprAllowed = false;
        }
        let ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
        if (refDestructuringErrors) {
          oldParenAssign = refDestructuringErrors.parenthesizedAssign;
          oldTrailingComma = refDestructuringErrors.trailingComma;
          oldDoubleProto = refDestructuringErrors.doubleProto;
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
          refDestructuringErrors = new DestructuringErrors3();
          ownDestructuringErrors = true;
        }
        let startPos = this.start, startLoc = this.startLoc;
        if (this.type === tt.parenL || tokenIsIdentifier(this.type)) {
          this.potentialArrowAt = this.start;
          this.potentialArrowInForAwait = forInit === "await";
        }
        let left = this.parseMaybeConditional(forInit, refDestructuringErrors);
        if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
        if (this.type.isAssign) {
          let node = this.startNodeAt(startPos, startLoc);
          node.operator = this.value;
          if (this.type === tt.eq) left = this.toAssignable(left, true, refDestructuringErrors);
          if (!ownDestructuringErrors) {
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
          }
          if (refDestructuringErrors.shorthandAssign >= left.start)
            refDestructuringErrors.shorthandAssign = -1;
          if (!this.maybeInArrowParameters) {
            if (this.type === tt.eq) this.checkLValPattern(left);
            else this.checkLValSimple(left);
          }
          node.left = left;
          this.next();
          node.right = this.parseMaybeAssign(forInit);
          if (oldDoubleProto > -1) refDestructuringErrors.doubleProto = oldDoubleProto;
          return this.finishNode(node, "AssignmentExpression");
        } else {
          if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true);
        }
        if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign;
        if (oldTrailingComma > -1) refDestructuringErrors.trailingComma = oldTrailingComma;
        return left;
      }
      parseMaybeAssign(forInit, refExpressionErrors, afterLeftParse) {
        let state;
        let jsx;
        let typeCast;
        if ((options == null ? void 0 : options.jsx) && (this.matchJsx("jsxTagStart") || this.tsMatchLeftRelational())) {
          state = this.cloneCurLookaheadState();
          jsx = this.tryParse(
            () => this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse),
            state
          );
          if (!jsx.error) return jsx.node;
          const context = this.context;
          const currentContext = context[context.length - 1];
          const lastCurrentContext = context[context.length - 2];
          if (currentContext === acornTypeScript.tokContexts.tc_oTag && lastCurrentContext === acornTypeScript.tokContexts.tc_expr) {
            context.pop();
            context.pop();
          } else if (currentContext === acornTypeScript.tokContexts.tc_oTag || currentContext === acornTypeScript.tokContexts.tc_expr) {
            context.pop();
          }
        }
        if (!(jsx == null ? void 0 : jsx.error) && !this.tsMatchLeftRelational()) {
          return this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse);
        }
        if (!state || this.compareLookaheadState(state, this.getCurLookaheadState())) {
          state = this.cloneCurLookaheadState();
        }
        let typeParameters;
        const arrow2 = this.tryParse((abort) => {
          var _a2;
          typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
          const expr = this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse);
          if (expr.type !== "ArrowFunctionExpression" || ((_a2 = expr.extra) == null ? void 0 : _a2.parenthesized)) {
            abort();
          }
          if ((typeParameters == null ? void 0 : typeParameters.params.length) !== 0) {
            this.resetStartLocationFromNode(expr, typeParameters);
          }
          expr.typeParameters = typeParameters;
          return expr;
        }, state);
        if (!arrow2.error && !arrow2.aborted) {
          if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
          return arrow2.node;
        }
        if (!jsx) {
          assert(true);
          typeCast = this.tryParse(
            () => this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse),
            state
          );
          if (!typeCast.error) return typeCast.node;
        }
        if (jsx == null ? void 0 : jsx.node) {
          this.setLookaheadState(jsx.failState);
          return jsx.node;
        }
        if (arrow2.node) {
          this.setLookaheadState(arrow2.failState);
          if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
          return arrow2.node;
        }
        if (typeCast == null ? void 0 : typeCast.node) {
          this.setLookaheadState(typeCast.failState);
          return typeCast.node;
        }
        if (jsx == null ? void 0 : jsx.thrown) throw jsx.error;
        if (arrow2.thrown) throw arrow2.error;
        if (typeCast == null ? void 0 : typeCast.thrown) throw typeCast.error;
        throw (jsx == null ? void 0 : jsx.error) || arrow2.error || (typeCast == null ? void 0 : typeCast.error);
      }
      parseAssignableListItem(allowModifiers) {
        const decorators = [];
        while (this.match(tokTypes2.at)) {
          decorators.push(this.parseDecorator());
        }
        const startPos = this.start;
        const startLoc = this.startLoc;
        let accessibility;
        let readonly = false;
        let override = false;
        if (allowModifiers !== void 0) {
          const modified = {};
          this.tsParseModifiers({
            modified,
            allowedModifiers: ["public", "private", "protected", "override", "readonly"]
          });
          accessibility = modified.accessibility;
          override = modified.override;
          readonly = modified.readonly;
          if (allowModifiers === false && (accessibility || readonly || override)) {
            this.raise(startLoc.start, TypeScriptError.UnexpectedParameterModifier);
          }
        }
        const left = this.parseMaybeDefault(startPos, startLoc);
        this.parseBindingListItem(left);
        const elt = this.parseMaybeDefault(left["start"], left["loc"], left);
        if (decorators.length) {
          elt.decorators = decorators;
        }
        if (accessibility || readonly || override) {
          const pp2 = this.startNodeAt(startPos, startLoc);
          if (accessibility) pp2.accessibility = accessibility;
          if (readonly) pp2.readonly = readonly;
          if (override) pp2.override = override;
          if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
            this.raise(pp2.start, TypeScriptError.UnsupportedParameterPropertyKind);
          }
          pp2.parameter = elt;
          return this.finishNode(pp2, "TSParameterProperty");
        }
        return elt;
      }
      // AssignmentPattern
      checkLValInnerPattern(expr, bindingType = acornScope.BIND_NONE, checkClashes) {
        switch (expr.type) {
          case "TSParameterProperty":
            this.checkLValInnerPattern(expr.parameter, bindingType, checkClashes);
            break;
          default: {
            super.checkLValInnerPattern(expr, bindingType, checkClashes);
            break;
          }
        }
      }
      // Allow type annotations inside of a parameter list.
      parseBindingListItem(param) {
        if (this.eat(tt.question)) {
          if (param.type !== "Identifier" && !this.isAmbientContext && !this.inType) {
            this.raise(param.start, TypeScriptError.PatternIsOptional);
          }
          param.optional = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) param.typeAnnotation = type;
        this.resetEndLocation(param);
        return param;
      }
      isAssignable(node, isBinding) {
        switch (node.type) {
          case "TSTypeCastExpression":
            return this.isAssignable(node.expression, isBinding);
          case "TSParameterProperty":
            return true;
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            return true;
          case "ObjectExpression": {
            const last = node.properties.length - 1;
            return node.properties.every((prop2, i) => {
              return prop2.type !== "ObjectMethod" && (i === last || prop2.type !== "SpreadElement") && this.isAssignable(prop2);
            });
          }
          case "Property":
          case "ObjectProperty":
            return this.isAssignable(node.value);
          case "SpreadElement":
            return this.isAssignable(node.argument);
          case "ArrayExpression":
            return node.elements.every(
              (element2) => element2 === null || this.isAssignable(element2)
            );
          case "AssignmentExpression":
            return node.operator === "=";
          case "ParenthesizedExpression":
            return this.isAssignable(node.expression);
          case "MemberExpression":
          case "OptionalMemberExpression":
            return !isBinding;
          default:
            return false;
        }
      }
      toAssignable(node, isBinding = false, refDestructuringErrors = new DestructuringErrors3()) {
        switch (node.type) {
          case "ParenthesizedExpression":
            return this.toAssignableParenthesizedExpression(
              node,
              isBinding,
              refDestructuringErrors
            );
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
            if (isBinding) {
            } else {
              this.raise(node.start, TypeScriptError.UnexpectedTypeCastInParameter);
            }
            return this.toAssignable(node.expression, isBinding, refDestructuringErrors);
          case "MemberExpression":
            break;
          case "AssignmentExpression":
            if (!isBinding && node.left.type === "TSTypeCastExpression") {
              node.left = this.typeCastToParameter(node.left);
            }
            return super.toAssignable(node, isBinding, refDestructuringErrors);
          case "TSTypeCastExpression": {
            return this.typeCastToParameter(node);
          }
          default:
            return super.toAssignable(node, isBinding, refDestructuringErrors);
        }
        return node;
      }
      toAssignableParenthesizedExpression(node, isBinding, refDestructuringErrors) {
        switch (node.expression.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
          case "ParenthesizedExpression":
            return this.toAssignable(node.expression, isBinding, refDestructuringErrors);
          default:
            return super.toAssignable(node, isBinding, refDestructuringErrors);
        }
      }
      parseBindingAtom() {
        switch (this.type) {
          case tt._this:
            return this.parseIdent(
              /* liberal */
              true
            );
          default:
            return super.parseBindingAtom();
        }
      }
      shouldParseArrow(exprList) {
        let shouldParseArrowRes;
        if (this.match(tt.colon)) {
          shouldParseArrowRes = exprList.every((expr) => this.isAssignable(expr, true));
        } else {
          shouldParseArrowRes = !this.canInsertSemicolon();
        }
        if (shouldParseArrowRes) {
          if (this.match(tt.colon)) {
            const result = this.tryParse((abort) => {
              const returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);
              if (this.canInsertSemicolon() || !this.match(tt.arrow)) abort();
              return returnType;
            });
            if (result.aborted) {
              this.shouldParseArrowReturnType = void 0;
              return false;
            }
            if (!result.thrown) {
              if (result.error) this.setLookaheadState(result.failState);
              this.shouldParseArrowReturnType = result.node;
            }
          }
          if (!this.match(tt.arrow)) {
            this.shouldParseArrowReturnType = void 0;
            return false;
          }
          return true;
        }
        this.shouldParseArrowReturnType = void 0;
        return shouldParseArrowRes;
      }
      parseParenArrowList(startPos, startLoc, exprList, forInit) {
        const node = this.startNodeAt(startPos, startLoc);
        node.returnType = this.shouldParseArrowReturnType;
        this.shouldParseArrowReturnType = void 0;
        return this.parseArrowExpression(node, exprList, false, forInit);
      }
      parseParenAndDistinguishExpression(canBeArrow, forInit) {
        let startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.ecmaVersion >= 8;
        if (this.ecmaVersion >= 6) {
          const oldMaybeInArrowParameters = this.maybeInArrowParameters;
          this.maybeInArrowParameters = true;
          this.next();
          let innerStartPos = this.start, innerStartLoc = this.startLoc;
          let exprList = [], first = true, lastIsComma = false;
          let refDestructuringErrors = new DestructuringErrors3(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          this.yieldPos = 0;
          this.awaitPos = 0;
          while (this.type !== tt.parenR) {
            first ? first = false : this.expect(tt.comma);
            if (allowTrailingComma && this.afterTrailingComma(tt.parenR, true)) {
              lastIsComma = true;
              break;
            } else if (this.type === tt.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseParenItem(this.parseRestBinding()));
              if (this.type === tt.comma) {
                this.raise(this.start, "Comma is not permitted after the rest element");
              }
              break;
            } else {
              exprList.push(
                this.parseMaybeAssign(forInit, refDestructuringErrors, this.parseParenItem)
              );
            }
          }
          let innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
          this.expect(tt.parenR);
          this.maybeInArrowParameters = oldMaybeInArrowParameters;
          if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(tt.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
          }
          if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart);
          if (spreadStart) this.unexpected(spreadStart);
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }
        if (this.options.preserveParens) {
          let par = this.startNodeAt(startPos, startLoc);
          par.expression = val;
          return this.finishNode(par, "ParenthesizedExpression");
        } else {
          return val;
        }
      }
      parseTaggedTemplateExpression(base, startPos, startLoc, optionalChainMember) {
        const node = this.startNodeAt(startPos, startLoc);
        node.tag = base;
        node.quasi = this.parseTemplate({ isTagged: true });
        if (optionalChainMember) {
          this.raise(
            startPos,
            "Tagged Template Literals are not allowed in optionalChain."
          );
        }
        return this.finishNode(node, "TaggedTemplateExpression");
      }
      shouldParseAsyncArrow() {
        if (this.match(tt.colon)) {
          const result = this.tryParse((abort) => {
            const returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);
            if (this.canInsertSemicolon() || !this.match(tt.arrow)) abort();
            return returnType;
          });
          if (result.aborted) {
            this.shouldParseAsyncArrowReturnType = void 0;
            return false;
          }
          if (!result.thrown) {
            if (result.error) this.setLookaheadState(result.failState);
            this.shouldParseAsyncArrowReturnType = result.node;
            return !this.canInsertSemicolon() && this.eat(tt.arrow);
          }
        } else {
          return !this.canInsertSemicolon() && this.eat(tt.arrow);
        }
      }
      parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit) {
        const arrN = this.startNodeAt(startPos, startLoc);
        arrN.returnType = this.shouldParseAsyncArrowReturnType;
        this.shouldParseAsyncArrowReturnType = void 0;
        return this.parseArrowExpression(arrN, exprList, true, forInit);
      }
      parseExprList(close2, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        let elts = [], first = true;
        while (!this.eat(close2)) {
          if (!first) {
            this.expect(tt.comma);
            if (allowTrailingComma && this.afterTrailingComma(close2)) break;
          } else first = false;
          let elt;
          if (allowEmpty && this.type === tt.comma) elt = null;
          else if (this.type === tt.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (this.maybeInArrowParameters && this.match(tt.colon)) {
              elt.typeAnnotation = this.tsParseTypeAnnotation();
            }
            if (refDestructuringErrors && this.type === tt.comma && refDestructuringErrors.trailingComma < 0)
              refDestructuringErrors.trailingComma = this.start;
          } else {
            elt = this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem);
          }
          elts.push(elt);
        }
        return elts;
      }
      parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
        let _optionalChained = optionalChained;
        if (!this.hasPrecedingLineBreak() && // NODE: replace bang
        this.value === "!" && this.match(tt.prefix)) {
          this.exprAllowed = false;
          this.next();
          const nonNullExpression = this.startNodeAt(startPos, startLoc);
          nonNullExpression.expression = base;
          base = this.finishNode(nonNullExpression, "TSNonNullExpression");
          return base;
        }
        let isOptionalCall = false;
        if (this.match(tt.questionDot) && this.lookaheadCharCode() === 60) {
          if (noCalls) {
            return base;
          }
          base.optional = true;
          _optionalChained = isOptionalCall = true;
          this.next();
        }
        if (this.tsMatchLeftRelational() || this.match(tt.bitShift)) {
          let missingParenErrorLoc;
          const result = this.tsTryParseAndCatch(() => {
            if (!noCalls && this.atPossibleAsyncArrow(base)) {
              const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(
                startPos,
                startLoc,
                forInit
              );
              if (asyncArrowFn) {
                base = asyncArrowFn;
                return base;
              }
            }
            const typeArguments = this.tsParseTypeArgumentsInExpression();
            if (!typeArguments) return base;
            if (isOptionalCall && !this.match(tt.parenL)) {
              missingParenErrorLoc = this.curPosition();
              return base;
            }
            if (tokenIsTemplate(this.type) || this.type === tt.backQuote) {
              const result2 = this.parseTaggedTemplateExpression(
                base,
                startPos,
                startLoc,
                _optionalChained
              );
              result2.typeArguments = typeArguments;
              return result2;
            }
            if (!noCalls && this.eat(tt.parenL)) {
              let refDestructuringErrors = new DestructuringErrors3();
              const node2 = this.startNodeAt(startPos, startLoc);
              node2.callee = base;
              node2.arguments = this.parseExprList(
                tt.parenR,
                this.ecmaVersion >= 8,
                false,
                refDestructuringErrors
              );
              this.tsCheckForInvalidTypeCasts(node2.arguments);
              node2.typeArguments = typeArguments;
              if (_optionalChained) {
                node2.optional = isOptionalCall;
              }
              this.checkExpressionErrors(refDestructuringErrors, true);
              base = this.finishNode(node2, "CallExpression");
              return base;
            }
            const tokenType = this.type;
            if (
              // a<b>>c is not (a<b>)>c, but a<(b>>c)
              this.tsMatchRightRelational() || // a<b>>>c is not (a<b>)>>c, but a<(b>>>c)
              tokenType === tt.bitShift || // a<b>c is (a<b)>c
              tokenType !== tt.parenL && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()
            ) {
              return;
            }
            const node = this.startNodeAt(startPos, startLoc);
            node.expression = base;
            node.typeArguments = typeArguments;
            return this.finishNode(node, "TSInstantiationExpression");
          });
          if (missingParenErrorLoc) {
            this.unexpected(missingParenErrorLoc);
          }
          if (result) {
            if (result.type === "TSInstantiationExpression" && (this.match(tt.dot) || this.match(tt.questionDot) && this.lookaheadCharCode() !== 40)) {
              this.raise(
                this.start,
                TypeScriptError.InvalidPropertyAccessAfterInstantiationExpression
              );
            }
            base = result;
            return base;
          }
        }
        let optionalSupported = this.ecmaVersion >= 11;
        let optional = optionalSupported && this.eat(tt.questionDot);
        if (noCalls && optional)
          this.raise(
            this.lastTokStart,
            "Optional chaining cannot appear in the callee of new expressions"
          );
        let computed = this.eat(tt.bracketL);
        if (computed || optional && this.type !== tt.parenL && this.type !== tt.backQuote || this.eat(tt.dot)) {
          let node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          if (computed) {
            node.property = this.parseExpression();
            this.expect(tt.bracketR);
          } else if (this.type === tt.privateId && base.type !== "Super") {
            node.property = this.parsePrivateIdent();
          } else {
            node.property = this.parseIdent(this.options.allowReserved !== "never");
          }
          node.computed = !!computed;
          if (optionalSupported) {
            node.optional = optional;
          }
          base = this.finishNode(node, "MemberExpression");
        } else if (!noCalls && this.eat(tt.parenL)) {
          const oldMaybeInArrowParameters = this.maybeInArrowParameters;
          this.maybeInArrowParameters = true;
          let refDestructuringErrors = new DestructuringErrors3(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          let exprList = this.parseExprList(
            tt.parenR,
            this.ecmaVersion >= 8,
            false,
            refDestructuringErrors
          );
          if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            if (this.awaitIdentPos > 0)
              this.raise(
                this.awaitIdentPos,
                "Cannot use 'await' as identifier inside an async function"
              );
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            this.awaitIdentPos = oldAwaitIdentPos;
            base = this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
          } else {
            this.checkExpressionErrors(refDestructuringErrors, true);
            this.yieldPos = oldYieldPos || this.yieldPos;
            this.awaitPos = oldAwaitPos || this.awaitPos;
            this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
            let node = this.startNodeAt(startPos, startLoc);
            node.callee = base;
            node.arguments = exprList;
            if (optionalSupported) {
              node.optional = optional;
            }
            base = this.finishNode(node, "CallExpression");
          }
          this.maybeInArrowParameters = oldMaybeInArrowParameters;
        } else if (this.type === tt.backQuote) {
          if (optional || _optionalChained) {
            this.raise(
              this.start,
              "Optional chaining cannot appear in the tag of tagged template expressions"
            );
          }
          let node = this.startNodeAt(startPos, startLoc);
          node.tag = base;
          node.quasi = this.parseTemplate({ isTagged: true });
          base = this.finishNode(node, "TaggedTemplateExpression");
        }
        return base;
      }
      parseGetterSetter(prop2) {
        prop2.kind = prop2.key.name;
        this.parsePropertyName(prop2);
        prop2.value = this.parseMethod(false);
        let paramCount = prop2.kind === "get" ? 0 : 1;
        const firstParam = prop2.value.params[0];
        const hasContextParam = firstParam && this.isThisParam(firstParam);
        paramCount = hasContextParam ? paramCount + 1 : paramCount;
        if (prop2.value.params.length !== paramCount) {
          let start = prop2.value.start;
          if (prop2.kind === "get") this.raiseRecoverable(start, "getter should have no params");
          else this.raiseRecoverable(start, "setter should have exactly one param");
        } else {
          if (prop2.kind === "set" && prop2.value.params[0].type === "RestElement")
            this.raiseRecoverable(prop2.value.params[0].start, "Setter cannot use rest params");
        }
      }
      parseProperty(isPattern, refDestructuringErrors) {
        if (!isPattern) {
          let decorators = [];
          if (this.match(tokTypes2.at)) {
            while (this.match(tokTypes2.at)) {
              decorators.push(this.parseDecorator());
            }
          }
          const property = super.parseProperty(isPattern, refDestructuringErrors);
          if (property.type === "SpreadElement") {
            if (decorators.length)
              this.raise(property.start, DecoratorsError.SpreadElementDecorator);
          }
          if (decorators.length) {
            property.decorators = decorators;
            decorators = [];
          }
          return property;
        }
        return super.parseProperty(isPattern, refDestructuringErrors);
      }
      parseCatchClauseParam() {
        const param = this.parseBindingAtom();
        let simple = param.type === "Identifier";
        this.enterScope(simple ? acornScope.SCOPE_SIMPLE_CATCH : 0);
        this.checkLValPattern(
          param,
          simple ? acornScope.BIND_SIMPLE_CATCH : acornScope.BIND_LEXICAL
        );
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          param.typeAnnotation = type;
          this.resetEndLocation(param);
        }
        this.expect(tt.parenR);
        return param;
      }
      parseClass(node, isStatement) {
        const oldInAbstractClass = this.inAbstractClass;
        this.inAbstractClass = !!node.abstract;
        try {
          this.next();
          this.takeDecorators(node);
          const oldStrict = this.strict;
          this.strict = true;
          this.parseClassId(node, isStatement);
          this.parseClassSuper(node);
          const privateNameMap = this.enterClassBody();
          const classBody = this.startNode();
          let hadConstructor = false;
          classBody.body = [];
          let decorators = [];
          this.expect(tt.braceL);
          while (this.type !== tt.braceR) {
            if (this.match(tokTypes2.at)) {
              decorators.push(this.parseDecorator());
              continue;
            }
            const element2 = this.parseClassElement(node.superClass !== null);
            if (decorators.length) {
              element2.decorators = decorators;
              this.resetStartLocationFromNode(element2, decorators[0]);
              decorators = [];
            }
            if (element2) {
              classBody.body.push(element2);
              if (element2.type === "MethodDefinition" && element2.kind === "constructor" && element2.value.type === "FunctionExpression") {
                if (hadConstructor) {
                  this.raiseRecoverable(element2.start, "Duplicate constructor in the same class");
                }
                hadConstructor = true;
                if (element2.decorators && element2.decorators.length > 0) {
                  this.raise(element2.start, DecoratorsError.DecoratorConstructor);
                }
              } else if (element2.key && element2.key.type === "PrivateIdentifier" && isPrivateNameConflicted2(privateNameMap, element2)) {
                this.raiseRecoverable(
                  element2.key.start,
                  `Identifier '#${element2.key.name}' has already been declared`
                );
              }
            }
          }
          this.strict = oldStrict;
          this.next();
          if (decorators.length) {
            this.raise(this.start, DecoratorsError.TrailingDecorator);
          }
          node.body = this.finishNode(classBody, "ClassBody");
          this.exitClassBody();
          return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
        } finally {
          this.inAbstractClass = oldInAbstractClass;
        }
      }
      parseClassFunctionParams() {
        const typeParameters = this.tsTryParseTypeParameters();
        let params = this.parseBindingList(tt.parenR, false, this.ecmaVersion >= 8, true);
        if (typeParameters) params.typeParameters = typeParameters;
        return params;
      }
      parseMethod(isGenerator, isAsync, allowDirectSuper, inClassScope, method2) {
        let node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.initFunction(node);
        if (this.ecmaVersion >= 6) node.generator = isGenerator;
        if (this.ecmaVersion >= 8) node.async = !!isAsync;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(
          functionFlags2(isAsync, node.generator) | acornScope.SCOPE_SUPER | (allowDirectSuper ? acornScope.SCOPE_DIRECT_SUPER : 0)
        );
        this.expect(tt.parenL);
        node.params = this.parseClassFunctionParams();
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node, false, true, false, {
          isClassMethod: inClassScope
        });
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        if (method2 && method2.abstract) {
          const hasBody = !!node.body;
          if (hasBody) {
            const { key: key2 } = method2;
            this.raise(
              method2.start,
              TypeScriptError.AbstractMethodHasImplementation({
                methodName: key2.type === "Identifier" && !method2.computed ? key2.name : `[${this.input.slice(key2.start, key2.end)}]`
              })
            );
          }
        }
        return this.finishNode(node, "FunctionExpression");
      }
      static parse(input, options2) {
        if (options2.locations === false) {
          throw new Error(`You have to enable options.locations while using acorn-typescript`);
        } else {
          options2.locations = true;
        }
        const parser = new this(options2, input);
        if (dts) {
          parser.isAmbientContext = true;
        }
        return parser.parse();
      }
      static parseExpressionAt(input, pos, options2) {
        if (options2.locations === false) {
          throw new Error(`You have to enable options.locations while using acorn-typescript`);
        } else {
          options2.locations = true;
        }
        const parser = new this(options2, input, pos);
        if (dts) {
          parser.isAmbientContext = true;
        }
        parser.nextToken();
        return parser.parseExpression();
      }
      parseImportSpecifier() {
        const isMaybeTypeOnly = this.ts_isContextual(tokTypes2.type);
        if (isMaybeTypeOnly) {
          let node = this.startNode();
          node.imported = this.parseModuleExportName();
          this.parseTypeOnlyImportExportSpecifier(
            node,
            /* isImport */
            true,
            this.importOrExportOuterKind === "type"
          );
          return this.finishNode(node, "ImportSpecifier");
        } else {
          const node = super.parseImportSpecifier();
          node.importKind = "value";
          return node;
        }
      }
      parseExportSpecifier(exports) {
        const isMaybeTypeOnly = this.ts_isContextual(tokTypes2.type);
        const isString = this.match(tt.string);
        if (!isString && isMaybeTypeOnly) {
          let node = this.startNode();
          node.local = this.parseModuleExportName();
          this.parseTypeOnlyImportExportSpecifier(
            node,
            /* isImport */
            false,
            this.importOrExportOuterKind === "type"
          );
          this.finishNode(node, "ExportSpecifier");
          this.checkExport(exports, node.exported, node.exported.start);
          return node;
        } else {
          const node = super.parseExportSpecifier(exports);
          node.exportKind = "value";
          return node;
        }
      }
      parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
        const leftOfAsKey = isImport ? "imported" : "local";
        const rightOfAsKey = isImport ? "local" : "exported";
        let leftOfAs = node[leftOfAsKey];
        let rightOfAs;
        let hasTypeSpecifier = false;
        let canParseAsKeyword = true;
        const loc = leftOfAs.start;
        if (this.isContextual("as")) {
          const firstAs = this.parseIdent();
          if (this.isContextual("as")) {
            const secondAs = this.parseIdent();
            if (tokenIsKeywordOrIdentifier(this.type)) {
              hasTypeSpecifier = true;
              leftOfAs = firstAs;
              rightOfAs = isImport ? this.parseIdent() : this.parseModuleExportName();
              canParseAsKeyword = false;
            } else {
              rightOfAs = secondAs;
              canParseAsKeyword = false;
            }
          } else if (tokenIsKeywordOrIdentifier(this.type)) {
            canParseAsKeyword = false;
            rightOfAs = isImport ? this.parseIdent() : this.parseModuleExportName();
          } else {
            hasTypeSpecifier = true;
            leftOfAs = firstAs;
          }
        } else if (tokenIsKeywordOrIdentifier(this.type)) {
          hasTypeSpecifier = true;
          if (isImport) {
            leftOfAs = super.parseIdent(true);
            if (!this.isContextual("as")) {
              this.checkUnreserved(leftOfAs);
            }
          } else {
            leftOfAs = this.parseModuleExportName();
          }
        }
        if (hasTypeSpecifier && isInTypeOnlyImportExport) {
          this.raise(
            loc,
            isImport ? TypeScriptError.TypeModifierIsUsedInTypeImports : TypeScriptError.TypeModifierIsUsedInTypeExports
          );
        }
        node[leftOfAsKey] = leftOfAs;
        node[rightOfAsKey] = rightOfAs;
        const kindKey = isImport ? "importKind" : "exportKind";
        node[kindKey] = hasTypeSpecifier ? "type" : "value";
        if (canParseAsKeyword && this.eatContextual("as")) {
          node[rightOfAsKey] = isImport ? this.parseIdent() : this.parseModuleExportName();
        }
        if (!node[rightOfAsKey]) {
          node[rightOfAsKey] = this.copyNode(node[leftOfAsKey]);
        }
        if (isImport) {
          this.checkLValSimple(node[rightOfAsKey], acornScope.BIND_LEXICAL);
        }
      }
      raiseCommonCheck(pos, message, recoverable) {
        switch (message) {
          case "Comma is not permitted after the rest element": {
            if (this.isAmbientContext && this.match(tt.comma) && this.lookaheadCharCode() === 41) {
              this.next();
              return;
            } else {
              return super.raise(pos, message);
            }
          }
        }
        return recoverable ? super.raiseRecoverable(pos, message) : super.raise(pos, message);
      }
      raiseRecoverable(pos, message) {
        return this.raiseCommonCheck(pos, message, true);
      }
      raise(pos, message) {
        return this.raiseCommonCheck(pos, message, true);
      }
      updateContext(prevType) {
        const { type } = this;
        if (type == tt.braceL) {
          var curContext = this.curContext();
          if (curContext == tsTokContexts.tc_oTag) this.context.push(tokContexts.b_expr);
          else if (curContext == tsTokContexts.tc_expr) this.context.push(tokContexts.b_tmpl);
          else super.updateContext(prevType);
          this.exprAllowed = true;
        } else if (type === tt.slash && prevType === tokTypes2.jsxTagStart) {
          this.context.length -= 2;
          this.context.push(tsTokContexts.tc_cTag);
          this.exprAllowed = false;
        } else {
          return super.updateContext(prevType);
        }
      }
      // Parses JSX opening tag starting after '<'.
      jsx_parseOpeningElementAt(startPos, startLoc) {
        let node = this.startNodeAt(startPos, startLoc);
        let nodeName = this.jsx_parseElementName();
        if (nodeName) node.name = nodeName;
        if (this.match(tt.relational) || this.match(tt.bitShift)) {
          const typeArguments = this.tsTryParseAndCatch(
            () => this.tsParseTypeArgumentsInExpression()
          );
          if (typeArguments) node.typeArguments = typeArguments;
        }
        node.attributes = [];
        while (this.type !== tt.slash && this.type !== tokTypes2.jsxTagEnd)
          node.attributes.push(this.jsx_parseAttribute());
        node.selfClosing = this.eat(tt.slash);
        this.expect(tokTypes2.jsxTagEnd);
        return this.finishNode(node, nodeName ? "JSXOpeningElement" : "JSXOpeningFragment");
      }
      enterScope(flags) {
        if (flags === TS_SCOPE_TS_MODULE) {
          this.importsStack.push([]);
        }
        super.enterScope(flags);
        const scope = super.currentScope();
        scope.types = [];
        scope.enums = [];
        scope.constEnums = [];
        scope.classes = [];
        scope.exportOnlyBindings = [];
      }
      exitScope() {
        const scope = super.currentScope();
        if (scope.flags === TS_SCOPE_TS_MODULE) {
          this.importsStack.pop();
        }
        super.exitScope();
      }
      hasImport(name, allowShadow) {
        const len = this.importsStack.length;
        if (this.importsStack[len - 1].indexOf(name) > -1) {
          return true;
        }
        if (!allowShadow && len > 1) {
          for (let i = 0; i < len - 1; i++) {
            if (this.importsStack[i].indexOf(name) > -1) return true;
          }
        }
        return false;
      }
      maybeExportDefined(scope, name) {
        if (this.inModule && scope.flags & acornScope.SCOPE_TOP) {
          this.undefinedExports.delete(name);
        }
      }
      declareName(name, bindingType, pos) {
        if (bindingType & acornScope.BIND_FLAGS_TS_IMPORT) {
          if (this.hasImport(name, true)) {
            this.raise(pos, `Identifier '${name}' has already been declared.`);
          }
          this.importsStack[this.importsStack.length - 1].push(name);
          return;
        }
        const scope = this.currentScope();
        if (bindingType & acornScope.BIND_FLAGS_TS_EXPORT_ONLY) {
          this.maybeExportDefined(scope, name);
          scope.exportOnlyBindings.push(name);
          return;
        }
        if (bindingType === acornScope.BIND_TS_TYPE || bindingType === acornScope.BIND_TS_INTERFACE) {
          if (bindingType === acornScope.BIND_TS_TYPE && scope.types.includes(name)) {
            this.raise(pos, `type '${name}' has already been declared.`);
          }
          scope.types.push(name);
        } else {
          super.declareName(name, bindingType, pos);
        }
        if (bindingType & acornScope.BIND_FLAGS_TS_ENUM) scope.enums.push(name);
        if (bindingType & acornScope.BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.push(name);
        if (bindingType & acornScope.BIND_FLAGS_CLASS) scope.classes.push(name);
      }
      checkLocalExport(id2) {
        const { name } = id2;
        if (this.hasImport(name)) return;
        const len = this.scopeStack.length;
        for (let i = len - 1; i >= 0; i--) {
          const scope = this.scopeStack[i];
          if (scope.types.indexOf(name) > -1 || scope.exportOnlyBindings.indexOf(name) > -1) return;
        }
        super.checkLocalExport(id2);
      }
    }
    return TypeScriptParser;
  };
}

// node_modules/svelte/src/compiler/phases/1-parse/acorn.js
var ParserWithTS = Parser.extend(tsPlugin());
function parse4(source2, typescript, is_script) {
  const parser = typescript ? ParserWithTS : Parser;
  const { onComment, add_comments } = get_comment_handlers(source2);
  const parse_statement = parser.prototype.parseStatement;
  if (is_script) {
    parser.prototype.parseStatement = function(...args) {
      const v = parse_statement.call(this, ...args);
      this.undefinedExports = {};
      return v;
    };
  }
  let ast;
  try {
    ast = parser.parse(source2, {
      onComment,
      sourceType: "module",
      ecmaVersion: 13,
      locations: true
    });
  } finally {
    if (is_script) {
      parser.prototype.parseStatement = parse_statement;
    }
  }
  add_comments(ast);
  return (
    /** @type {Program} */
    ast
  );
}
function parse_expression_at(source2, typescript, index) {
  const parser = typescript ? ParserWithTS : Parser;
  const { onComment, add_comments } = get_comment_handlers(source2);
  const ast = parser.parseExpressionAt(source2, index, {
    onComment,
    sourceType: "module",
    ecmaVersion: 13,
    locations: true
  });
  add_comments(ast);
  return ast;
}
function get_comment_handlers(source2) {
  const comments = [];
  return {
    /**
     * @param {boolean} block
     * @param {string} value
     * @param {number} start
     * @param {number} end
     */
    onComment: (block2, value, start, end) => {
      if (block2 && /\n/.test(value)) {
        let a = start;
        while (a > 0 && source2[a - 1] !== "\n") a -= 1;
        let b = a;
        while (/[ \t]/.test(source2[b])) b += 1;
        const indentation = source2.slice(a, b);
        value = value.replace(new RegExp(`^${indentation}`, "gm"), "");
      }
      comments.push({ type: block2 ? "Block" : "Line", value, start, end });
    },
    /** @param {acorn.Node & { leadingComments?: CommentWithLocation[]; trailingComments?: CommentWithLocation[]; }} ast */
    add_comments(ast) {
      if (comments.length === 0) return;
      walk(ast, null, {
        _(node, { next: next2, path: path11 }) {
          let comment;
          while (comments[0] && comments[0].start < node.start) {
            comment = /** @type {CommentWithLocation} */
            comments.shift();
            (node.leadingComments || (node.leadingComments = [])).push(comment);
          }
          next2();
          if (comments[0]) {
            const parent = (
              /** @type {any} */
              path11.at(-1)
            );
            if (parent === void 0 || node.end !== parent.end) {
              const slice = source2.slice(node.end, comments[0].start);
              const is_last_in_body = ((parent == null ? void 0 : parent.type) === "BlockStatement" || (parent == null ? void 0 : parent.type) === "Program") && parent.body.indexOf(node) === parent.body.length - 1 || (parent == null ? void 0 : parent.type) === "ArrayExpression" && parent.elements.indexOf(node) === parent.elements.length - 1 || (parent == null ? void 0 : parent.type) === "ObjectExpression" && parent.properties.indexOf(node) === parent.properties.length - 1;
              if (is_last_in_body) {
                let end = node.end;
                while (comments.length) {
                  const comment2 = comments[0];
                  if (parent && comment2.start >= parent.end) break;
                  (node.trailingComments || (node.trailingComments = [])).push(comment2);
                  comments.shift();
                  end = comment2.end;
                }
              } else if (node.end <= comments[0].start && /^[,) \t]*$/.test(slice)) {
                node.trailingComments = [
                  /** @type {CommentWithLocation} */
                  comments.shift()
                ];
              }
            }
          }
        }
      });
      if (comments.length > 0 && (comments[0].start >= ast.end || ast.type === "Program")) {
        (ast.trailingComments || (ast.trailingComments = [])).push(...comments.splice(0));
      }
    }
  };
}

// node_modules/svelte/src/compiler/errors.js
var _diagnostic;
var InternalCompileError = class extends Error {
  /**
   * @param {string} code
   * @param {string} message
   * @param {[number, number] | undefined} position
   */
  constructor(code, message, position) {
    super(message);
    __publicField(this, "message", "");
    // ensure this property is enumerable
    __privateAdd(this, _diagnostic);
    this.stack = "";
    __privateSet(this, _diagnostic, new CompileDiagnostic(code, message, position));
    Object.assign(this, __privateGet(this, _diagnostic));
    this.name = "CompileError";
  }
  toString() {
    return __privateGet(this, _diagnostic).toString();
  }
  toJSON() {
    return __privateGet(this, _diagnostic).toJSON();
  }
};
_diagnostic = new WeakMap();
function e(node, code, message) {
  const start = typeof node === "number" ? node : node == null ? void 0 : node.start;
  const end = typeof node === "number" ? node : node == null ? void 0 : node.end;
  throw new InternalCompileError(code, message, start !== void 0 ? [start, end ?? start] : void 0);
}
function options_invalid_value(node, details) {
  e(node, "options_invalid_value", `Invalid compiler option: ${details}
https://svelte.dev/e/options_invalid_value`);
}
function options_removed(node, details) {
  e(node, "options_removed", `Invalid compiler option: ${details}
https://svelte.dev/e/options_removed`);
}
function options_unrecognised(node, keypath) {
  e(node, "options_unrecognised", `Unrecognised compiler option ${keypath}
https://svelte.dev/e/options_unrecognised`);
}
function bindable_invalid_location(node) {
  e(node, "bindable_invalid_location", `\`$bindable()\` can only be used inside a \`$props()\` declaration
https://svelte.dev/e/bindable_invalid_location`);
}
function constant_assignment(node, thing) {
  e(node, "constant_assignment", `Cannot assign to ${thing}
https://svelte.dev/e/constant_assignment`);
}
function constant_binding(node, thing) {
  e(node, "constant_binding", `Cannot bind to ${thing}
https://svelte.dev/e/constant_binding`);
}
function declaration_duplicate(node, name) {
  e(node, "declaration_duplicate", `\`${name}\` has already been declared
https://svelte.dev/e/declaration_duplicate`);
}
function declaration_duplicate_module_import(node) {
  e(node, "declaration_duplicate_module_import", `Cannot declare a variable with the same name as an import inside \`<script module>\`
https://svelte.dev/e/declaration_duplicate_module_import`);
}
function derived_invalid_export(node) {
  e(node, "derived_invalid_export", `Cannot export derived state from a module. To expose the current derived value, export a function returning its value
https://svelte.dev/e/derived_invalid_export`);
}
function dollar_binding_invalid(node) {
  e(node, "dollar_binding_invalid", `The $ name is reserved, and cannot be used for variables and imports
https://svelte.dev/e/dollar_binding_invalid`);
}
function dollar_prefix_invalid(node) {
  e(node, "dollar_prefix_invalid", `The $ prefix is reserved, and cannot be used for variables and imports
https://svelte.dev/e/dollar_prefix_invalid`);
}
function each_item_invalid_assignment(node) {
  e(node, "each_item_invalid_assignment", `Cannot reassign or bind to each block argument in runes mode. Use the array and index variables instead (e.g. \`array[i] = value\` instead of \`entry = value\`, or \`bind:value={array[i]}\` instead of \`bind:value={entry}\`)
https://svelte.dev/e/each_item_invalid_assignment`);
}
function effect_invalid_placement(node) {
  e(node, "effect_invalid_placement", `\`$effect()\` can only be used as an expression statement
https://svelte.dev/e/effect_invalid_placement`);
}
function export_undefined(node, name) {
  e(node, "export_undefined", `\`${name}\` is not defined
https://svelte.dev/e/export_undefined`);
}
function global_reference_invalid(node, name) {
  e(node, "global_reference_invalid", `\`${name}\` is an illegal variable name. To reference a global variable called \`${name}\`, use \`globalThis.${name}\`
https://svelte.dev/e/global_reference_invalid`);
}
function host_invalid_placement(node) {
  e(node, "host_invalid_placement", `\`$host()\` can only be used inside custom element component instances
https://svelte.dev/e/host_invalid_placement`);
}
function import_svelte_internal_forbidden(node) {
  e(node, "import_svelte_internal_forbidden", `Imports of \`svelte/internal/*\` are forbidden. It contains private runtime code which is subject to change without notice. If you're importing from \`svelte/internal/*\` to work around a limitation of Svelte, please open an issue at https://github.com/sveltejs/svelte and explain your use case
https://svelte.dev/e/import_svelte_internal_forbidden`);
}
function inspect_trace_generator(node) {
  e(node, "inspect_trace_generator", `\`$inspect.trace(...)\` cannot be used inside a generator function
https://svelte.dev/e/inspect_trace_generator`);
}
function inspect_trace_invalid_placement(node) {
  e(node, "inspect_trace_invalid_placement", `\`$inspect.trace(...)\` must be the first statement of a function body
https://svelte.dev/e/inspect_trace_invalid_placement`);
}
function invalid_arguments_usage(node) {
  e(node, "invalid_arguments_usage", `The arguments keyword cannot be used within the template or at the top level of a component
https://svelte.dev/e/invalid_arguments_usage`);
}
function legacy_export_invalid(node) {
  e(node, "legacy_export_invalid", `Cannot use \`export let\` in runes mode — use \`$props()\` instead
https://svelte.dev/e/legacy_export_invalid`);
}
function legacy_props_invalid(node) {
  e(node, "legacy_props_invalid", `Cannot use \`$$props\` in runes mode
https://svelte.dev/e/legacy_props_invalid`);
}
function legacy_reactive_statement_invalid(node) {
  e(node, "legacy_reactive_statement_invalid", `\`$:\` is not allowed in runes mode, use \`$derived\` or \`$effect\` instead
https://svelte.dev/e/legacy_reactive_statement_invalid`);
}
function legacy_rest_props_invalid(node) {
  e(node, "legacy_rest_props_invalid", `Cannot use \`$$restProps\` in runes mode
https://svelte.dev/e/legacy_rest_props_invalid`);
}
function module_illegal_default_export(node) {
  e(node, "module_illegal_default_export", `A component cannot have a default export
https://svelte.dev/e/module_illegal_default_export`);
}
function props_duplicate(node, rune) {
  e(node, "props_duplicate", `Cannot use \`${rune}()\` more than once
https://svelte.dev/e/props_duplicate`);
}
function props_id_invalid_placement(node) {
  e(node, "props_id_invalid_placement", `\`$props.id()\` can only be used at the top level of components as a variable declaration initializer
https://svelte.dev/e/props_id_invalid_placement`);
}
function props_illegal_name(node) {
  e(node, "props_illegal_name", `Declaring or accessing a prop starting with \`$$\` is illegal (they are reserved for Svelte internals)
https://svelte.dev/e/props_illegal_name`);
}
function props_invalid_identifier(node) {
  e(node, "props_invalid_identifier", `\`$props()\` can only be used with an object destructuring pattern
https://svelte.dev/e/props_invalid_identifier`);
}
function props_invalid_pattern(node) {
  e(node, "props_invalid_pattern", `\`$props()\` assignment must not contain nested properties or computed keys
https://svelte.dev/e/props_invalid_pattern`);
}
function props_invalid_placement(node) {
  e(node, "props_invalid_placement", `\`$props()\` can only be used at the top level of components as a variable declaration initializer
https://svelte.dev/e/props_invalid_placement`);
}
function reactive_declaration_cycle(node, cycle) {
  e(node, "reactive_declaration_cycle", `Cyclical dependency detected: ${cycle}
https://svelte.dev/e/reactive_declaration_cycle`);
}
function rune_invalid_arguments(node, rune) {
  e(node, "rune_invalid_arguments", `\`${rune}\` cannot be called with arguments
https://svelte.dev/e/rune_invalid_arguments`);
}
function rune_invalid_arguments_length(node, rune, args) {
  e(node, "rune_invalid_arguments_length", `\`${rune}\` must be called with ${args}
https://svelte.dev/e/rune_invalid_arguments_length`);
}
function rune_invalid_computed_property(node) {
  e(node, "rune_invalid_computed_property", `Cannot access a computed property of a rune
https://svelte.dev/e/rune_invalid_computed_property`);
}
function rune_invalid_name(node, name) {
  e(node, "rune_invalid_name", `\`${name}\` is not a valid rune
https://svelte.dev/e/rune_invalid_name`);
}
function rune_invalid_spread(node, rune) {
  e(node, "rune_invalid_spread", `\`${rune}\` cannot be called with a spread argument
https://svelte.dev/e/rune_invalid_spread`);
}
function rune_invalid_usage(node, rune) {
  e(node, "rune_invalid_usage", `Cannot use \`${rune}\` rune in non-runes mode
https://svelte.dev/e/rune_invalid_usage`);
}
function rune_missing_parentheses(node) {
  e(node, "rune_missing_parentheses", `Cannot use rune without parentheses
https://svelte.dev/e/rune_missing_parentheses`);
}
function rune_removed(node, name) {
  e(node, "rune_removed", `The \`${name}\` rune has been removed
https://svelte.dev/e/rune_removed`);
}
function rune_renamed(node, name, replacement) {
  e(node, "rune_renamed", `\`${name}\` is now \`${replacement}\`
https://svelte.dev/e/rune_renamed`);
}
function runes_mode_invalid_import(node, name) {
  e(node, "runes_mode_invalid_import", `${name} cannot be used in runes mode
https://svelte.dev/e/runes_mode_invalid_import`);
}
function snippet_invalid_export(node) {
  e(node, "snippet_invalid_export", `An exported snippet can only reference things declared in a \`<script module>\`, or other exportable snippets
https://svelte.dev/e/snippet_invalid_export`);
}
function snippet_parameter_assignment(node) {
  e(node, "snippet_parameter_assignment", `Cannot reassign or bind to snippet parameter
https://svelte.dev/e/snippet_parameter_assignment`);
}
function state_field_duplicate(node, name) {
  e(node, "state_field_duplicate", `\`${name}\` has already been declared on this class
https://svelte.dev/e/state_field_duplicate`);
}
function state_field_invalid_assignment(node) {
  e(node, "state_field_invalid_assignment", `Cannot assign to a state field before its declaration
https://svelte.dev/e/state_field_invalid_assignment`);
}
function state_invalid_export(node) {
  e(node, "state_invalid_export", `Cannot export state from a module if it is reassigned. Either export a function returning the state value or only mutate the state value's properties
https://svelte.dev/e/state_invalid_export`);
}
function state_invalid_placement(node, rune) {
  e(node, "state_invalid_placement", `\`${rune}(...)\` can only be used as a variable declaration initializer, a class field declaration, or the first assignment to a class field at the top level of the constructor.
https://svelte.dev/e/state_invalid_placement`);
}
function store_invalid_scoped_subscription(node) {
  e(node, "store_invalid_scoped_subscription", `Cannot subscribe to stores that are not declared at the top level of the component
https://svelte.dev/e/store_invalid_scoped_subscription`);
}
function store_invalid_subscription(node) {
  e(node, "store_invalid_subscription", `Cannot reference store value inside \`<script module>\`
https://svelte.dev/e/store_invalid_subscription`);
}
function store_invalid_subscription_module(node) {
  e(node, "store_invalid_subscription_module", `Cannot reference store value outside a \`.svelte\` file
https://svelte.dev/e/store_invalid_subscription_module`);
}
function typescript_invalid_feature(node, feature) {
  e(node, "typescript_invalid_feature", `TypeScript language features like ${feature} are not natively supported, and their use is generally discouraged. Outside of \`<script>\` tags, these features are not supported. For use within \`<script>\` tags, you will need to use a preprocessor to convert it to JavaScript before it gets passed to the Svelte compiler. If you are using \`vitePreprocess\`, make sure to specifically enable preprocessing script tags (\`vitePreprocess({ script: true })\`)
https://svelte.dev/e/typescript_invalid_feature`);
}
function css_empty_declaration(node) {
  e(node, "css_empty_declaration", `Declaration cannot be empty
https://svelte.dev/e/css_empty_declaration`);
}
function css_expected_identifier(node) {
  e(node, "css_expected_identifier", `Expected a valid CSS identifier
https://svelte.dev/e/css_expected_identifier`);
}
function css_global_block_invalid_combinator(node, name) {
  e(node, "css_global_block_invalid_combinator", `A \`:global\` selector cannot follow a \`${name}\` combinator
https://svelte.dev/e/css_global_block_invalid_combinator`);
}
function css_global_block_invalid_declaration(node) {
  e(node, "css_global_block_invalid_declaration", `A top-level \`:global {...}\` block can only contain rules, not declarations
https://svelte.dev/e/css_global_block_invalid_declaration`);
}
function css_global_block_invalid_list(node) {
  e(node, "css_global_block_invalid_list", `A \`:global\` selector cannot be part of a selector list with entries that don't contain \`:global\`
https://svelte.dev/e/css_global_block_invalid_list`);
}
function css_global_block_invalid_modifier(node) {
  e(node, "css_global_block_invalid_modifier", `A \`:global\` selector cannot modify an existing selector
https://svelte.dev/e/css_global_block_invalid_modifier`);
}
function css_global_block_invalid_modifier_start(node) {
  e(node, "css_global_block_invalid_modifier_start", `A \`:global\` selector can only be modified if it is a descendant of other selectors
https://svelte.dev/e/css_global_block_invalid_modifier_start`);
}
function css_global_block_invalid_placement(node) {
  e(node, "css_global_block_invalid_placement", `A \`:global\` selector cannot be inside a pseudoclass
https://svelte.dev/e/css_global_block_invalid_placement`);
}
function css_global_invalid_placement(node) {
  e(node, "css_global_invalid_placement", `\`:global(...)\` can be at the start or end of a selector sequence, but not in the middle
https://svelte.dev/e/css_global_invalid_placement`);
}
function css_global_invalid_selector(node) {
  e(node, "css_global_invalid_selector", `\`:global(...)\` must contain exactly one selector
https://svelte.dev/e/css_global_invalid_selector`);
}
function css_global_invalid_selector_list(node) {
  e(node, "css_global_invalid_selector_list", `\`:global(...)\` must not contain type or universal selectors when used in a compound selector
https://svelte.dev/e/css_global_invalid_selector_list`);
}
function css_nesting_selector_invalid_placement(node) {
  e(node, "css_nesting_selector_invalid_placement", `Nesting selectors can only be used inside a rule or as the first selector inside a lone \`:global(...)\`
https://svelte.dev/e/css_nesting_selector_invalid_placement`);
}
function css_selector_invalid(node) {
  e(node, "css_selector_invalid", `Invalid selector
https://svelte.dev/e/css_selector_invalid`);
}
function css_type_selector_invalid_placement(node) {
  e(node, "css_type_selector_invalid_placement", `\`:global(...)\` must not be followed by a type selector
https://svelte.dev/e/css_type_selector_invalid_placement`);
}
function animation_duplicate(node) {
  e(node, "animation_duplicate", `An element can only have one 'animate' directive
https://svelte.dev/e/animation_duplicate`);
}
function animation_invalid_placement(node) {
  e(node, "animation_invalid_placement", `An element that uses the \`animate:\` directive must be the only child of a keyed \`{#each ...}\` block
https://svelte.dev/e/animation_invalid_placement`);
}
function animation_missing_key(node) {
  e(node, "animation_missing_key", `An element that uses the \`animate:\` directive must be the only child of a keyed \`{#each ...}\` block. Did you forget to add a key to your each block?
https://svelte.dev/e/animation_missing_key`);
}
function attribute_contenteditable_dynamic(node) {
  e(node, "attribute_contenteditable_dynamic", `'contenteditable' attribute cannot be dynamic if element uses two-way binding
https://svelte.dev/e/attribute_contenteditable_dynamic`);
}
function attribute_contenteditable_missing(node) {
  e(node, "attribute_contenteditable_missing", `'contenteditable' attribute is required for textContent, innerHTML and innerText two-way bindings
https://svelte.dev/e/attribute_contenteditable_missing`);
}
function attribute_duplicate(node) {
  e(node, "attribute_duplicate", `Attributes need to be unique
https://svelte.dev/e/attribute_duplicate`);
}
function attribute_empty_shorthand(node) {
  e(node, "attribute_empty_shorthand", `Attribute shorthand cannot be empty
https://svelte.dev/e/attribute_empty_shorthand`);
}
function attribute_invalid_event_handler(node) {
  e(node, "attribute_invalid_event_handler", `Event attribute must be a JavaScript expression, not a string
https://svelte.dev/e/attribute_invalid_event_handler`);
}
function attribute_invalid_multiple(node) {
  e(node, "attribute_invalid_multiple", `'multiple' attribute must be static if select uses two-way binding
https://svelte.dev/e/attribute_invalid_multiple`);
}
function attribute_invalid_name(node, name) {
  e(node, "attribute_invalid_name", `'${name}' is not a valid attribute name
https://svelte.dev/e/attribute_invalid_name`);
}
function attribute_invalid_sequence_expression(node) {
  e(node, "attribute_invalid_sequence_expression", `Sequence expressions are not allowed as attribute/directive values in runes mode, unless wrapped in parentheses
https://svelte.dev/e/attribute_invalid_sequence_expression`);
}
function attribute_invalid_type(node) {
  e(node, "attribute_invalid_type", `'type' attribute must be a static text value if input uses two-way binding
https://svelte.dev/e/attribute_invalid_type`);
}
function attribute_unquoted_sequence(node) {
  e(node, "attribute_unquoted_sequence", `Attribute values containing \`{...}\` must be enclosed in quote marks, unless the value only contains the expression
https://svelte.dev/e/attribute_unquoted_sequence`);
}
function bind_group_invalid_expression(node) {
  e(node, "bind_group_invalid_expression", `\`bind:group\` can only bind to an Identifier or MemberExpression
https://svelte.dev/e/bind_group_invalid_expression`);
}
function bind_group_invalid_snippet_parameter(node) {
  e(node, "bind_group_invalid_snippet_parameter", `Cannot \`bind:group\` to a snippet parameter
https://svelte.dev/e/bind_group_invalid_snippet_parameter`);
}
function bind_invalid_expression(node) {
  e(node, "bind_invalid_expression", `Can only bind to an Identifier or MemberExpression or a \`{get, set}\` pair
https://svelte.dev/e/bind_invalid_expression`);
}
function bind_invalid_name(node, name, explanation) {
  e(node, "bind_invalid_name", `${explanation ? `\`bind:${name}\` is not a valid binding. ${explanation}` : `\`bind:${name}\` is not a valid binding`}
https://svelte.dev/e/bind_invalid_name`);
}
function bind_invalid_parens(node, name) {
  e(node, "bind_invalid_parens", `\`bind:${name}={get, set}\` must not have surrounding parentheses
https://svelte.dev/e/bind_invalid_parens`);
}
function bind_invalid_target(node, name, elements) {
  e(node, "bind_invalid_target", `\`bind:${name}\` can only be used with ${elements}
https://svelte.dev/e/bind_invalid_target`);
}
function bind_invalid_value(node) {
  e(node, "bind_invalid_value", `Can only bind to state or props
https://svelte.dev/e/bind_invalid_value`);
}
function block_duplicate_clause(node, name) {
  e(node, "block_duplicate_clause", `${name} cannot appear more than once within a block
https://svelte.dev/e/block_duplicate_clause`);
}
function block_invalid_continuation_placement(node) {
  e(node, "block_invalid_continuation_placement", `{:...} block is invalid at this position (did you forget to close the preceding element or block?)
https://svelte.dev/e/block_invalid_continuation_placement`);
}
function block_invalid_elseif(node) {
  e(node, "block_invalid_elseif", `'elseif' should be 'else if'
https://svelte.dev/e/block_invalid_elseif`);
}
function block_invalid_placement(node, name, location) {
  e(node, "block_invalid_placement", `{#${name} ...} block cannot be ${location}
https://svelte.dev/e/block_invalid_placement`);
}
function block_unclosed(node) {
  e(node, "block_unclosed", `Block was left open
https://svelte.dev/e/block_unclosed`);
}
function block_unexpected_character(node, character) {
  e(node, "block_unexpected_character", `Expected a \`${character}\` character immediately following the opening bracket
https://svelte.dev/e/block_unexpected_character`);
}
function block_unexpected_close(node) {
  e(node, "block_unexpected_close", `Unexpected block closing tag
https://svelte.dev/e/block_unexpected_close`);
}
function component_invalid_directive(node) {
  e(node, "component_invalid_directive", `This type of directive is not valid on components
https://svelte.dev/e/component_invalid_directive`);
}
function const_tag_cycle(node, cycle) {
  e(node, "const_tag_cycle", `Cyclical dependency detected: ${cycle}
https://svelte.dev/e/const_tag_cycle`);
}
function const_tag_invalid_expression(node) {
  e(node, "const_tag_invalid_expression", `{@const ...} must consist of a single variable declaration
https://svelte.dev/e/const_tag_invalid_expression`);
}
function const_tag_invalid_placement(node) {
  e(node, "const_tag_invalid_placement", `\`{@const}\` must be the immediate child of \`{#snippet}\`, \`{#if}\`, \`{:else if}\`, \`{:else}\`, \`{#each}\`, \`{:then}\`, \`{:catch}\`, \`<svelte:fragment>\`, \`<svelte:boundary\` or \`<Component>\`
https://svelte.dev/e/const_tag_invalid_placement`);
}
function debug_tag_invalid_arguments(node) {
  e(node, "debug_tag_invalid_arguments", `{@debug ...} arguments must be identifiers, not arbitrary expressions
https://svelte.dev/e/debug_tag_invalid_arguments`);
}
function directive_invalid_value(node) {
  e(node, "directive_invalid_value", `Directive value must be a JavaScript expression enclosed in curly braces
https://svelte.dev/e/directive_invalid_value`);
}
function directive_missing_name(node, type) {
  e(node, "directive_missing_name", `\`${type}\` name cannot be empty
https://svelte.dev/e/directive_missing_name`);
}
function element_invalid_closing_tag(node, name) {
  e(node, "element_invalid_closing_tag", `\`</${name}>\` attempted to close an element that was not open
https://svelte.dev/e/element_invalid_closing_tag`);
}
function element_invalid_closing_tag_autoclosed(node, name, reason) {
  e(node, "element_invalid_closing_tag_autoclosed", `\`</${name}>\` attempted to close element that was already automatically closed by \`<${reason}>\` (cannot nest \`<${reason}>\` inside \`<${name}>\`)
https://svelte.dev/e/element_invalid_closing_tag_autoclosed`);
}
function element_unclosed(node, name) {
  e(node, "element_unclosed", `\`<${name}>\` was left open
https://svelte.dev/e/element_unclosed`);
}
function event_handler_invalid_component_modifier(node) {
  e(node, "event_handler_invalid_component_modifier", `Event modifiers other than 'once' can only be used on DOM elements
https://svelte.dev/e/event_handler_invalid_component_modifier`);
}
function event_handler_invalid_modifier(node, list3) {
  e(node, "event_handler_invalid_modifier", `Valid event modifiers are ${list3}
https://svelte.dev/e/event_handler_invalid_modifier`);
}
function event_handler_invalid_modifier_combination(node, modifier1, modifier2) {
  e(node, "event_handler_invalid_modifier_combination", `The '${modifier1}' and '${modifier2}' modifiers cannot be used together
https://svelte.dev/e/event_handler_invalid_modifier_combination`);
}
function expected_attribute_value(node) {
  e(node, "expected_attribute_value", `Expected attribute value
https://svelte.dev/e/expected_attribute_value`);
}
function expected_block_type(node) {
  e(node, "expected_block_type", `Expected 'if', 'each', 'await', 'key' or 'snippet'
https://svelte.dev/e/expected_block_type`);
}
function expected_identifier(node) {
  e(node, "expected_identifier", `Expected an identifier
https://svelte.dev/e/expected_identifier`);
}
function expected_pattern(node) {
  e(node, "expected_pattern", `Expected identifier or destructure pattern
https://svelte.dev/e/expected_pattern`);
}
function expected_token(node, token) {
  e(node, "expected_token", `Expected token ${token}
https://svelte.dev/e/expected_token`);
}
function expected_whitespace(node) {
  e(node, "expected_whitespace", `Expected whitespace
https://svelte.dev/e/expected_whitespace`);
}
function illegal_element_attribute(node, name) {
  e(node, "illegal_element_attribute", `\`<${name}>\` does not support non-event attributes or spread attributes
https://svelte.dev/e/illegal_element_attribute`);
}
function js_parse_error(node, message) {
  e(node, "js_parse_error", `${message}
https://svelte.dev/e/js_parse_error`);
}
function let_directive_invalid_placement(node) {
  e(node, "let_directive_invalid_placement", `\`let:\` directive at invalid position
https://svelte.dev/e/let_directive_invalid_placement`);
}
function mixed_event_handler_syntaxes(node, name) {
  e(node, "mixed_event_handler_syntaxes", `Mixing old (on:${name}) and new syntaxes for event handling is not allowed. Use only the on${name} syntax
https://svelte.dev/e/mixed_event_handler_syntaxes`);
}
function node_invalid_placement(node, message) {
  e(node, "node_invalid_placement", `${message}. The browser will 'repair' the HTML (by moving, removing, or inserting elements) which breaks Svelte's assumptions about the structure of your components.
https://svelte.dev/e/node_invalid_placement`);
}
function render_tag_invalid_call_expression(node) {
  e(node, "render_tag_invalid_call_expression", `Calling a snippet function using apply, bind or call is not allowed
https://svelte.dev/e/render_tag_invalid_call_expression`);
}
function render_tag_invalid_expression(node) {
  e(node, "render_tag_invalid_expression", `\`{@render ...}\` tags can only contain call expressions
https://svelte.dev/e/render_tag_invalid_expression`);
}
function render_tag_invalid_spread_argument(node) {
  e(node, "render_tag_invalid_spread_argument", `cannot use spread arguments in \`{@render ...}\` tags
https://svelte.dev/e/render_tag_invalid_spread_argument`);
}
function script_duplicate(node) {
  e(node, "script_duplicate", `A component can have a single top-level \`<script>\` element and/or a single top-level \`<script module>\` element
https://svelte.dev/e/script_duplicate`);
}
function script_invalid_attribute_value(node, name) {
  e(node, "script_invalid_attribute_value", `If the \`${name}\` attribute is supplied, it must be a boolean attribute
https://svelte.dev/e/script_invalid_attribute_value`);
}
function script_invalid_context(node) {
  e(node, "script_invalid_context", `If the context attribute is supplied, its value must be "module"
https://svelte.dev/e/script_invalid_context`);
}
function script_reserved_attribute(node, name) {
  e(node, "script_reserved_attribute", `The \`${name}\` attribute is reserved and cannot be used
https://svelte.dev/e/script_reserved_attribute`);
}
function slot_attribute_duplicate(node, name, component) {
  e(node, "slot_attribute_duplicate", `Duplicate slot name '${name}' in <${component}>
https://svelte.dev/e/slot_attribute_duplicate`);
}
function slot_attribute_invalid(node) {
  e(node, "slot_attribute_invalid", `slot attribute must be a static value
https://svelte.dev/e/slot_attribute_invalid`);
}
function slot_attribute_invalid_placement(node) {
  e(node, "slot_attribute_invalid_placement", `Element with a slot='...' attribute must be a child of a component or a descendant of a custom element
https://svelte.dev/e/slot_attribute_invalid_placement`);
}
function slot_default_duplicate(node) {
  e(node, "slot_default_duplicate", `Found default slot content alongside an explicit slot="default"
https://svelte.dev/e/slot_default_duplicate`);
}
function slot_element_invalid_attribute(node) {
  e(node, "slot_element_invalid_attribute", `\`<slot>\` can only receive attributes and (optionally) let directives
https://svelte.dev/e/slot_element_invalid_attribute`);
}
function slot_element_invalid_name(node) {
  e(node, "slot_element_invalid_name", `slot attribute must be a static value
https://svelte.dev/e/slot_element_invalid_name`);
}
function slot_element_invalid_name_default(node) {
  e(node, "slot_element_invalid_name_default", `\`default\` is a reserved word — it cannot be used as a slot name
https://svelte.dev/e/slot_element_invalid_name_default`);
}
function slot_snippet_conflict(node) {
  e(node, "slot_snippet_conflict", `Cannot use \`<slot>\` syntax and \`{@render ...}\` tags in the same component. Migrate towards \`{@render ...}\` tags completely
https://svelte.dev/e/slot_snippet_conflict`);
}
function snippet_conflict(node) {
  e(node, "snippet_conflict", `Cannot use explicit children snippet at the same time as implicit children content. Remove either the non-whitespace content or the children snippet block
https://svelte.dev/e/snippet_conflict`);
}
function snippet_invalid_rest_parameter(node) {
  e(node, "snippet_invalid_rest_parameter", `Snippets do not support rest parameters; use an array instead
https://svelte.dev/e/snippet_invalid_rest_parameter`);
}
function snippet_shadowing_prop(node, prop2) {
  e(node, "snippet_shadowing_prop", `This snippet is shadowing the prop \`${prop2}\` with the same name
https://svelte.dev/e/snippet_shadowing_prop`);
}
function style_directive_invalid_modifier(node) {
  e(node, "style_directive_invalid_modifier", `\`style:\` directive can only use the \`important\` modifier
https://svelte.dev/e/style_directive_invalid_modifier`);
}
function style_duplicate(node) {
  e(node, "style_duplicate", `A component can have a single top-level \`<style>\` element
https://svelte.dev/e/style_duplicate`);
}
function svelte_body_illegal_attribute(node) {
  e(node, "svelte_body_illegal_attribute", `\`<svelte:body>\` does not support non-event attributes or spread attributes
https://svelte.dev/e/svelte_body_illegal_attribute`);
}
function svelte_boundary_invalid_attribute(node) {
  e(node, "svelte_boundary_invalid_attribute", `Valid attributes on \`<svelte:boundary>\` are \`onerror\` and \`failed\`
https://svelte.dev/e/svelte_boundary_invalid_attribute`);
}
function svelte_boundary_invalid_attribute_value(node) {
  e(node, "svelte_boundary_invalid_attribute_value", `Attribute value must be a non-string expression
https://svelte.dev/e/svelte_boundary_invalid_attribute_value`);
}
function svelte_component_invalid_this(node) {
  e(node, "svelte_component_invalid_this", `Invalid component definition — must be an \`{expression}\`
https://svelte.dev/e/svelte_component_invalid_this`);
}
function svelte_component_missing_this(node) {
  e(node, "svelte_component_missing_this", `\`<svelte:component>\` must have a 'this' attribute
https://svelte.dev/e/svelte_component_missing_this`);
}
function svelte_element_missing_this(node) {
  e(node, "svelte_element_missing_this", `\`<svelte:element>\` must have a 'this' attribute with a value
https://svelte.dev/e/svelte_element_missing_this`);
}
function svelte_fragment_invalid_attribute(node) {
  e(node, "svelte_fragment_invalid_attribute", `\`<svelte:fragment>\` can only have a slot attribute and (optionally) a let: directive
https://svelte.dev/e/svelte_fragment_invalid_attribute`);
}
function svelte_fragment_invalid_placement(node) {
  e(node, "svelte_fragment_invalid_placement", `\`<svelte:fragment>\` must be the direct child of a component
https://svelte.dev/e/svelte_fragment_invalid_placement`);
}
function svelte_head_illegal_attribute(node) {
  e(node, "svelte_head_illegal_attribute", `\`<svelte:head>\` cannot have attributes nor directives
https://svelte.dev/e/svelte_head_illegal_attribute`);
}
function svelte_meta_duplicate(node, name) {
  e(node, "svelte_meta_duplicate", `A component can only have one \`<${name}>\` element
https://svelte.dev/e/svelte_meta_duplicate`);
}
function svelte_meta_invalid_content(node, name) {
  e(node, "svelte_meta_invalid_content", `<${name}> cannot have children
https://svelte.dev/e/svelte_meta_invalid_content`);
}
function svelte_meta_invalid_placement(node, name) {
  e(node, "svelte_meta_invalid_placement", `\`<${name}>\` tags cannot be inside elements or blocks
https://svelte.dev/e/svelte_meta_invalid_placement`);
}
function svelte_meta_invalid_tag(node, list3) {
  e(node, "svelte_meta_invalid_tag", `Valid \`<svelte:...>\` tag names are ${list3}
https://svelte.dev/e/svelte_meta_invalid_tag`);
}
function svelte_options_deprecated_tag(node) {
  e(node, "svelte_options_deprecated_tag", `"tag" option is deprecated — use "customElement" instead
https://svelte.dev/e/svelte_options_deprecated_tag`);
}
function svelte_options_invalid_attribute(node) {
  e(node, "svelte_options_invalid_attribute", `\`<svelte:options>\` can only receive static attributes
https://svelte.dev/e/svelte_options_invalid_attribute`);
}
function svelte_options_invalid_attribute_value(node, list3) {
  e(node, "svelte_options_invalid_attribute_value", `Value must be ${list3}, if specified
https://svelte.dev/e/svelte_options_invalid_attribute_value`);
}
function svelte_options_invalid_customelement(node) {
  e(node, "svelte_options_invalid_customelement", `"customElement" must be a string literal defining a valid custom element name or an object of the form { tag?: string; shadow?: "open" | "none"; props?: { [key: string]: { attribute?: string; reflect?: boolean; type: .. } } }
https://svelte.dev/e/svelte_options_invalid_customelement`);
}
function svelte_options_invalid_customelement_props(node) {
  e(node, "svelte_options_invalid_customelement_props", `"props" must be a statically analyzable object literal of the form "{ [key: string]: { attribute?: string; reflect?: boolean; type?: "String" | "Boolean" | "Number" | "Array" | "Object" }"
https://svelte.dev/e/svelte_options_invalid_customelement_props`);
}
function svelte_options_invalid_customelement_shadow(node) {
  e(node, "svelte_options_invalid_customelement_shadow", `"shadow" must be either "open" or "none"
https://svelte.dev/e/svelte_options_invalid_customelement_shadow`);
}
function svelte_options_invalid_tagname(node) {
  e(node, "svelte_options_invalid_tagname", `Tag name must be lowercase and hyphenated
https://svelte.dev/e/svelte_options_invalid_tagname`);
}
function svelte_options_reserved_tagname(node) {
  e(node, "svelte_options_reserved_tagname", `Tag name is reserved
https://svelte.dev/e/svelte_options_reserved_tagname`);
}
function svelte_options_unknown_attribute(node, name) {
  e(node, "svelte_options_unknown_attribute", `\`<svelte:options>\` unknown attribute '${name}'
https://svelte.dev/e/svelte_options_unknown_attribute`);
}
function svelte_self_invalid_placement(node) {
  e(node, "svelte_self_invalid_placement", `\`<svelte:self>\` components can only exist inside \`{#if}\` blocks, \`{#each}\` blocks, \`{#snippet}\` blocks or slots passed to components
https://svelte.dev/e/svelte_self_invalid_placement`);
}
function tag_invalid_name(node) {
  e(node, "tag_invalid_name", `Expected a valid element or component name. Components must have a valid variable name or dot notation expression
https://svelte.dev/e/tag_invalid_name`);
}
function tag_invalid_placement(node, name, location) {
  e(node, "tag_invalid_placement", `{@${name} ...} tag cannot be ${location}
https://svelte.dev/e/tag_invalid_placement`);
}
function textarea_invalid_content(node) {
  e(node, "textarea_invalid_content", `A \`<textarea>\` can have either a value attribute or (equivalently) child content, but not both
https://svelte.dev/e/textarea_invalid_content`);
}
function title_illegal_attribute(node) {
  e(node, "title_illegal_attribute", `\`<title>\` cannot have attributes nor directives
https://svelte.dev/e/title_illegal_attribute`);
}
function title_invalid_content(node) {
  e(node, "title_invalid_content", `\`<title>\` can only contain text and {tags}
https://svelte.dev/e/title_invalid_content`);
}
function transition_conflict(node, type, existing) {
  e(node, "transition_conflict", `Cannot use \`${type}:\` alongside existing \`${existing}:\` directive
https://svelte.dev/e/transition_conflict`);
}
function transition_duplicate(node, type) {
  e(node, "transition_duplicate", `Cannot use multiple \`${type}:\` directives on a single element
https://svelte.dev/e/transition_duplicate`);
}
function unexpected_eof(node) {
  e(node, "unexpected_eof", `Unexpected end of input
https://svelte.dev/e/unexpected_eof`);
}
function unexpected_reserved_word(node, word) {
  e(node, "unexpected_reserved_word", `'${word}' is a reserved word in JavaScript and cannot be used here
https://svelte.dev/e/unexpected_reserved_word`);
}
function unterminated_string_constant(node) {
  e(node, "unterminated_string_constant", `Unterminated string constant
https://svelte.dev/e/unterminated_string_constant`);
}
function void_element_invalid_content(node) {
  e(node, "void_element_invalid_content", `Void elements cannot have children or closing tags
https://svelte.dev/e/void_element_invalid_content`);
}

// node_modules/svelte/src/compiler/phases/1-parse/utils/bracket.js
function infinity_if_negative(num) {
  if (num < 0) {
    return Infinity;
  }
  return num;
}
function find_string_end(string2, search_start_index, string_start_char) {
  let string_to_search;
  if (string_start_char === "`") {
    string_to_search = string2;
  } else {
    string_to_search = string2.slice(
      0,
      infinity_if_negative(string2.indexOf("\n", search_start_index))
    );
  }
  return find_unescaped_char(string_to_search, search_start_index, string_start_char);
}
function find_regex_end(string2, search_start_index) {
  return find_unescaped_char(string2, search_start_index, "/");
}
function find_unescaped_char(string2, search_start_index, char) {
  let i = search_start_index;
  while (true) {
    const found_index = string2.indexOf(char, i);
    if (found_index === -1) {
      return Infinity;
    }
    if (count_leading_backslashes(string2, found_index - 1) % 2 === 0) {
      return found_index;
    }
    i = found_index + 1;
  }
}
function count_leading_backslashes(string2, search_start_index) {
  let i = search_start_index;
  let count = 0;
  while (string2[i] === "\\") {
    count++;
    i--;
  }
  return count;
}
function find_matching_bracket(template2, index, open2) {
  const close2 = default_brackets[open2];
  let brackets = 1;
  let i = index;
  while (brackets > 0 && i < template2.length) {
    const char = template2[i];
    switch (char) {
      case "'":
      case '"':
      case "`":
        i = find_string_end(template2, i + 1, char) + 1;
        continue;
      case "/": {
        const next_char = template2[i + 1];
        if (!next_char) continue;
        if (next_char === "/") {
          i = infinity_if_negative(template2.indexOf("\n", i + 1)) + "\n".length;
          continue;
        }
        if (next_char === "*") {
          i = infinity_if_negative(template2.indexOf("*/", i + 1)) + "*/".length;
          continue;
        }
        i = find_regex_end(template2, i + 1) + "/".length;
        continue;
      }
      default: {
        const char2 = template2[i];
        if (char2 === open2) {
          brackets++;
        } else if (char2 === close2) {
          brackets--;
        }
        if (brackets === 0) {
          return i;
        }
        i++;
      }
    }
  }
  return void 0;
}
var default_brackets = {
  "{": "}",
  "(": ")",
  "[": "]"
};
function match_bracket(parser, start, brackets = default_brackets) {
  const close2 = Object.values(brackets);
  const bracket_stack = [];
  let i = start;
  while (i < parser.template.length) {
    let char = parser.template[i++];
    if (char === "'" || char === '"' || char === "`") {
      i = match_quote(parser, i, char);
      continue;
    }
    if (char in brackets) {
      bracket_stack.push(char);
    } else if (close2.includes(char)) {
      const popped = (
        /** @type {string} */
        bracket_stack.pop()
      );
      const expected = (
        /** @type {string} */
        brackets[popped]
      );
      if (char !== expected) {
        expected_token(i - 1, expected);
      }
      if (bracket_stack.length === 0) {
        return i;
      }
    }
  }
  unexpected_eof(parser.template.length);
}
function match_quote(parser, start, quote2) {
  let is_escaped = false;
  let i = start;
  while (i < parser.template.length) {
    const char = parser.template[i++];
    if (is_escaped) {
      is_escaped = false;
      continue;
    }
    if (char === quote2) {
      return i;
    }
    if (char === "\\") {
      is_escaped = true;
    }
    if (quote2 === "`" && char === "$" && parser.template[i] === "{") {
      i = match_bracket(parser, i);
    }
  }
  unterminated_string_constant(start);
}

// node_modules/svelte/src/compiler/phases/1-parse/read/expression.js
function get_loose_identifier(parser, opening_token) {
  const end = find_matching_bracket(parser.template, parser.index, opening_token ?? "{");
  if (end) {
    const start = parser.index;
    parser.index = end;
    return {
      type: "Identifier",
      start,
      end,
      name: ""
    };
  }
}
function read_expression(parser, opening_token, disallow_loose) {
  try {
    const node = parse_expression_at(parser.template, parser.ts, parser.index);
    let num_parens = 0;
    if (node.leadingComments !== void 0 && node.leadingComments.length > 0) {
      parser.index = node.leadingComments.at(-1).end;
    }
    for (let i = parser.index; i < /** @type {number} */
    node.start; i += 1) {
      if (parser.template[i] === "(") num_parens += 1;
    }
    let index = (
      /** @type {number} */
      node.end
    );
    if (node.trailingComments !== void 0 && node.trailingComments.length > 0) {
      index = node.trailingComments.at(-1).end;
    }
    while (num_parens > 0) {
      const char = parser.template[index];
      if (char === ")") {
        num_parens -= 1;
      } else if (!regex_whitespace.test(char)) {
        expected_token(index, ")");
      }
      index += 1;
    }
    parser.index = index;
    return (
      /** @type {Expression} */
      node
    );
  } catch (err) {
    if (parser.loose && !disallow_loose) {
      const expression = get_loose_identifier(parser, opening_token);
      if (expression) {
        return expression;
      }
    }
    parser.acorn_error(err);
  }
}

// node_modules/svelte/src/compiler/utils/sanitize_template_string.js
function sanitize_template_string(str) {
  return str.replace(/(`|\${|\\)/g, "\\$1");
}

// node_modules/svelte/src/compiler/utils/builders.js
function array(elements = []) {
  return { type: "ArrayExpression", elements };
}
function array_pattern(elements) {
  return { type: "ArrayPattern", elements };
}
function assignment_pattern(left, right) {
  return { type: "AssignmentPattern", left, right };
}
function arrow(params, body) {
  return {
    type: "ArrowFunctionExpression",
    params,
    body,
    expression: body.type !== "BlockStatement",
    generator: false,
    async: false,
    metadata: (
      /** @type {any} */
      null
    )
    // should not be used by codegen
  };
}
function assignment(operator, left, right) {
  return { type: "AssignmentExpression", operator, left, right };
}
function async(func) {
  return { ...func, async: true };
}
function await_builder(argument) {
  return { type: "AwaitExpression", argument };
}
function binary(operator, left, right) {
  return { type: "BinaryExpression", operator, left, right };
}
function block(body) {
  return { type: "BlockStatement", body };
}
function labeled(name, body) {
  return { type: "LabeledStatement", label: id(name), body };
}
function call(callee, ...args) {
  if (typeof callee === "string") callee = id(callee);
  args = args.slice();
  let i = args.length;
  let popping = true;
  while (i--) {
    if (!args[i]) {
      if (popping) {
        args.pop();
      } else {
        args[i] = id("undefined");
      }
    } else {
      popping = false;
    }
  }
  return {
    type: "CallExpression",
    callee,
    arguments: (
      /** @type {Array<ESTree.Expression | ESTree.SpreadElement>} */
      args
    ),
    optional: false
  };
}
function maybe_call(callee, ...args) {
  const expression = (
    /** @type {ESTree.SimpleCallExpression} */
    call(callee, ...args)
  );
  expression.optional = true;
  return {
    type: "ChainExpression",
    expression
  };
}
function unary(operator, argument) {
  return { type: "UnaryExpression", argument, operator, prefix: true };
}
var void0 = unary("void", literal2(0));
function logical(operator, left, right) {
  return { type: "LogicalExpression", operator, left, right };
}
function declaration(kind, declarations) {
  return {
    type: "VariableDeclaration",
    kind,
    declarations
  };
}
function declarator(pattern, init3) {
  if (typeof pattern === "string") pattern = id(pattern);
  return { type: "VariableDeclarator", id: pattern, init: init3 };
}
var empty2 = {
  type: "EmptyStatement"
};
function export_default(declaration2) {
  return { type: "ExportDefaultDeclaration", declaration: declaration2 };
}
function function_declaration(id2, params, body) {
  return {
    type: "FunctionDeclaration",
    id: id2,
    params,
    body,
    generator: false,
    async: false,
    metadata: (
      /** @type {any} */
      null
    )
    // should not be used by codegen
  };
}
function get(name, body) {
  return prop("get", key(name), function_builder(null, [], block(body)));
}
function id(name) {
  return { type: "Identifier", name };
}
function private_id(name) {
  return { type: "PrivateIdentifier", name };
}
function import_namespace(local) {
  return {
    type: "ImportNamespaceSpecifier",
    local: id(local)
  };
}
function init2(name, value) {
  return prop("init", key(name), value);
}
function literal2(value) {
  return { type: "Literal", value };
}
function member(object4, property, computed = false, optional = false) {
  if (typeof property === "string") {
    property = id(property);
  }
  return { type: "MemberExpression", object: object4, property, computed, optional };
}
function member_id(path11) {
  const parts = path11.split(".");
  let expression = id(parts[0]);
  for (let i = 1; i < parts.length; i += 1) {
    expression = member(expression, id(parts[i]));
  }
  return expression;
}
function object(properties) {
  return { type: "ObjectExpression", properties };
}
function object_pattern(properties) {
  return { type: "ObjectPattern", properties };
}
function prop(kind, key2, value, computed = false) {
  return { type: "Property", kind, key: key2, value, method: false, shorthand: false, computed };
}
function prop_def(key2, value, computed = false, is_static = false) {
  return { type: "PropertyDefinition", key: key2, value, computed, static: is_static };
}
function quasi(cooked, tail = false) {
  const raw = sanitize_template_string(cooked);
  return { type: "TemplateElement", value: { raw, cooked }, tail };
}
function rest(argument) {
  return { type: "RestElement", argument };
}
function sequence(expressions) {
  return { type: "SequenceExpression", expressions };
}
function set(name, body) {
  return prop("set", key(name), function_builder(null, [id("$$value")], block(body)));
}
function spread(argument) {
  return { type: "SpreadElement", argument };
}
function stmt(expression) {
  return { type: "ExpressionStatement", expression };
}
function template(elements, expressions) {
  return { type: "TemplateLiteral", quasis: elements, expressions };
}
function thunk(expression, async2 = false) {
  const fn = arrow([], expression);
  if (async2) fn.async = true;
  return unthunk(fn);
}
function unthunk(expression) {
  if (expression.type === "ArrowFunctionExpression" && expression.async === false && expression.body.type === "CallExpression" && expression.body.callee.type === "Identifier" && expression.params.length === expression.body.arguments.length && expression.params.every((param, index) => {
    const arg = (
      /** @type {ESTree.SimpleCallExpression} */
      expression.body.arguments[index]
    );
    return param.type === "Identifier" && arg.type === "Identifier" && param.name === arg.name;
  })) {
    return expression.body.callee;
  }
  return expression;
}
function new_builder(expression, ...args) {
  if (typeof expression === "string") expression = id(expression);
  return {
    callee: expression,
    arguments: args,
    type: "NewExpression"
  };
}
function update(operator, argument, prefix2 = false) {
  return { type: "UpdateExpression", operator, argument, prefix: prefix2 };
}
function do_while(test, body) {
  return { type: "DoWhileStatement", test, body };
}
var true_instance = literal2(true);
var false_instance = literal2(false);
var null_instance = literal2(null);
var debugger_builder = {
  type: "DebuggerStatement"
};
var this_instance = {
  type: "ThisExpression"
};
function let_builder(pattern, init3) {
  return declaration("let", [declarator(pattern, init3)]);
}
function const_builder(pattern, init3) {
  return declaration("const", [declarator(pattern, init3)]);
}
function var_builder(pattern, init3) {
  return declaration("var", [declarator(pattern, init3)]);
}
function for_builder(init3, test, update2, body) {
  return { type: "ForStatement", init: init3, test, update: update2, body };
}
function method(kind, key2, params, body, computed = false, is_static = false) {
  return {
    type: "MethodDefinition",
    key: key2,
    kind,
    value: function_builder(null, params, block(body)),
    computed,
    static: is_static
  };
}
function function_builder(id2, params, body) {
  return {
    type: "FunctionExpression",
    id: id2,
    params,
    body,
    generator: false,
    async: false,
    metadata: (
      /** @type {any} */
      null
    )
    // should not be used by codegen
  };
}
function if_builder(test, consequent, alternate) {
  return { type: "IfStatement", test, consequent, alternate };
}
function import_all(as, source2) {
  return {
    type: "ImportDeclaration",
    source: literal2(source2),
    specifiers: [import_namespace(as)]
  };
}
function imports(parts, source2) {
  return {
    type: "ImportDeclaration",
    source: literal2(source2),
    specifiers: parts.map((p) => ({
      type: "ImportSpecifier",
      imported: id(p[0]),
      local: id(p[1])
    }))
  };
}
function return_builder(argument = null) {
  return { type: "ReturnStatement", argument };
}
function throw_error(str) {
  return {
    type: "ThrowStatement",
    argument: new_builder("Error", literal2(str))
  };
}
function key(name) {
  return regex_is_valid_identifier.test(name) ? id(name) : literal2(name);
}

// node_modules/svelte/src/compiler/utils/ast.js
function object2(expression) {
  while (expression.type === "MemberExpression") {
    expression = /** @type {ESTree.MemberExpression | ESTree.Identifier} */
    expression.object;
  }
  if (expression.type !== "Identifier") {
    return null;
  }
  return expression;
}
function is_text_attribute(attribute) {
  return Array.isArray(attribute.value) && attribute.value.length === 1 && attribute.value[0].type === "Text";
}
function is_expression_attribute(attribute) {
  return attribute.value !== true && !Array.isArray(attribute.value) || Array.isArray(attribute.value) && attribute.value.length === 1 && attribute.value[0].type === "ExpressionTag";
}
function get_attribute_expression(attribute) {
  return Array.isArray(attribute.value) ? (
    /** @type {AST.ExpressionTag} */
    attribute.value[0].expression
  ) : attribute.value.expression;
}
function get_attribute_chunks(value) {
  return Array.isArray(value) ? value : typeof value === "boolean" ? [] : [value];
}
function is_event_attribute(attribute) {
  return is_expression_attribute(attribute) && attribute.name.startsWith("on");
}
function unwrap_pattern(pattern, nodes = []) {
  switch (pattern.type) {
    case "Identifier":
      nodes.push(pattern);
      break;
    case "MemberExpression":
      nodes.push(pattern);
      break;
    case "ObjectPattern":
      for (const prop2 of pattern.properties) {
        if (prop2.type === "RestElement") {
          unwrap_pattern(prop2.argument, nodes);
        } else {
          unwrap_pattern(prop2.value, nodes);
        }
      }
      break;
    case "ArrayPattern":
      for (const element2 of pattern.elements) {
        if (element2) unwrap_pattern(element2, nodes);
      }
      break;
    case "RestElement":
      unwrap_pattern(pattern.argument, nodes);
      break;
    case "AssignmentPattern":
      unwrap_pattern(pattern.left, nodes);
      break;
  }
  return nodes;
}
function extract_identifiers(pattern) {
  return unwrap_pattern(pattern, []).filter((node) => node.type === "Identifier");
}
function extract_all_identifiers_from_expression(expr) {
  let nodes = [];
  let keypath = [];
  walk(
    expr,
    {},
    {
      Identifier(node, { path: path11 }) {
        const parent = path11.at(-1);
        if ((parent == null ? void 0 : parent.type) !== "MemberExpression" || parent.property !== node || parent.computed) {
          nodes.push(node);
        }
        if ((parent == null ? void 0 : parent.type) === "MemberExpression" && parent.computed && parent.property === node) {
          keypath.push(`[${node.name}]`);
        } else {
          keypath.push(node.name);
        }
      },
      Literal(node, { path: path11 }) {
        const value = typeof node.value === "string" ? `"${node.value}"` : String(node.value);
        const parent = path11.at(-1);
        if ((parent == null ? void 0 : parent.type) === "MemberExpression" && parent.computed && parent.property === node) {
          keypath.push(`[${value}]`);
        } else {
          keypath.push(value);
        }
      },
      ThisExpression(_, { next: next2 }) {
        keypath.push("this");
        next2();
      }
    }
  );
  return [keypath.join("."), nodes];
}
function extract_identifiers_from_destructuring(node, nodes = []) {
  switch (node.type) {
    case "Identifier":
      nodes.push(node);
      break;
    case "ObjectExpression":
      for (const prop2 of node.properties) {
        if (prop2.type === "Property") {
          extract_identifiers_from_destructuring(
            /** @type {any} */
            prop2.value,
            nodes
          );
        } else {
          extract_identifiers_from_destructuring(
            /** @type {any} */
            prop2.argument,
            nodes
          );
        }
      }
      break;
    case "ArrayExpression":
      for (const element2 of node.elements) {
        if (element2) extract_identifiers_from_destructuring(
          /** @type {any} */
          element2,
          nodes
        );
      }
      break;
  }
  return nodes;
}
function extract_paths(param, initial) {
  const inserts = [];
  const paths = [];
  _extract_paths(paths, inserts, param, initial, initial, false);
  return { inserts, paths };
}
function _extract_paths(paths, inserts, param, expression, update_expression, has_default_value) {
  var _a2;
  switch (param.type) {
    case "Identifier":
    case "MemberExpression":
      paths.push({
        node: param,
        is_rest: false,
        has_default_value,
        expression,
        update_expression
      });
      break;
    case "ObjectPattern":
      for (const prop2 of param.properties) {
        if (prop2.type === "RestElement") {
          const props = [];
          for (const p of param.properties) {
            if (p.type === "Property" && p.key.type !== "PrivateIdentifier") {
              if (p.key.type === "Identifier" && !p.computed) {
                props.push(literal2(p.key.name));
              } else if (p.key.type === "Literal") {
                props.push(literal2(String(p.key.value)));
              } else {
                props.push(call("String", p.key));
              }
            }
          }
          const rest_expression = call("$.exclude_from_object", expression, array(props));
          if (prop2.argument.type === "Identifier") {
            paths.push({
              node: prop2.argument,
              is_rest: true,
              has_default_value,
              expression: rest_expression,
              update_expression: rest_expression
            });
          } else {
            _extract_paths(
              paths,
              inserts,
              prop2.argument,
              rest_expression,
              rest_expression,
              has_default_value
            );
          }
        } else {
          const object_expression = member(
            expression,
            prop2.key,
            prop2.computed || prop2.key.type !== "Identifier"
          );
          _extract_paths(
            paths,
            inserts,
            prop2.value,
            object_expression,
            object_expression,
            has_default_value
          );
        }
      }
      break;
    case "ArrayPattern": {
      const id2 = id("#");
      const value = call(
        "$.to_array",
        expression,
        ((_a2 = param.elements.at(-1)) == null ? void 0 : _a2.type) === "RestElement" ? void 0 : literal2(param.elements.length)
      );
      inserts.push({ id: id2, value });
      for (let i = 0; i < param.elements.length; i += 1) {
        const element2 = param.elements[i];
        if (element2) {
          if (element2.type === "RestElement") {
            const rest_expression = call(member(id2, "slice"), literal2(i));
            if (element2.argument.type === "Identifier") {
              paths.push({
                node: element2.argument,
                is_rest: true,
                has_default_value,
                expression: rest_expression,
                update_expression: rest_expression
              });
            } else {
              _extract_paths(
                paths,
                inserts,
                element2.argument,
                rest_expression,
                rest_expression,
                has_default_value
              );
            }
          } else {
            const array_expression = member(id2, literal2(i), true);
            _extract_paths(
              paths,
              inserts,
              element2,
              array_expression,
              array_expression,
              has_default_value
            );
          }
        }
      }
      break;
    }
    case "AssignmentPattern": {
      const fallback_expression = build_fallback(expression, param.right);
      if (param.left.type === "Identifier") {
        paths.push({
          node: param.left,
          is_rest: false,
          has_default_value: true,
          expression: fallback_expression,
          update_expression
        });
      } else {
        _extract_paths(paths, inserts, param.left, fallback_expression, update_expression, true);
      }
      break;
    }
  }
  return paths;
}
function get_parent(path11, at2) {
  let node = path11.at(at2);
  if (node.type === "TSNonNullExpression" || node.type === "TSAsExpression") {
    return (
      /** @type {T} */
      path11.at(at2 < 0 ? at2 - 1 : at2 + 1)
    );
  }
  return (
    /** @type {T} */
    node
  );
}
function is_simple_expression(node) {
  if (node.type === "Literal" || node.type === "Identifier" || node.type === "ArrowFunctionExpression" || node.type === "FunctionExpression") {
    return true;
  }
  if (node.type === "ConditionalExpression") {
    return is_simple_expression(node.test) && is_simple_expression(node.consequent) && is_simple_expression(node.alternate);
  }
  if (node.type === "BinaryExpression" || node.type === "LogicalExpression") {
    return node.left.type !== "PrivateIdentifier" && is_simple_expression(node.left) && is_simple_expression(node.right);
  }
  return false;
}
function unwrap_optional(node) {
  return node.type === "ChainExpression" ? node.expression : node;
}
function is_expression_async(expression) {
  switch (expression.type) {
    case "AwaitExpression": {
      return true;
    }
    case "ArrayPattern": {
      return expression.elements.some((element2) => element2 && is_expression_async(element2));
    }
    case "ArrayExpression": {
      return expression.elements.some((element2) => {
        if (!element2) {
          return false;
        } else if (element2.type === "SpreadElement") {
          return is_expression_async(element2.argument);
        } else {
          return is_expression_async(element2);
        }
      });
    }
    case "AssignmentPattern":
    case "AssignmentExpression":
    case "BinaryExpression":
    case "LogicalExpression": {
      return expression.left.type !== "PrivateIdentifier" && is_expression_async(expression.left) || is_expression_async(expression.right);
    }
    case "CallExpression":
    case "NewExpression": {
      return expression.callee.type !== "Super" && is_expression_async(expression.callee) || expression.arguments.some((element2) => {
        if (element2.type === "SpreadElement") {
          return is_expression_async(element2.argument);
        } else {
          return is_expression_async(element2);
        }
      });
    }
    case "ChainExpression": {
      return is_expression_async(expression.expression);
    }
    case "ConditionalExpression": {
      return is_expression_async(expression.test) || is_expression_async(expression.alternate) || is_expression_async(expression.consequent);
    }
    case "ImportExpression": {
      return is_expression_async(expression.source);
    }
    case "MemberExpression": {
      return expression.object.type !== "Super" && is_expression_async(expression.object) || expression.property.type !== "PrivateIdentifier" && is_expression_async(expression.property);
    }
    case "ObjectPattern":
    case "ObjectExpression": {
      return expression.properties.some((property) => {
        if (property.type === "SpreadElement") {
          return is_expression_async(property.argument);
        } else if (property.type === "Property") {
          return property.key.type !== "PrivateIdentifier" && is_expression_async(property.key) || is_expression_async(property.value);
        }
      });
    }
    case "RestElement": {
      return is_expression_async(expression.argument);
    }
    case "SequenceExpression":
    case "TemplateLiteral": {
      return expression.expressions.some((subexpression) => is_expression_async(subexpression));
    }
    case "TaggedTemplateExpression": {
      return is_expression_async(expression.tag) || is_expression_async(expression.quasi);
    }
    case "UnaryExpression":
    case "UpdateExpression": {
      return is_expression_async(expression.argument);
    }
    case "YieldExpression": {
      return expression.argument ? is_expression_async(expression.argument) : false;
    }
    default:
      return false;
  }
}
function build_fallback(expression, fallback) {
  if (is_simple_expression(fallback)) {
    return call("$.fallback", expression, fallback);
  }
  if (fallback.type === "AwaitExpression" && is_simple_expression(fallback.argument)) {
    return await_builder(call("$.fallback", expression, fallback.argument));
  }
  return is_expression_async(fallback) ? await_builder(call("$.fallback", expression, thunk(fallback, true), true_instance)) : call("$.fallback", expression, thunk(fallback), true_instance);
}
function build_assignment_value(operator, left, right) {
  return operator === "=" ? right : (
    // turn something like x += 1 into x = x + 1
    ["||=", "&&=", "??="].includes(operator) ? logical(
      /** @type {ESTree.LogicalOperator} */
      operator.slice(0, -1),
      left,
      right
    ) : binary(
      /** @type {ESTree.BinaryOperator} */
      operator.slice(0, -1),
      left,
      right
    )
  );
}

// node_modules/svelte/src/compiler/phases/1-parse/read/script.js
var regex_closing_script_tag = /<\/script\s*>/;
var regex_starts_with_closing_script_tag = /^<\/script\s*>/;
var RESERVED_ATTRIBUTES = ["server", "client", "worker", "test", "default"];
var ALLOWED_ATTRIBUTES = ["context", "generics", "lang", "module"];
function read_script(parser, start, attributes) {
  const script_start = parser.index;
  const data2 = parser.read_until(regex_closing_script_tag);
  if (parser.index >= parser.template.length) {
    element_unclosed(parser.template.length, "script");
  }
  const source2 = parser.template.slice(0, script_start).replace(regex_not_newline_characters, " ") + data2;
  parser.read(regex_starts_with_closing_script_tag);
  let ast;
  try {
    ast = parse4(source2, parser.ts, true);
  } catch (err) {
    parser.acorn_error(err);
  }
  ast.start = script_start;
  let context = "default";
  for (
    const attribute of
    /** @type {AST.Attribute[]} */
    attributes
  ) {
    if (RESERVED_ATTRIBUTES.includes(attribute.name)) {
      script_reserved_attribute(attribute, attribute.name);
    }
    if (!ALLOWED_ATTRIBUTES.includes(attribute.name)) {
      script_unknown_attribute(attribute);
    }
    if (attribute.name === "module") {
      if (attribute.value !== true) {
        script_invalid_attribute_value(attribute, attribute.name);
      }
      context = "module";
    }
    if (attribute.name === "context") {
      if (attribute.value === true || !is_text_attribute(attribute)) {
        script_invalid_context(attribute);
      }
      const value = attribute.value[0].data;
      if (value !== "module") {
        script_invalid_context(attribute);
      }
      context = "module";
    }
  }
  return {
    type: "Script",
    start,
    end: parser.index,
    context,
    content: ast,
    // @ts-ignore
    attributes
  };
}

// node_modules/svelte/src/compiler/phases/1-parse/read/style.js
var REGEX_MATCHER = /^[~^$*|]?=/;
var REGEX_CLOSING_BRACKET = /[\s\]]/;
var REGEX_ATTRIBUTE_FLAGS = /^[a-zA-Z]+/;
var REGEX_COMBINATOR = /^(\+|~|>|\|\|)/;
var REGEX_PERCENTAGE = /^\d+(\.\d+)?%/;
var REGEX_NTH_OF = /^(even|odd|\+?(\d+|\d*n(\s*[+-]\s*\d+)?)|-\d*n(\s*\+\s*\d+))((?=\s*[,)])|\s+of\s+)/;
var REGEX_WHITESPACE_OR_COLON = /[\s:]/;
var REGEX_LEADING_HYPHEN_OR_DIGIT = /-?\d/;
var REGEX_VALID_IDENTIFIER_CHAR = /[a-zA-Z0-9_-]/;
var REGEX_UNICODE_SEQUENCE = /^\\[0-9a-fA-F]{1,6}(\r\n|\s)?/;
var REGEX_COMMENT_CLOSE = /\*\//;
var REGEX_HTML_COMMENT_CLOSE = /-->/;
function read_style(parser, start, attributes) {
  const content_start = parser.index;
  const children = read_body(parser, "</style");
  const content_end = parser.index;
  parser.read(/^<\/style\s*>/);
  return {
    type: "StyleSheet",
    start,
    end: parser.index,
    attributes,
    children,
    content: {
      start: content_start,
      end: content_end,
      styles: parser.template.slice(content_start, content_end),
      comment: null
    }
  };
}
function read_body(parser, close2) {
  const children = [];
  while (parser.index < parser.template.length) {
    allow_comment_or_whitespace(parser);
    if (parser.match(close2)) {
      return children;
    }
    if (parser.match("@")) {
      children.push(read_at_rule(parser));
    } else {
      children.push(read_rule(parser));
    }
  }
  expected_token(parser.template.length, close2);
}
function read_at_rule(parser) {
  const start = parser.index;
  parser.eat("@", true);
  const name = read_identifier(parser);
  const prelude = read_value(parser);
  let block2 = null;
  if (parser.match("{")) {
    block2 = read_block(parser);
  } else {
    parser.eat(";", true);
  }
  return {
    type: "Atrule",
    start,
    end: parser.index,
    name,
    prelude,
    block: block2
  };
}
function read_rule(parser) {
  const start = parser.index;
  return {
    type: "Rule",
    prelude: read_selector_list(parser),
    block: read_block(parser),
    start,
    end: parser.index,
    metadata: {
      parent_rule: null,
      has_local_selectors: false,
      has_global_selectors: false,
      is_global_block: false
    }
  };
}
function read_selector_list(parser, inside_pseudo_class = false) {
  const children = [];
  allow_comment_or_whitespace(parser);
  const start = parser.index;
  while (parser.index < parser.template.length) {
    children.push(read_selector(parser, inside_pseudo_class));
    const end = parser.index;
    allow_comment_or_whitespace(parser);
    if (inside_pseudo_class ? parser.match(")") : parser.match("{")) {
      return {
        type: "SelectorList",
        start,
        end,
        children
      };
    } else {
      parser.eat(",", true);
      allow_comment_or_whitespace(parser);
    }
  }
  unexpected_eof(parser.template.length);
}
function read_selector(parser, inside_pseudo_class = false) {
  const list_start = parser.index;
  const children = [];
  function create_selector(combinator, start) {
    return {
      type: "RelativeSelector",
      combinator,
      selectors: [],
      start,
      end: -1,
      metadata: {
        is_global: false,
        is_global_like: false,
        scoped: false
      }
    };
  }
  let relative_selector = create_selector(null, parser.index);
  while (parser.index < parser.template.length) {
    let start = parser.index;
    if (parser.eat("&")) {
      relative_selector.selectors.push({
        type: "NestingSelector",
        name: "&",
        start,
        end: parser.index
      });
    } else if (parser.eat("*")) {
      let name = "*";
      if (parser.eat("|")) {
        name = read_identifier(parser);
      }
      relative_selector.selectors.push({
        type: "TypeSelector",
        name,
        start,
        end: parser.index
      });
    } else if (parser.eat("#")) {
      relative_selector.selectors.push({
        type: "IdSelector",
        name: read_identifier(parser),
        start,
        end: parser.index
      });
    } else if (parser.eat(".")) {
      relative_selector.selectors.push({
        type: "ClassSelector",
        name: read_identifier(parser),
        start,
        end: parser.index
      });
    } else if (parser.eat("::")) {
      relative_selector.selectors.push({
        type: "PseudoElementSelector",
        name: read_identifier(parser),
        start,
        end: parser.index
      });
      if (parser.eat("(")) {
        read_selector_list(parser, true);
        parser.eat(")", true);
      }
    } else if (parser.eat(":")) {
      const name = read_identifier(parser);
      let args = null;
      if (parser.eat("(")) {
        args = read_selector_list(parser, true);
        parser.eat(")", true);
      }
      relative_selector.selectors.push({
        type: "PseudoClassSelector",
        name,
        args,
        start,
        end: parser.index
      });
    } else if (parser.eat("[")) {
      parser.allow_whitespace();
      const name = read_identifier(parser);
      parser.allow_whitespace();
      let value = null;
      const matcher = parser.read(REGEX_MATCHER);
      if (matcher) {
        parser.allow_whitespace();
        value = read_attribute_value(parser);
      }
      parser.allow_whitespace();
      const flags = parser.read(REGEX_ATTRIBUTE_FLAGS);
      parser.allow_whitespace();
      parser.eat("]", true);
      relative_selector.selectors.push({
        type: "AttributeSelector",
        start,
        end: parser.index,
        name,
        matcher,
        value,
        flags
      });
    } else if (inside_pseudo_class && parser.match_regex(REGEX_NTH_OF)) {
      relative_selector.selectors.push({
        type: "Nth",
        value: (
          /**@type {string} */
          parser.read(REGEX_NTH_OF)
        ),
        start,
        end: parser.index
      });
    } else if (parser.match_regex(REGEX_PERCENTAGE)) {
      relative_selector.selectors.push({
        type: "Percentage",
        value: (
          /** @type {string} */
          parser.read(REGEX_PERCENTAGE)
        ),
        start,
        end: parser.index
      });
    } else if (!parser.match_regex(REGEX_COMBINATOR)) {
      let name = read_identifier(parser);
      if (parser.eat("|")) {
        name = read_identifier(parser);
      }
      relative_selector.selectors.push({
        type: "TypeSelector",
        name,
        start,
        end: parser.index
      });
    }
    const index = parser.index;
    allow_comment_or_whitespace(parser);
    if (parser.match(",") || (inside_pseudo_class ? parser.match(")") : parser.match("{"))) {
      parser.index = index;
      relative_selector.end = index;
      children.push(relative_selector);
      return {
        type: "ComplexSelector",
        start: list_start,
        end: index,
        children,
        metadata: {
          rule: null,
          is_global: false,
          used: false
        }
      };
    }
    parser.index = index;
    const combinator = read_combinator(parser);
    if (combinator) {
      if (relative_selector.selectors.length > 0) {
        relative_selector.end = index;
        children.push(relative_selector);
      }
      relative_selector = create_selector(combinator, combinator.start);
      parser.allow_whitespace();
      if (parser.match(",") || (inside_pseudo_class ? parser.match(")") : parser.match("{"))) {
        css_selector_invalid(parser.index);
      }
    }
  }
  unexpected_eof(parser.template.length);
}
function read_combinator(parser) {
  const start = parser.index;
  parser.allow_whitespace();
  const index = parser.index;
  const name = parser.read(REGEX_COMBINATOR);
  if (name) {
    const end = parser.index;
    parser.allow_whitespace();
    return {
      type: "Combinator",
      name,
      start: index,
      end
    };
  }
  if (parser.index !== start) {
    return {
      type: "Combinator",
      name: " ",
      start,
      end: parser.index
    };
  }
  return null;
}
function read_block(parser) {
  const start = parser.index;
  parser.eat("{", true);
  const children = [];
  while (parser.index < parser.template.length) {
    allow_comment_or_whitespace(parser);
    if (parser.match("}")) {
      break;
    } else {
      children.push(read_block_item(parser));
    }
  }
  parser.eat("}", true);
  return {
    type: "Block",
    start,
    end: parser.index,
    children
  };
}
function read_block_item(parser) {
  if (parser.match("@")) {
    return read_at_rule(parser);
  }
  const start = parser.index;
  read_value(parser);
  const char = parser.template[parser.index];
  parser.index = start;
  return char === "{" ? read_rule(parser) : read_declaration(parser);
}
function read_declaration(parser) {
  const start = parser.index;
  const property = parser.read_until(REGEX_WHITESPACE_OR_COLON);
  parser.allow_whitespace();
  parser.eat(":");
  let index = parser.index;
  parser.allow_whitespace();
  const value = read_value(parser);
  if (!value && !property.startsWith("--")) {
    css_empty_declaration({ start, end: index });
  }
  const end = parser.index;
  if (!parser.match("}")) {
    parser.eat(";", true);
  }
  return {
    type: "Declaration",
    start,
    end,
    property,
    value
  };
}
function read_value(parser) {
  let value = "";
  let escaped = false;
  let in_url = false;
  let quote_mark = null;
  while (parser.index < parser.template.length) {
    const char = parser.template[parser.index];
    if (escaped) {
      value += "\\" + char;
      escaped = false;
    } else if (char === "\\") {
      escaped = true;
    } else if (char === quote_mark) {
      quote_mark = null;
    } else if (char === ")") {
      in_url = false;
    } else if (quote_mark === null && (char === '"' || char === "'")) {
      quote_mark = char;
    } else if (char === "(" && value.slice(-3) === "url") {
      in_url = true;
    } else if ((char === ";" || char === "{" || char === "}") && !in_url && !quote_mark) {
      return value.trim();
    }
    value += char;
    parser.index++;
  }
  unexpected_eof(parser.template.length);
}
function read_attribute_value(parser) {
  let value = "";
  let escaped = false;
  const quote_mark = parser.eat('"') ? '"' : parser.eat("'") ? "'" : null;
  while (parser.index < parser.template.length) {
    const char = parser.template[parser.index];
    if (escaped) {
      value += "\\" + char;
      escaped = false;
    } else if (char === "\\") {
      escaped = true;
    } else if (quote_mark ? char === quote_mark : REGEX_CLOSING_BRACKET.test(char)) {
      if (quote_mark) {
        parser.eat(quote_mark, true);
      }
      return value.trim();
    } else {
      value += char;
    }
    parser.index++;
  }
  unexpected_eof(parser.template.length);
}
function read_identifier(parser) {
  const start = parser.index;
  let identifier = "";
  if (parser.match_regex(REGEX_LEADING_HYPHEN_OR_DIGIT)) {
    css_expected_identifier(start);
  }
  while (parser.index < parser.template.length) {
    const char = parser.template[parser.index];
    if (char === "\\") {
      const sequence3 = parser.match_regex(REGEX_UNICODE_SEQUENCE);
      if (sequence3) {
        identifier += String.fromCodePoint(parseInt(sequence3.slice(1), 16));
        parser.index += sequence3.length;
      } else {
        identifier += "\\" + parser.template[parser.index + 1];
        parser.index += 2;
      }
    } else if (
      /** @type {number} */
      char.codePointAt(0) >= 160 || REGEX_VALID_IDENTIFIER_CHAR.test(char)
    ) {
      identifier += char;
      parser.index++;
    } else {
      break;
    }
  }
  if (identifier === "") {
    css_expected_identifier(start);
  }
  return identifier;
}
function allow_comment_or_whitespace(parser) {
  parser.allow_whitespace();
  while (parser.match("/*") || parser.match("<!--")) {
    if (parser.eat("/*")) {
      parser.read_until(REGEX_COMMENT_CLOSE);
      parser.eat("*/", true);
    }
    if (parser.eat("<!--")) {
      parser.read_until(REGEX_HTML_COMMENT_CLOSE);
      parser.eat("-->", true);
    }
    parser.allow_whitespace();
  }
}

// node_modules/svelte/src/compiler/phases/1-parse/utils/entities.js
var entities_default = {
  "CounterClockwiseContourIntegral;": 8755,
  "ClockwiseContourIntegral;": 8754,
  "DoubleLongLeftRightArrow;": 10234,
  "NotNestedGreaterGreater;": 10914,
  "DiacriticalDoubleAcute;": 733,
  "NotSquareSupersetEqual;": 8931,
  "CloseCurlyDoubleQuote;": 8221,
  "DoubleContourIntegral;": 8751,
  "FilledVerySmallSquare;": 9642,
  "NegativeVeryThinSpace;": 8203,
  "NotPrecedesSlantEqual;": 8928,
  "NotRightTriangleEqual;": 8941,
  "NotSucceedsSlantEqual;": 8929,
  "CapitalDifferentialD;": 8517,
  "DoubleLeftRightArrow;": 8660,
  "DoubleLongRightArrow;": 10233,
  "EmptyVerySmallSquare;": 9643,
  "NestedGreaterGreater;": 8811,
  "NotDoubleVerticalBar;": 8742,
  "NotGreaterSlantEqual;": 10878,
  "NotLeftTriangleEqual;": 8940,
  "NotSquareSubsetEqual;": 8930,
  "OpenCurlyDoubleQuote;": 8220,
  "ReverseUpEquilibrium;": 10607,
  "DoubleLongLeftArrow;": 10232,
  "DownLeftRightVector;": 10576,
  "LeftArrowRightArrow;": 8646,
  "NegativeMediumSpace;": 8203,
  "NotGreaterFullEqual;": 8807,
  "NotRightTriangleBar;": 10704,
  "RightArrowLeftArrow;": 8644,
  "SquareSupersetEqual;": 8850,
  "leftrightsquigarrow;": 8621,
  "DownRightTeeVector;": 10591,
  "DownRightVectorBar;": 10583,
  "LongLeftRightArrow;": 10231,
  "Longleftrightarrow;": 10234,
  "NegativeThickSpace;": 8203,
  "NotLeftTriangleBar;": 10703,
  "PrecedesSlantEqual;": 8828,
  "ReverseEquilibrium;": 8651,
  "RightDoubleBracket;": 10215,
  "RightDownTeeVector;": 10589,
  "RightDownVectorBar;": 10581,
  "RightTriangleEqual;": 8885,
  "SquareIntersection;": 8851,
  "SucceedsSlantEqual;": 8829,
  "blacktriangleright;": 9656,
  "longleftrightarrow;": 10231,
  "DoubleUpDownArrow;": 8661,
  "DoubleVerticalBar;": 8741,
  "DownLeftTeeVector;": 10590,
  "DownLeftVectorBar;": 10582,
  "FilledSmallSquare;": 9724,
  "GreaterSlantEqual;": 10878,
  "LeftDoubleBracket;": 10214,
  "LeftDownTeeVector;": 10593,
  "LeftDownVectorBar;": 10585,
  "LeftTriangleEqual;": 8884,
  "NegativeThinSpace;": 8203,
  "NotGreaterGreater;": 8811,
  "NotLessSlantEqual;": 10877,
  "NotNestedLessLess;": 10913,
  "NotReverseElement;": 8716,
  "NotSquareSuperset;": 8848,
  "NotTildeFullEqual;": 8775,
  "RightAngleBracket;": 10217,
  "RightUpDownVector;": 10575,
  "SquareSubsetEqual;": 8849,
  "VerticalSeparator;": 10072,
  "blacktriangledown;": 9662,
  "blacktriangleleft;": 9666,
  "leftrightharpoons;": 8651,
  "rightleftharpoons;": 8652,
  "twoheadrightarrow;": 8608,
  "DiacriticalAcute;": 180,
  "DiacriticalGrave;": 96,
  "DiacriticalTilde;": 732,
  "DoubleRightArrow;": 8658,
  "DownArrowUpArrow;": 8693,
  "EmptySmallSquare;": 9723,
  "GreaterEqualLess;": 8923,
  "GreaterFullEqual;": 8807,
  "LeftAngleBracket;": 10216,
  "LeftUpDownVector;": 10577,
  "LessEqualGreater;": 8922,
  "NonBreakingSpace;": 160,
  "NotPrecedesEqual;": 10927,
  "NotRightTriangle;": 8939,
  "NotSucceedsEqual;": 10928,
  "NotSucceedsTilde;": 8831,
  "NotSupersetEqual;": 8841,
  "RightTriangleBar;": 10704,
  "RightUpTeeVector;": 10588,
  "RightUpVectorBar;": 10580,
  "UnderParenthesis;": 9181,
  "UpArrowDownArrow;": 8645,
  "circlearrowright;": 8635,
  "downharpoonright;": 8642,
  "ntrianglerighteq;": 8941,
  "rightharpoondown;": 8641,
  "rightrightarrows;": 8649,
  "twoheadleftarrow;": 8606,
  "vartriangleright;": 8883,
  "CloseCurlyQuote;": 8217,
  "ContourIntegral;": 8750,
  "DoubleDownArrow;": 8659,
  "DoubleLeftArrow;": 8656,
  "DownRightVector;": 8641,
  "LeftRightVector;": 10574,
  "LeftTriangleBar;": 10703,
  "LeftUpTeeVector;": 10592,
  "LeftUpVectorBar;": 10584,
  "LowerRightArrow;": 8600,
  "NotGreaterEqual;": 8817,
  "NotGreaterTilde;": 8821,
  "NotHumpDownHump;": 8782,
  "NotLeftTriangle;": 8938,
  "NotSquareSubset;": 8847,
  "OverParenthesis;": 9180,
  "RightDownVector;": 8642,
  "ShortRightArrow;": 8594,
  "UpperRightArrow;": 8599,
  "bigtriangledown;": 9661,
  "circlearrowleft;": 8634,
  "curvearrowright;": 8631,
  "downharpoonleft;": 8643,
  "leftharpoondown;": 8637,
  "leftrightarrows;": 8646,
  "nLeftrightarrow;": 8654,
  "nleftrightarrow;": 8622,
  "ntrianglelefteq;": 8940,
  "rightleftarrows;": 8644,
  "rightsquigarrow;": 8605,
  "rightthreetimes;": 8908,
  "straightepsilon;": 1013,
  "trianglerighteq;": 8885,
  "vartriangleleft;": 8882,
  "DiacriticalDot;": 729,
  "DoubleRightTee;": 8872,
  "DownLeftVector;": 8637,
  "GreaterGreater;": 10914,
  "HorizontalLine;": 9472,
  "InvisibleComma;": 8291,
  "InvisibleTimes;": 8290,
  "LeftDownVector;": 8643,
  "LeftRightArrow;": 8596,
  "Leftrightarrow;": 8660,
  "LessSlantEqual;": 10877,
  "LongRightArrow;": 10230,
  "Longrightarrow;": 10233,
  "LowerLeftArrow;": 8601,
  "NestedLessLess;": 8810,
  "NotGreaterLess;": 8825,
  "NotLessGreater;": 8824,
  "NotSubsetEqual;": 8840,
  "NotVerticalBar;": 8740,
  "OpenCurlyQuote;": 8216,
  "ReverseElement;": 8715,
  "RightTeeVector;": 10587,
  "RightVectorBar;": 10579,
  "ShortDownArrow;": 8595,
  "ShortLeftArrow;": 8592,
  "SquareSuperset;": 8848,
  "TildeFullEqual;": 8773,
  "UpperLeftArrow;": 8598,
  "ZeroWidthSpace;": 8203,
  "curvearrowleft;": 8630,
  "doublebarwedge;": 8966,
  "downdownarrows;": 8650,
  "hookrightarrow;": 8618,
  "leftleftarrows;": 8647,
  "leftrightarrow;": 8596,
  "leftthreetimes;": 8907,
  "longrightarrow;": 10230,
  "looparrowright;": 8620,
  "nshortparallel;": 8742,
  "ntriangleright;": 8939,
  "rightarrowtail;": 8611,
  "rightharpoonup;": 8640,
  "trianglelefteq;": 8884,
  "upharpoonright;": 8638,
  "ApplyFunction;": 8289,
  "DifferentialD;": 8518,
  "DoubleLeftTee;": 10980,
  "DoubleUpArrow;": 8657,
  "LeftTeeVector;": 10586,
  "LeftVectorBar;": 10578,
  "LessFullEqual;": 8806,
  "LongLeftArrow;": 10229,
  "Longleftarrow;": 10232,
  "NotEqualTilde;": 8770,
  "NotTildeEqual;": 8772,
  "NotTildeTilde;": 8777,
  "Poincareplane;": 8460,
  "PrecedesEqual;": 10927,
  "PrecedesTilde;": 8830,
  "RightArrowBar;": 8677,
  "RightTeeArrow;": 8614,
  "RightTriangle;": 8883,
  "RightUpVector;": 8638,
  "SucceedsEqual;": 10928,
  "SucceedsTilde;": 8831,
  "SupersetEqual;": 8839,
  "UpEquilibrium;": 10606,
  "VerticalTilde;": 8768,
  "VeryThinSpace;": 8202,
  "bigtriangleup;": 9651,
  "blacktriangle;": 9652,
  "divideontimes;": 8903,
  "fallingdotseq;": 8786,
  "hookleftarrow;": 8617,
  "leftarrowtail;": 8610,
  "leftharpoonup;": 8636,
  "longleftarrow;": 10229,
  "looparrowleft;": 8619,
  "measuredangle;": 8737,
  "ntriangleleft;": 8938,
  "shortparallel;": 8741,
  "smallsetminus;": 8726,
  "triangleright;": 9657,
  "upharpoonleft;": 8639,
  "varsubsetneqq;": 10955,
  "varsupsetneqq;": 10956,
  "DownArrowBar;": 10515,
  "DownTeeArrow;": 8615,
  "ExponentialE;": 8519,
  "GreaterEqual;": 8805,
  "GreaterTilde;": 8819,
  "HilbertSpace;": 8459,
  "HumpDownHump;": 8782,
  "Intersection;": 8898,
  "LeftArrowBar;": 8676,
  "LeftTeeArrow;": 8612,
  "LeftTriangle;": 8882,
  "LeftUpVector;": 8639,
  "NotCongruent;": 8802,
  "NotHumpEqual;": 8783,
  "NotLessEqual;": 8816,
  "NotLessTilde;": 8820,
  "Proportional;": 8733,
  "RightCeiling;": 8969,
  "RoundImplies;": 10608,
  "ShortUpArrow;": 8593,
  "SquareSubset;": 8847,
  "UnderBracket;": 9141,
  "VerticalLine;": 124,
  "blacklozenge;": 10731,
  "exponentiale;": 8519,
  "risingdotseq;": 8787,
  "triangledown;": 9663,
  "triangleleft;": 9667,
  "varsubsetneq;": 8842,
  "varsupsetneq;": 8843,
  "CircleMinus;": 8854,
  "CircleTimes;": 8855,
  "Equilibrium;": 8652,
  "GreaterLess;": 8823,
  "LeftCeiling;": 8968,
  "LessGreater;": 8822,
  "MediumSpace;": 8287,
  "NotLessLess;": 8810,
  "NotPrecedes;": 8832,
  "NotSucceeds;": 8833,
  "NotSuperset;": 8835,
  "OverBracket;": 9140,
  "RightVector;": 8640,
  "Rrightarrow;": 8667,
  "RuleDelayed;": 10740,
  "SmallCircle;": 8728,
  "SquareUnion;": 8852,
  "SubsetEqual;": 8838,
  "UpDownArrow;": 8597,
  "Updownarrow;": 8661,
  "VerticalBar;": 8739,
  "backepsilon;": 1014,
  "blacksquare;": 9642,
  "circledcirc;": 8858,
  "circleddash;": 8861,
  "curlyeqprec;": 8926,
  "curlyeqsucc;": 8927,
  "diamondsuit;": 9830,
  "eqslantless;": 10901,
  "expectation;": 8496,
  "nRightarrow;": 8655,
  "nrightarrow;": 8603,
  "preccurlyeq;": 8828,
  "precnapprox;": 10937,
  "quaternions;": 8461,
  "straightphi;": 981,
  "succcurlyeq;": 8829,
  "succnapprox;": 10938,
  "thickapprox;": 8776,
  "updownarrow;": 8597,
  "Bernoullis;": 8492,
  "CirclePlus;": 8853,
  "EqualTilde;": 8770,
  "Fouriertrf;": 8497,
  "ImaginaryI;": 8520,
  "Laplacetrf;": 8466,
  "LeftVector;": 8636,
  "Lleftarrow;": 8666,
  "NotElement;": 8713,
  "NotGreater;": 8815,
  "Proportion;": 8759,
  "RightArrow;": 8594,
  "RightFloor;": 8971,
  "Rightarrow;": 8658,
  "ThickSpace;": 8287,
  "TildeEqual;": 8771,
  "TildeTilde;": 8776,
  "UnderBrace;": 9183,
  "UpArrowBar;": 10514,
  "UpTeeArrow;": 8613,
  "circledast;": 8859,
  "complement;": 8705,
  "curlywedge;": 8911,
  "eqslantgtr;": 10902,
  "gtreqqless;": 10892,
  "lessapprox;": 10885,
  "lesseqqgtr;": 10891,
  "lmoustache;": 9136,
  "longmapsto;": 10236,
  "mapstodown;": 8615,
  "mapstoleft;": 8612,
  "nLeftarrow;": 8653,
  "nleftarrow;": 8602,
  "nsubseteqq;": 10949,
  "nsupseteqq;": 10950,
  "precapprox;": 10935,
  "rightarrow;": 8594,
  "rmoustache;": 9137,
  "sqsubseteq;": 8849,
  "sqsupseteq;": 8850,
  "subsetneqq;": 10955,
  "succapprox;": 10936,
  "supsetneqq;": 10956,
  "upuparrows;": 8648,
  "varepsilon;": 1013,
  "varnothing;": 8709,
  "Backslash;": 8726,
  "CenterDot;": 183,
  "CircleDot;": 8857,
  "Congruent;": 8801,
  "Coproduct;": 8720,
  "DoubleDot;": 168,
  "DownArrow;": 8595,
  "DownBreve;": 785,
  "Downarrow;": 8659,
  "HumpEqual;": 8783,
  "LeftArrow;": 8592,
  "LeftFloor;": 8970,
  "Leftarrow;": 8656,
  "LessTilde;": 8818,
  "Mellintrf;": 8499,
  "MinusPlus;": 8723,
  "NotCupCap;": 8813,
  "NotExists;": 8708,
  "NotSubset;": 8834,
  "OverBrace;": 9182,
  "PlusMinus;": 177,
  "Therefore;": 8756,
  "ThinSpace;": 8201,
  "TripleDot;": 8411,
  "UnionPlus;": 8846,
  "backprime;": 8245,
  "backsimeq;": 8909,
  "bigotimes;": 10754,
  "centerdot;": 183,
  "checkmark;": 10003,
  "complexes;": 8450,
  "dotsquare;": 8865,
  "downarrow;": 8595,
  "gtrapprox;": 10886,
  "gtreqless;": 8923,
  "gvertneqq;": 8809,
  "heartsuit;": 9829,
  "leftarrow;": 8592,
  "lesseqgtr;": 8922,
  "lvertneqq;": 8808,
  "ngeqslant;": 10878,
  "nleqslant;": 10877,
  "nparallel;": 8742,
  "nshortmid;": 8740,
  "nsubseteq;": 8840,
  "nsupseteq;": 8841,
  "pitchfork;": 8916,
  "rationals;": 8474,
  "spadesuit;": 9824,
  "subseteqq;": 10949,
  "subsetneq;": 8842,
  "supseteqq;": 10950,
  "supsetneq;": 8843,
  "therefore;": 8756,
  "triangleq;": 8796,
  "varpropto;": 8733,
  "DDotrahd;": 10513,
  "DotEqual;": 8784,
  "Integral;": 8747,
  "LessLess;": 10913,
  "NotEqual;": 8800,
  "NotTilde;": 8769,
  "PartialD;": 8706,
  "Precedes;": 8826,
  "RightTee;": 8866,
  "Succeeds;": 8827,
  "SuchThat;": 8715,
  "Superset;": 8835,
  "Uarrocir;": 10569,
  "UnderBar;": 95,
  "andslope;": 10840,
  "angmsdaa;": 10664,
  "angmsdab;": 10665,
  "angmsdac;": 10666,
  "angmsdad;": 10667,
  "angmsdae;": 10668,
  "angmsdaf;": 10669,
  "angmsdag;": 10670,
  "angmsdah;": 10671,
  "angrtvbd;": 10653,
  "approxeq;": 8778,
  "awconint;": 8755,
  "backcong;": 8780,
  "barwedge;": 8965,
  "bbrktbrk;": 9142,
  "bigoplus;": 10753,
  "bigsqcup;": 10758,
  "biguplus;": 10756,
  "bigwedge;": 8896,
  "boxminus;": 8863,
  "boxtimes;": 8864,
  "bsolhsub;": 10184,
  "capbrcup;": 10825,
  "circledR;": 174,
  "circledS;": 9416,
  "cirfnint;": 10768,
  "clubsuit;": 9827,
  "cupbrcap;": 10824,
  "curlyvee;": 8910,
  "cwconint;": 8754,
  "doteqdot;": 8785,
  "dotminus;": 8760,
  "drbkarow;": 10512,
  "dzigrarr;": 10239,
  "elinters;": 9191,
  "emptyset;": 8709,
  "eqvparsl;": 10725,
  "fpartint;": 10765,
  "geqslant;": 10878,
  "gesdotol;": 10884,
  "gnapprox;": 10890,
  "hksearow;": 10533,
  "hkswarow;": 10534,
  "imagline;": 8464,
  "imagpart;": 8465,
  "infintie;": 10717,
  "integers;": 8484,
  "intercal;": 8890,
  "intlarhk;": 10775,
  "laemptyv;": 10676,
  "ldrushar;": 10571,
  "leqslant;": 10877,
  "lesdotor;": 10883,
  "llcorner;": 8990,
  "lnapprox;": 10889,
  "lrcorner;": 8991,
  "lurdshar;": 10570,
  "mapstoup;": 8613,
  "multimap;": 8888,
  "naturals;": 8469,
  "ncongdot;": 10861,
  "notindot;": 8949,
  "otimesas;": 10806,
  "parallel;": 8741,
  "plusacir;": 10787,
  "pointint;": 10773,
  "precneqq;": 10933,
  "precnsim;": 8936,
  "profalar;": 9006,
  "profline;": 8978,
  "profsurf;": 8979,
  "raemptyv;": 10675,
  "realpart;": 8476,
  "rppolint;": 10770,
  "rtriltri;": 10702,
  "scpolint;": 10771,
  "setminus;": 8726,
  "shortmid;": 8739,
  "smeparsl;": 10724,
  "sqsubset;": 8847,
  "sqsupset;": 8848,
  "subseteq;": 8838,
  "succneqq;": 10934,
  "succnsim;": 8937,
  "supseteq;": 8839,
  "thetasym;": 977,
  "thicksim;": 8764,
  "timesbar;": 10801,
  "triangle;": 9653,
  "triminus;": 10810,
  "trpezium;": 9186,
  "ulcorner;": 8988,
  "urcorner;": 8989,
  "varkappa;": 1008,
  "varsigma;": 962,
  "vartheta;": 977,
  "Because;": 8757,
  "Cayleys;": 8493,
  "Cconint;": 8752,
  "Cedilla;": 184,
  "Diamond;": 8900,
  "DownTee;": 8868,
  "Element;": 8712,
  "Epsilon;": 917,
  "Implies;": 8658,
  "LeftTee;": 8867,
  "NewLine;": 10,
  "NoBreak;": 8288,
  "NotLess;": 8814,
  "Omicron;": 927,
  "OverBar;": 8254,
  "Product;": 8719,
  "UpArrow;": 8593,
  "Uparrow;": 8657,
  "Upsilon;": 933,
  "alefsym;": 8501,
  "angrtvb;": 8894,
  "angzarr;": 9084,
  "asympeq;": 8781,
  "backsim;": 8765,
  "because;": 8757,
  "bemptyv;": 10672,
  "between;": 8812,
  "bigcirc;": 9711,
  "bigodot;": 10752,
  "bigstar;": 9733,
  "bnequiv;": 8801,
  "boxplus;": 8862,
  "ccupssm;": 10832,
  "cemptyv;": 10674,
  "cirscir;": 10690,
  "coloneq;": 8788,
  "congdot;": 10861,
  "cudarrl;": 10552,
  "cudarrr;": 10549,
  "cularrp;": 10557,
  "curarrm;": 10556,
  "dbkarow;": 10511,
  "ddagger;": 8225,
  "ddotseq;": 10871,
  "demptyv;": 10673,
  "diamond;": 8900,
  "digamma;": 989,
  "dotplus;": 8724,
  "dwangle;": 10662,
  "epsilon;": 949,
  "eqcolon;": 8789,
  "equivDD;": 10872,
  "gesdoto;": 10882,
  "gtquest;": 10876,
  "gtrless;": 8823,
  "harrcir;": 10568,
  "intprod;": 10812,
  "isindot;": 8949,
  "larrbfs;": 10527,
  "larrsim;": 10611,
  "lbrksld;": 10639,
  "lbrkslu;": 10637,
  "ldrdhar;": 10599,
  "lesdoto;": 10881,
  "lessdot;": 8918,
  "lessgtr;": 8822,
  "lesssim;": 8818,
  "lotimes;": 10804,
  "lozenge;": 9674,
  "ltquest;": 10875,
  "luruhar;": 10598,
  "maltese;": 10016,
  "minusdu;": 10794,
  "napprox;": 8777,
  "natural;": 9838,
  "nearrow;": 8599,
  "nexists;": 8708,
  "notinva;": 8713,
  "notinvb;": 8951,
  "notinvc;": 8950,
  "notniva;": 8716,
  "notnivb;": 8958,
  "notnivc;": 8957,
  "npolint;": 10772,
  "npreceq;": 10927,
  "nsqsube;": 8930,
  "nsqsupe;": 8931,
  "nsubset;": 8834,
  "nsucceq;": 10928,
  "nsupset;": 8835,
  "nvinfin;": 10718,
  "nvltrie;": 8884,
  "nvrtrie;": 8885,
  "nwarrow;": 8598,
  "olcross;": 10683,
  "omicron;": 959,
  "orderof;": 8500,
  "orslope;": 10839,
  "pertenk;": 8241,
  "planckh;": 8462,
  "pluscir;": 10786,
  "plussim;": 10790,
  "plustwo;": 10791,
  "precsim;": 8830,
  "quatint;": 10774,
  "questeq;": 8799,
  "rarrbfs;": 10528,
  "rarrsim;": 10612,
  "rbrksld;": 10638,
  "rbrkslu;": 10640,
  "rdldhar;": 10601,
  "realine;": 8475,
  "rotimes;": 10805,
  "ruluhar;": 10600,
  "searrow;": 8600,
  "simplus;": 10788,
  "simrarr;": 10610,
  "subedot;": 10947,
  "submult;": 10945,
  "subplus;": 10943,
  "subrarr;": 10617,
  "succsim;": 8831,
  "supdsub;": 10968,
  "supedot;": 10948,
  "suphsol;": 10185,
  "suphsub;": 10967,
  "suplarr;": 10619,
  "supmult;": 10946,
  "supplus;": 10944,
  "swarrow;": 8601,
  "topfork;": 10970,
  "triplus;": 10809,
  "tritime;": 10811,
  "uparrow;": 8593,
  "upsilon;": 965,
  "uwangle;": 10663,
  "vzigzag;": 10650,
  "zigrarr;": 8669,
  "Aacute;": 193,
  "Abreve;": 258,
  "Agrave;": 192,
  "Assign;": 8788,
  "Atilde;": 195,
  "Barwed;": 8966,
  "Bumpeq;": 8782,
  "Cacute;": 262,
  "Ccaron;": 268,
  "Ccedil;": 199,
  "Colone;": 10868,
  "Conint;": 8751,
  "CupCap;": 8781,
  "Dagger;": 8225,
  "Dcaron;": 270,
  "DotDot;": 8412,
  "Dstrok;": 272,
  "Eacute;": 201,
  "Ecaron;": 282,
  "Egrave;": 200,
  "Exists;": 8707,
  "ForAll;": 8704,
  "Gammad;": 988,
  "Gbreve;": 286,
  "Gcedil;": 290,
  "HARDcy;": 1066,
  "Hstrok;": 294,
  "Iacute;": 205,
  "Igrave;": 204,
  "Itilde;": 296,
  "Jsercy;": 1032,
  "Kcedil;": 310,
  "Lacute;": 313,
  "Lambda;": 923,
  "Lcaron;": 317,
  "Lcedil;": 315,
  "Lmidot;": 319,
  "Lstrok;": 321,
  "Nacute;": 323,
  "Ncaron;": 327,
  "Ncedil;": 325,
  "Ntilde;": 209,
  "Oacute;": 211,
  "Odblac;": 336,
  "Ograve;": 210,
  "Oslash;": 216,
  "Otilde;": 213,
  "Otimes;": 10807,
  "Racute;": 340,
  "Rarrtl;": 10518,
  "Rcaron;": 344,
  "Rcedil;": 342,
  "SHCHcy;": 1065,
  "SOFTcy;": 1068,
  "Sacute;": 346,
  "Scaron;": 352,
  "Scedil;": 350,
  "Square;": 9633,
  "Subset;": 8912,
  "Supset;": 8913,
  "Tcaron;": 356,
  "Tcedil;": 354,
  "Tstrok;": 358,
  "Uacute;": 218,
  "Ubreve;": 364,
  "Udblac;": 368,
  "Ugrave;": 217,
  "Utilde;": 360,
  "Vdashl;": 10982,
  "Verbar;": 8214,
  "Vvdash;": 8874,
  "Yacute;": 221,
  "Zacute;": 377,
  "Zcaron;": 381,
  "aacute;": 225,
  "abreve;": 259,
  "agrave;": 224,
  "andand;": 10837,
  "angmsd;": 8737,
  "angsph;": 8738,
  "apacir;": 10863,
  "approx;": 8776,
  "atilde;": 227,
  "barvee;": 8893,
  "barwed;": 8965,
  "becaus;": 8757,
  "bernou;": 8492,
  "bigcap;": 8898,
  "bigcup;": 8899,
  "bigvee;": 8897,
  "bkarow;": 10509,
  "bottom;": 8869,
  "bowtie;": 8904,
  "boxbox;": 10697,
  "bprime;": 8245,
  "brvbar;": 166,
  "bullet;": 8226,
  "bumpeq;": 8783,
  "cacute;": 263,
  "capand;": 10820,
  "capcap;": 10827,
  "capcup;": 10823,
  "capdot;": 10816,
  "ccaron;": 269,
  "ccedil;": 231,
  "circeq;": 8791,
  "cirmid;": 10991,
  "colone;": 8788,
  "commat;": 64,
  "compfn;": 8728,
  "conint;": 8750,
  "coprod;": 8720,
  "copysr;": 8471,
  "cularr;": 8630,
  "cupcap;": 10822,
  "cupcup;": 10826,
  "cupdot;": 8845,
  "curarr;": 8631,
  "curren;": 164,
  "cylcty;": 9005,
  "dagger;": 8224,
  "daleth;": 8504,
  "dcaron;": 271,
  "dfisht;": 10623,
  "divide;": 247,
  "divonx;": 8903,
  "dlcorn;": 8990,
  "dlcrop;": 8973,
  "dollar;": 36,
  "drcorn;": 8991,
  "drcrop;": 8972,
  "dstrok;": 273,
  "eacute;": 233,
  "easter;": 10862,
  "ecaron;": 283,
  "ecolon;": 8789,
  "egrave;": 232,
  "egsdot;": 10904,
  "elsdot;": 10903,
  "emptyv;": 8709,
  "emsp13;": 8196,
  "emsp14;": 8197,
  "eparsl;": 10723,
  "eqcirc;": 8790,
  "equals;": 61,
  "equest;": 8799,
  "female;": 9792,
  "ffilig;": 64259,
  "ffllig;": 64260,
  "forall;": 8704,
  "frac12;": 189,
  "frac13;": 8531,
  "frac14;": 188,
  "frac15;": 8533,
  "frac16;": 8537,
  "frac18;": 8539,
  "frac23;": 8532,
  "frac25;": 8534,
  "frac34;": 190,
  "frac35;": 8535,
  "frac38;": 8540,
  "frac45;": 8536,
  "frac56;": 8538,
  "frac58;": 8541,
  "frac78;": 8542,
  "gacute;": 501,
  "gammad;": 989,
  "gbreve;": 287,
  "gesdot;": 10880,
  "gesles;": 10900,
  "gtlPar;": 10645,
  "gtrarr;": 10616,
  "gtrdot;": 8919,
  "gtrsim;": 8819,
  "hairsp;": 8202,
  "hamilt;": 8459,
  "hardcy;": 1098,
  "hearts;": 9829,
  "hellip;": 8230,
  "hercon;": 8889,
  "homtht;": 8763,
  "horbar;": 8213,
  "hslash;": 8463,
  "hstrok;": 295,
  "hybull;": 8259,
  "hyphen;": 8208,
  "iacute;": 237,
  "igrave;": 236,
  "iiiint;": 10764,
  "iinfin;": 10716,
  "incare;": 8453,
  "inodot;": 305,
  "intcal;": 8890,
  "iquest;": 191,
  "isinsv;": 8947,
  "itilde;": 297,
  "jsercy;": 1112,
  "kappav;": 1008,
  "kcedil;": 311,
  "kgreen;": 312,
  "lAtail;": 10523,
  "lacute;": 314,
  "lagran;": 8466,
  "lambda;": 955,
  "langle;": 10216,
  "larrfs;": 10525,
  "larrhk;": 8617,
  "larrlp;": 8619,
  "larrpl;": 10553,
  "larrtl;": 8610,
  "latail;": 10521,
  "lbrace;": 123,
  "lbrack;": 91,
  "lcaron;": 318,
  "lcedil;": 316,
  "ldquor;": 8222,
  "lesdot;": 10879,
  "lesges;": 10899,
  "lfisht;": 10620,
  "lfloor;": 8970,
  "lharul;": 10602,
  "llhard;": 10603,
  "lmidot;": 320,
  "lmoust;": 9136,
  "loplus;": 10797,
  "lowast;": 8727,
  "lowbar;": 95,
  "lparlt;": 10643,
  "lrhard;": 10605,
  "lsaquo;": 8249,
  "lsquor;": 8218,
  "lstrok;": 322,
  "lthree;": 8907,
  "ltimes;": 8905,
  "ltlarr;": 10614,
  "ltrPar;": 10646,
  "mapsto;": 8614,
  "marker;": 9646,
  "mcomma;": 10793,
  "midast;": 42,
  "midcir;": 10992,
  "middot;": 183,
  "minusb;": 8863,
  "minusd;": 8760,
  "mnplus;": 8723,
  "models;": 8871,
  "mstpos;": 8766,
  "nVDash;": 8879,
  "nVdash;": 8878,
  "nacute;": 324,
  "nbumpe;": 8783,
  "ncaron;": 328,
  "ncedil;": 326,
  "nearhk;": 10532,
  "nequiv;": 8802,
  "nesear;": 10536,
  "nexist;": 8708,
  "nltrie;": 8940,
  "notinE;": 8953,
  "nparsl;": 11005,
  "nprcue;": 8928,
  "nrarrc;": 10547,
  "nrarrw;": 8605,
  "nrtrie;": 8941,
  "nsccue;": 8929,
  "nsimeq;": 8772,
  "ntilde;": 241,
  "numero;": 8470,
  "nvDash;": 8877,
  "nvHarr;": 10500,
  "nvdash;": 8876,
  "nvlArr;": 10498,
  "nvrArr;": 10499,
  "nwarhk;": 10531,
  "nwnear;": 10535,
  "oacute;": 243,
  "odblac;": 337,
  "odsold;": 10684,
  "ograve;": 242,
  "ominus;": 8854,
  "origof;": 8886,
  "oslash;": 248,
  "otilde;": 245,
  "otimes;": 8855,
  "parsim;": 10995,
  "percnt;": 37,
  "period;": 46,
  "permil;": 8240,
  "phmmat;": 8499,
  "planck;": 8463,
  "plankv;": 8463,
  "plusdo;": 8724,
  "plusdu;": 10789,
  "plusmn;": 177,
  "preceq;": 10927,
  "primes;": 8473,
  "prnsim;": 8936,
  "propto;": 8733,
  "prurel;": 8880,
  "puncsp;": 8200,
  "qprime;": 8279,
  "rAtail;": 10524,
  "racute;": 341,
  "rangle;": 10217,
  "rarrap;": 10613,
  "rarrfs;": 10526,
  "rarrhk;": 8618,
  "rarrlp;": 8620,
  "rarrpl;": 10565,
  "rarrtl;": 8611,
  "ratail;": 10522,
  "rbrace;": 125,
  "rbrack;": 93,
  "rcaron;": 345,
  "rcedil;": 343,
  "rdquor;": 8221,
  "rfisht;": 10621,
  "rfloor;": 8971,
  "rharul;": 10604,
  "rmoust;": 9137,
  "roplus;": 10798,
  "rpargt;": 10644,
  "rsaquo;": 8250,
  "rsquor;": 8217,
  "rthree;": 8908,
  "rtimes;": 8906,
  "sacute;": 347,
  "scaron;": 353,
  "scedil;": 351,
  "scnsim;": 8937,
  "searhk;": 10533,
  "seswar;": 10537,
  "sfrown;": 8994,
  "shchcy;": 1097,
  "sigmaf;": 962,
  "sigmav;": 962,
  "simdot;": 10858,
  "smashp;": 10803,
  "softcy;": 1100,
  "solbar;": 9023,
  "spades;": 9824,
  "sqcaps;": 8851,
  "sqcups;": 8852,
  "sqsube;": 8849,
  "sqsupe;": 8850,
  "square;": 9633,
  "squarf;": 9642,
  "ssetmn;": 8726,
  "ssmile;": 8995,
  "sstarf;": 8902,
  "subdot;": 10941,
  "subset;": 8834,
  "subsim;": 10951,
  "subsub;": 10965,
  "subsup;": 10963,
  "succeq;": 10928,
  "supdot;": 10942,
  "supset;": 8835,
  "supsim;": 10952,
  "supsub;": 10964,
  "supsup;": 10966,
  "swarhk;": 10534,
  "swnwar;": 10538,
  "target;": 8982,
  "tcaron;": 357,
  "tcedil;": 355,
  "telrec;": 8981,
  "there4;": 8756,
  "thetav;": 977,
  "thinsp;": 8201,
  "thksim;": 8764,
  "timesb;": 8864,
  "timesd;": 10800,
  "topbot;": 9014,
  "topcir;": 10993,
  "tprime;": 8244,
  "tridot;": 9708,
  "tstrok;": 359,
  "uacute;": 250,
  "ubreve;": 365,
  "udblac;": 369,
  "ufisht;": 10622,
  "ugrave;": 249,
  "ulcorn;": 8988,
  "ulcrop;": 8975,
  "urcorn;": 8989,
  "urcrop;": 8974,
  "utilde;": 361,
  "vangrt;": 10652,
  "varphi;": 981,
  "varrho;": 1009,
  "veebar;": 8891,
  "vellip;": 8942,
  "verbar;": 124,
  "vsubnE;": 10955,
  "vsubne;": 8842,
  "vsupnE;": 10956,
  "vsupne;": 8843,
  "wedbar;": 10847,
  "wedgeq;": 8793,
  "weierp;": 8472,
  "wreath;": 8768,
  "xoplus;": 10753,
  "xotime;": 10754,
  "xsqcup;": 10758,
  "xuplus;": 10756,
  "xwedge;": 8896,
  "yacute;": 253,
  "zacute;": 378,
  "zcaron;": 382,
  "zeetrf;": 8488,
  "AElig;": 198,
  Aacute: 193,
  "Acirc;": 194,
  Agrave: 192,
  "Alpha;": 913,
  "Amacr;": 256,
  "Aogon;": 260,
  "Aring;": 197,
  Atilde: 195,
  "Breve;": 728,
  Ccedil: 199,
  "Ccirc;": 264,
  "Colon;": 8759,
  "Cross;": 10799,
  "Dashv;": 10980,
  "Delta;": 916,
  Eacute: 201,
  "Ecirc;": 202,
  Egrave: 200,
  "Emacr;": 274,
  "Eogon;": 280,
  "Equal;": 10869,
  "Gamma;": 915,
  "Gcirc;": 284,
  "Hacek;": 711,
  "Hcirc;": 292,
  "IJlig;": 306,
  Iacute: 205,
  "Icirc;": 206,
  Igrave: 204,
  "Imacr;": 298,
  "Iogon;": 302,
  "Iukcy;": 1030,
  "Jcirc;": 308,
  "Jukcy;": 1028,
  "Kappa;": 922,
  Ntilde: 209,
  "OElig;": 338,
  Oacute: 211,
  "Ocirc;": 212,
  Ograve: 210,
  "Omacr;": 332,
  "Omega;": 937,
  Oslash: 216,
  Otilde: 213,
  "Prime;": 8243,
  "RBarr;": 10512,
  "Scirc;": 348,
  "Sigma;": 931,
  "THORN;": 222,
  "TRADE;": 8482,
  "TSHcy;": 1035,
  "Theta;": 920,
  "Tilde;": 8764,
  Uacute: 218,
  "Ubrcy;": 1038,
  "Ucirc;": 219,
  Ugrave: 217,
  "Umacr;": 362,
  "Union;": 8899,
  "Uogon;": 370,
  "UpTee;": 8869,
  "Uring;": 366,
  "VDash;": 8875,
  "Vdash;": 8873,
  "Wcirc;": 372,
  "Wedge;": 8896,
  Yacute: 221,
  "Ycirc;": 374,
  aacute: 225,
  "acirc;": 226,
  "acute;": 180,
  "aelig;": 230,
  agrave: 224,
  "aleph;": 8501,
  "alpha;": 945,
  "amacr;": 257,
  "amalg;": 10815,
  "angle;": 8736,
  "angrt;": 8735,
  "angst;": 197,
  "aogon;": 261,
  "aring;": 229,
  "asymp;": 8776,
  atilde: 227,
  "awint;": 10769,
  "bcong;": 8780,
  "bdquo;": 8222,
  "bepsi;": 1014,
  "blank;": 9251,
  "blk12;": 9618,
  "blk14;": 9617,
  "blk34;": 9619,
  "block;": 9608,
  "boxDL;": 9559,
  "boxDR;": 9556,
  "boxDl;": 9558,
  "boxDr;": 9555,
  "boxHD;": 9574,
  "boxHU;": 9577,
  "boxHd;": 9572,
  "boxHu;": 9575,
  "boxUL;": 9565,
  "boxUR;": 9562,
  "boxUl;": 9564,
  "boxUr;": 9561,
  "boxVH;": 9580,
  "boxVL;": 9571,
  "boxVR;": 9568,
  "boxVh;": 9579,
  "boxVl;": 9570,
  "boxVr;": 9567,
  "boxdL;": 9557,
  "boxdR;": 9554,
  "boxdl;": 9488,
  "boxdr;": 9484,
  "boxhD;": 9573,
  "boxhU;": 9576,
  "boxhd;": 9516,
  "boxhu;": 9524,
  "boxuL;": 9563,
  "boxuR;": 9560,
  "boxul;": 9496,
  "boxur;": 9492,
  "boxvH;": 9578,
  "boxvL;": 9569,
  "boxvR;": 9566,
  "boxvh;": 9532,
  "boxvl;": 9508,
  "boxvr;": 9500,
  "breve;": 728,
  brvbar: 166,
  "bsemi;": 8271,
  "bsime;": 8909,
  "bsolb;": 10693,
  "bumpE;": 10926,
  "bumpe;": 8783,
  "caret;": 8257,
  "caron;": 711,
  "ccaps;": 10829,
  ccedil: 231,
  "ccirc;": 265,
  "ccups;": 10828,
  "cedil;": 184,
  "check;": 10003,
  "clubs;": 9827,
  "colon;": 58,
  "comma;": 44,
  "crarr;": 8629,
  "cross;": 10007,
  "csube;": 10961,
  "csupe;": 10962,
  "ctdot;": 8943,
  "cuepr;": 8926,
  "cuesc;": 8927,
  "cupor;": 10821,
  curren: 164,
  "cuvee;": 8910,
  "cuwed;": 8911,
  "cwint;": 8753,
  "dashv;": 8867,
  "dblac;": 733,
  "ddarr;": 8650,
  "delta;": 948,
  "dharl;": 8643,
  "dharr;": 8642,
  "diams;": 9830,
  "disin;": 8946,
  divide: 247,
  "doteq;": 8784,
  "dtdot;": 8945,
  "dtrif;": 9662,
  "duarr;": 8693,
  "duhar;": 10607,
  "eDDot;": 10871,
  eacute: 233,
  "ecirc;": 234,
  "efDot;": 8786,
  egrave: 232,
  "emacr;": 275,
  "empty;": 8709,
  "eogon;": 281,
  "eplus;": 10865,
  "epsiv;": 1013,
  "eqsim;": 8770,
  "equiv;": 8801,
  "erDot;": 8787,
  "erarr;": 10609,
  "esdot;": 8784,
  "exist;": 8707,
  "fflig;": 64256,
  "filig;": 64257,
  "fjlig;": 102,
  "fllig;": 64258,
  "fltns;": 9649,
  "forkv;": 10969,
  frac12: 189,
  frac14: 188,
  frac34: 190,
  "frasl;": 8260,
  "frown;": 8994,
  "gamma;": 947,
  "gcirc;": 285,
  "gescc;": 10921,
  "gimel;": 8503,
  "gneqq;": 8809,
  "gnsim;": 8935,
  "grave;": 96,
  "gsime;": 10894,
  "gsiml;": 10896,
  "gtcir;": 10874,
  "gtdot;": 8919,
  "harrw;": 8621,
  "hcirc;": 293,
  "hoarr;": 8703,
  iacute: 237,
  "icirc;": 238,
  "iexcl;": 161,
  igrave: 236,
  "iiint;": 8749,
  "iiota;": 8489,
  "ijlig;": 307,
  "imacr;": 299,
  "image;": 8465,
  "imath;": 305,
  "imped;": 437,
  "infin;": 8734,
  "iogon;": 303,
  "iprod;": 10812,
  iquest: 191,
  "isinE;": 8953,
  "isins;": 8948,
  "isinv;": 8712,
  "iukcy;": 1110,
  "jcirc;": 309,
  "jmath;": 567,
  "jukcy;": 1108,
  "kappa;": 954,
  "lAarr;": 8666,
  "lBarr;": 10510,
  "langd;": 10641,
  "laquo;": 171,
  "larrb;": 8676,
  "lates;": 10925,
  "lbarr;": 10508,
  "lbbrk;": 10098,
  "lbrke;": 10635,
  "lceil;": 8968,
  "ldquo;": 8220,
  "lescc;": 10920,
  "lhard;": 8637,
  "lharu;": 8636,
  "lhblk;": 9604,
  "llarr;": 8647,
  "lltri;": 9722,
  "lneqq;": 8808,
  "lnsim;": 8934,
  "loang;": 10220,
  "loarr;": 8701,
  "lobrk;": 10214,
  "lopar;": 10629,
  "lrarr;": 8646,
  "lrhar;": 8651,
  "lrtri;": 8895,
  "lsime;": 10893,
  "lsimg;": 10895,
  "lsquo;": 8216,
  "ltcir;": 10873,
  "ltdot;": 8918,
  "ltrie;": 8884,
  "ltrif;": 9666,
  "mDDot;": 8762,
  "mdash;": 8212,
  "micro;": 181,
  middot: 183,
  "minus;": 8722,
  "mumap;": 8888,
  "nabla;": 8711,
  "napid;": 8779,
  "napos;": 329,
  "natur;": 9838,
  "nbump;": 8782,
  "ncong;": 8775,
  "ndash;": 8211,
  "neArr;": 8663,
  "nearr;": 8599,
  "nedot;": 8784,
  "nesim;": 8770,
  "ngeqq;": 8807,
  "ngsim;": 8821,
  "nhArr;": 8654,
  "nharr;": 8622,
  "nhpar;": 10994,
  "nlArr;": 8653,
  "nlarr;": 8602,
  "nleqq;": 8806,
  "nless;": 8814,
  "nlsim;": 8820,
  "nltri;": 8938,
  "notin;": 8713,
  "notni;": 8716,
  "npart;": 8706,
  "nprec;": 8832,
  "nrArr;": 8655,
  "nrarr;": 8603,
  "nrtri;": 8939,
  "nsime;": 8772,
  "nsmid;": 8740,
  "nspar;": 8742,
  "nsubE;": 10949,
  "nsube;": 8840,
  "nsucc;": 8833,
  "nsupE;": 10950,
  "nsupe;": 8841,
  ntilde: 241,
  "numsp;": 8199,
  "nvsim;": 8764,
  "nwArr;": 8662,
  "nwarr;": 8598,
  oacute: 243,
  "ocirc;": 244,
  "odash;": 8861,
  "oelig;": 339,
  "ofcir;": 10687,
  ograve: 242,
  "ohbar;": 10677,
  "olarr;": 8634,
  "olcir;": 10686,
  "oline;": 8254,
  "omacr;": 333,
  "omega;": 969,
  "operp;": 10681,
  "oplus;": 8853,
  "orarr;": 8635,
  "order;": 8500,
  oslash: 248,
  otilde: 245,
  "ovbar;": 9021,
  "parsl;": 11005,
  "phone;": 9742,
  "plusb;": 8862,
  "pluse;": 10866,
  plusmn: 177,
  "pound;": 163,
  "prcue;": 8828,
  "prime;": 8242,
  "prnap;": 10937,
  "prsim;": 8830,
  "quest;": 63,
  "rAarr;": 8667,
  "rBarr;": 10511,
  "radic;": 8730,
  "rangd;": 10642,
  "range;": 10661,
  "raquo;": 187,
  "rarrb;": 8677,
  "rarrc;": 10547,
  "rarrw;": 8605,
  "ratio;": 8758,
  "rbarr;": 10509,
  "rbbrk;": 10099,
  "rbrke;": 10636,
  "rceil;": 8969,
  "rdquo;": 8221,
  "reals;": 8477,
  "rhard;": 8641,
  "rharu;": 8640,
  "rlarr;": 8644,
  "rlhar;": 8652,
  "rnmid;": 10990,
  "roang;": 10221,
  "roarr;": 8702,
  "robrk;": 10215,
  "ropar;": 10630,
  "rrarr;": 8649,
  "rsquo;": 8217,
  "rtrie;": 8885,
  "rtrif;": 9656,
  "sbquo;": 8218,
  "sccue;": 8829,
  "scirc;": 349,
  "scnap;": 10938,
  "scsim;": 8831,
  "sdotb;": 8865,
  "sdote;": 10854,
  "seArr;": 8664,
  "searr;": 8600,
  "setmn;": 8726,
  "sharp;": 9839,
  "sigma;": 963,
  "simeq;": 8771,
  "simgE;": 10912,
  "simlE;": 10911,
  "simne;": 8774,
  "slarr;": 8592,
  "smile;": 8995,
  "smtes;": 10924,
  "sqcap;": 8851,
  "sqcup;": 8852,
  "sqsub;": 8847,
  "sqsup;": 8848,
  "srarr;": 8594,
  "starf;": 9733,
  "strns;": 175,
  "subnE;": 10955,
  "subne;": 8842,
  "supnE;": 10956,
  "supne;": 8843,
  "swArr;": 8665,
  "swarr;": 8601,
  "szlig;": 223,
  "theta;": 952,
  "thkap;": 8776,
  "thorn;": 254,
  "tilde;": 732,
  "times;": 215,
  "trade;": 8482,
  "trisb;": 10701,
  "tshcy;": 1115,
  "twixt;": 8812,
  uacute: 250,
  "ubrcy;": 1118,
  "ucirc;": 251,
  "udarr;": 8645,
  "udhar;": 10606,
  ugrave: 249,
  "uharl;": 8639,
  "uharr;": 8638,
  "uhblk;": 9600,
  "ultri;": 9720,
  "umacr;": 363,
  "uogon;": 371,
  "uplus;": 8846,
  "upsih;": 978,
  "uring;": 367,
  "urtri;": 9721,
  "utdot;": 8944,
  "utrif;": 9652,
  "uuarr;": 8648,
  "vBarv;": 10985,
  "vDash;": 8872,
  "varpi;": 982,
  "vdash;": 8866,
  "veeeq;": 8794,
  "vltri;": 8882,
  "vnsub;": 8834,
  "vnsup;": 8835,
  "vprop;": 8733,
  "vrtri;": 8883,
  "wcirc;": 373,
  "wedge;": 8743,
  "xcirc;": 9711,
  "xdtri;": 9661,
  "xhArr;": 10234,
  "xharr;": 10231,
  "xlArr;": 10232,
  "xlarr;": 10229,
  "xodot;": 10752,
  "xrArr;": 10233,
  "xrarr;": 10230,
  "xutri;": 9651,
  yacute: 253,
  "ycirc;": 375,
  AElig: 198,
  Acirc: 194,
  "Aopf;": 120120,
  Aring: 197,
  "Ascr;": 119964,
  "Auml;": 196,
  "Barv;": 10983,
  "Beta;": 914,
  "Bopf;": 120121,
  "Bscr;": 8492,
  "CHcy;": 1063,
  "COPY;": 169,
  "Cdot;": 266,
  "Copf;": 8450,
  "Cscr;": 119966,
  "DJcy;": 1026,
  "DScy;": 1029,
  "DZcy;": 1039,
  "Darr;": 8609,
  "Dopf;": 120123,
  "Dscr;": 119967,
  Ecirc: 202,
  "Edot;": 278,
  "Eopf;": 120124,
  "Escr;": 8496,
  "Esim;": 10867,
  "Euml;": 203,
  "Fopf;": 120125,
  "Fscr;": 8497,
  "GJcy;": 1027,
  "Gdot;": 288,
  "Gopf;": 120126,
  "Gscr;": 119970,
  "Hopf;": 8461,
  "Hscr;": 8459,
  "IEcy;": 1045,
  "IOcy;": 1025,
  Icirc: 206,
  "Idot;": 304,
  "Iopf;": 120128,
  "Iota;": 921,
  "Iscr;": 8464,
  "Iuml;": 207,
  "Jopf;": 120129,
  "Jscr;": 119973,
  "KHcy;": 1061,
  "KJcy;": 1036,
  "Kopf;": 120130,
  "Kscr;": 119974,
  "LJcy;": 1033,
  "Lang;": 10218,
  "Larr;": 8606,
  "Lopf;": 120131,
  "Lscr;": 8466,
  "Mopf;": 120132,
  "Mscr;": 8499,
  "NJcy;": 1034,
  "Nopf;": 8469,
  "Nscr;": 119977,
  Ocirc: 212,
  "Oopf;": 120134,
  "Oscr;": 119978,
  "Ouml;": 214,
  "Popf;": 8473,
  "Pscr;": 119979,
  "QUOT;": 34,
  "Qopf;": 8474,
  "Qscr;": 119980,
  "Rang;": 10219,
  "Rarr;": 8608,
  "Ropf;": 8477,
  "Rscr;": 8475,
  "SHcy;": 1064,
  "Sopf;": 120138,
  "Sqrt;": 8730,
  "Sscr;": 119982,
  "Star;": 8902,
  THORN: 222,
  "TScy;": 1062,
  "Topf;": 120139,
  "Tscr;": 119983,
  "Uarr;": 8607,
  Ucirc: 219,
  "Uopf;": 120140,
  "Upsi;": 978,
  "Uscr;": 119984,
  "Uuml;": 220,
  "Vbar;": 10987,
  "Vert;": 8214,
  "Vopf;": 120141,
  "Vscr;": 119985,
  "Wopf;": 120142,
  "Wscr;": 119986,
  "Xopf;": 120143,
  "Xscr;": 119987,
  "YAcy;": 1071,
  "YIcy;": 1031,
  "YUcy;": 1070,
  "Yopf;": 120144,
  "Yscr;": 119988,
  "Yuml;": 376,
  "ZHcy;": 1046,
  "Zdot;": 379,
  "Zeta;": 918,
  "Zopf;": 8484,
  "Zscr;": 119989,
  acirc: 226,
  acute: 180,
  aelig: 230,
  "andd;": 10844,
  "andv;": 10842,
  "ange;": 10660,
  "aopf;": 120146,
  "apid;": 8779,
  "apos;": 39,
  aring: 229,
  "ascr;": 119990,
  "auml;": 228,
  "bNot;": 10989,
  "bbrk;": 9141,
  "beta;": 946,
  "beth;": 8502,
  "bnot;": 8976,
  "bopf;": 120147,
  "boxH;": 9552,
  "boxV;": 9553,
  "boxh;": 9472,
  "boxv;": 9474,
  "bscr;": 119991,
  "bsim;": 8765,
  "bsol;": 92,
  "bull;": 8226,
  "bump;": 8782,
  "caps;": 8745,
  "cdot;": 267,
  cedil: 184,
  "cent;": 162,
  "chcy;": 1095,
  "cirE;": 10691,
  "circ;": 710,
  "cire;": 8791,
  "comp;": 8705,
  "cong;": 8773,
  "copf;": 120148,
  "copy;": 169,
  "cscr;": 119992,
  "csub;": 10959,
  "csup;": 10960,
  "cups;": 8746,
  "dArr;": 8659,
  "dHar;": 10597,
  "darr;": 8595,
  "dash;": 8208,
  "diam;": 8900,
  "djcy;": 1106,
  "dopf;": 120149,
  "dscr;": 119993,
  "dscy;": 1109,
  "dsol;": 10742,
  "dtri;": 9663,
  "dzcy;": 1119,
  "eDot;": 8785,
  "ecir;": 8790,
  ecirc: 234,
  "edot;": 279,
  "emsp;": 8195,
  "ensp;": 8194,
  "eopf;": 120150,
  "epar;": 8917,
  "epsi;": 949,
  "escr;": 8495,
  "esim;": 8770,
  "euml;": 235,
  "euro;": 8364,
  "excl;": 33,
  "flat;": 9837,
  "fnof;": 402,
  "fopf;": 120151,
  "fork;": 8916,
  "fscr;": 119995,
  "gdot;": 289,
  "geqq;": 8807,
  "gesl;": 8923,
  "gjcy;": 1107,
  "gnap;": 10890,
  "gneq;": 10888,
  "gopf;": 120152,
  "gscr;": 8458,
  "gsim;": 8819,
  "gtcc;": 10919,
  "gvnE;": 8809,
  "hArr;": 8660,
  "half;": 189,
  "harr;": 8596,
  "hbar;": 8463,
  "hopf;": 120153,
  "hscr;": 119997,
  icirc: 238,
  "iecy;": 1077,
  iexcl: 161,
  "imof;": 8887,
  "iocy;": 1105,
  "iopf;": 120154,
  "iota;": 953,
  "iscr;": 119998,
  "isin;": 8712,
  "iuml;": 239,
  "jopf;": 120155,
  "jscr;": 119999,
  "khcy;": 1093,
  "kjcy;": 1116,
  "kopf;": 120156,
  "kscr;": 12e4,
  "lArr;": 8656,
  "lHar;": 10594,
  "lang;": 10216,
  laquo: 171,
  "larr;": 8592,
  "late;": 10925,
  "lcub;": 123,
  "ldca;": 10550,
  "ldsh;": 8626,
  "leqq;": 8806,
  "lesg;": 8922,
  "ljcy;": 1113,
  "lnap;": 10889,
  "lneq;": 10887,
  "lopf;": 120157,
  "lozf;": 10731,
  "lpar;": 40,
  "lscr;": 120001,
  "lsim;": 8818,
  "lsqb;": 91,
  "ltcc;": 10918,
  "ltri;": 9667,
  "lvnE;": 8808,
  "macr;": 175,
  "male;": 9794,
  "malt;": 10016,
  micro: 181,
  "mlcp;": 10971,
  "mldr;": 8230,
  "mopf;": 120158,
  "mscr;": 120002,
  "nGtv;": 8811,
  "nLtv;": 8810,
  "nang;": 8736,
  "napE;": 10864,
  "nbsp;": 160,
  "ncap;": 10819,
  "ncup;": 10818,
  "ngeq;": 8817,
  "nges;": 10878,
  "ngtr;": 8815,
  "nisd;": 8954,
  "njcy;": 1114,
  "nldr;": 8229,
  "nleq;": 8816,
  "nles;": 10877,
  "nmid;": 8740,
  "nopf;": 120159,
  "npar;": 8742,
  "npre;": 10927,
  "nsce;": 10928,
  "nscr;": 120003,
  "nsim;": 8769,
  "nsub;": 8836,
  "nsup;": 8837,
  "ntgl;": 8825,
  "ntlg;": 8824,
  "nvap;": 8781,
  "nvge;": 8805,
  "nvgt;": 62,
  "nvle;": 8804,
  "nvlt;": 60,
  "oast;": 8859,
  "ocir;": 8858,
  ocirc: 244,
  "odiv;": 10808,
  "odot;": 8857,
  "ogon;": 731,
  "oint;": 8750,
  "omid;": 10678,
  "oopf;": 120160,
  "opar;": 10679,
  "ordf;": 170,
  "ordm;": 186,
  "oror;": 10838,
  "oscr;": 8500,
  "osol;": 8856,
  "ouml;": 246,
  "para;": 182,
  "part;": 8706,
  "perp;": 8869,
  "phiv;": 981,
  "plus;": 43,
  "popf;": 120161,
  pound: 163,
  "prap;": 10935,
  "prec;": 8826,
  "prnE;": 10933,
  "prod;": 8719,
  "prop;": 8733,
  "pscr;": 120005,
  "qint;": 10764,
  "qopf;": 120162,
  "qscr;": 120006,
  "quot;": 34,
  "rArr;": 8658,
  "rHar;": 10596,
  "race;": 8765,
  "rang;": 10217,
  raquo: 187,
  "rarr;": 8594,
  "rcub;": 125,
  "rdca;": 10551,
  "rdsh;": 8627,
  "real;": 8476,
  "rect;": 9645,
  "rhov;": 1009,
  "ring;": 730,
  "ropf;": 120163,
  "rpar;": 41,
  "rscr;": 120007,
  "rsqb;": 93,
  "rtri;": 9657,
  "scap;": 10936,
  "scnE;": 10934,
  "sdot;": 8901,
  "sect;": 167,
  "semi;": 59,
  "sext;": 10038,
  "shcy;": 1096,
  "sime;": 8771,
  "simg;": 10910,
  "siml;": 10909,
  "smid;": 8739,
  "smte;": 10924,
  "solb;": 10692,
  "sopf;": 120164,
  "spar;": 8741,
  "squf;": 9642,
  "sscr;": 120008,
  "star;": 9734,
  "subE;": 10949,
  "sube;": 8838,
  "succ;": 8827,
  "sung;": 9834,
  "sup1;": 185,
  "sup2;": 178,
  "sup3;": 179,
  "supE;": 10950,
  "supe;": 8839,
  szlig: 223,
  "tbrk;": 9140,
  "tdot;": 8411,
  thorn: 254,
  times: 215,
  "tint;": 8749,
  "toea;": 10536,
  "topf;": 120165,
  "tosa;": 10537,
  "trie;": 8796,
  "tscr;": 120009,
  "tscy;": 1094,
  "uArr;": 8657,
  "uHar;": 10595,
  "uarr;": 8593,
  ucirc: 251,
  "uopf;": 120166,
  "upsi;": 965,
  "uscr;": 120010,
  "utri;": 9653,
  "uuml;": 252,
  "vArr;": 8661,
  "vBar;": 10984,
  "varr;": 8597,
  "vert;": 124,
  "vopf;": 120167,
  "vscr;": 120011,
  "wopf;": 120168,
  "wscr;": 120012,
  "xcap;": 8898,
  "xcup;": 8899,
  "xmap;": 10236,
  "xnis;": 8955,
  "xopf;": 120169,
  "xscr;": 120013,
  "xvee;": 8897,
  "yacy;": 1103,
  "yicy;": 1111,
  "yopf;": 120170,
  "yscr;": 120014,
  "yucy;": 1102,
  "yuml;": 255,
  "zdot;": 380,
  "zeta;": 950,
  "zhcy;": 1078,
  "zopf;": 120171,
  "zscr;": 120015,
  "zwnj;": 8204,
  "AMP;": 38,
  "Acy;": 1040,
  "Afr;": 120068,
  "And;": 10835,
  Auml: 196,
  "Bcy;": 1041,
  "Bfr;": 120069,
  COPY: 169,
  "Cap;": 8914,
  "Cfr;": 8493,
  "Chi;": 935,
  "Cup;": 8915,
  "Dcy;": 1044,
  "Del;": 8711,
  "Dfr;": 120071,
  "Dot;": 168,
  "ENG;": 330,
  "ETH;": 208,
  "Ecy;": 1069,
  "Efr;": 120072,
  "Eta;": 919,
  Euml: 203,
  "Fcy;": 1060,
  "Ffr;": 120073,
  "Gcy;": 1043,
  "Gfr;": 120074,
  "Hat;": 94,
  "Hfr;": 8460,
  "Icy;": 1048,
  "Ifr;": 8465,
  "Int;": 8748,
  Iuml: 207,
  "Jcy;": 1049,
  "Jfr;": 120077,
  "Kcy;": 1050,
  "Kfr;": 120078,
  "Lcy;": 1051,
  "Lfr;": 120079,
  "Lsh;": 8624,
  "Map;": 10501,
  "Mcy;": 1052,
  "Mfr;": 120080,
  "Ncy;": 1053,
  "Nfr;": 120081,
  "Not;": 10988,
  "Ocy;": 1054,
  "Ofr;": 120082,
  Ouml: 214,
  "Pcy;": 1055,
  "Pfr;": 120083,
  "Phi;": 934,
  "Psi;": 936,
  QUOT: 34,
  "Qfr;": 120084,
  "REG;": 174,
  "Rcy;": 1056,
  "Rfr;": 8476,
  "Rho;": 929,
  "Rsh;": 8625,
  "Scy;": 1057,
  "Sfr;": 120086,
  "Sub;": 8912,
  "Sum;": 8721,
  "Sup;": 8913,
  "Tab;": 9,
  "Tau;": 932,
  "Tcy;": 1058,
  "Tfr;": 120087,
  "Ucy;": 1059,
  "Ufr;": 120088,
  Uuml: 220,
  "Vcy;": 1042,
  "Vee;": 8897,
  "Vfr;": 120089,
  "Wfr;": 120090,
  "Xfr;": 120091,
  "Ycy;": 1067,
  "Yfr;": 120092,
  "Zcy;": 1047,
  "Zfr;": 8488,
  "acE;": 8766,
  "acd;": 8767,
  "acy;": 1072,
  "afr;": 120094,
  "amp;": 38,
  "and;": 8743,
  "ang;": 8736,
  "apE;": 10864,
  "ape;": 8778,
  "ast;": 42,
  auml: 228,
  "bcy;": 1073,
  "bfr;": 120095,
  "bne;": 61,
  "bot;": 8869,
  "cap;": 8745,
  cent: 162,
  "cfr;": 120096,
  "chi;": 967,
  "cir;": 9675,
  copy: 169,
  "cup;": 8746,
  "dcy;": 1076,
  "deg;": 176,
  "dfr;": 120097,
  "die;": 168,
  "div;": 247,
  "dot;": 729,
  "ecy;": 1101,
  "efr;": 120098,
  "egs;": 10902,
  "ell;": 8467,
  "els;": 10901,
  "eng;": 331,
  "eta;": 951,
  "eth;": 240,
  euml: 235,
  "fcy;": 1092,
  "ffr;": 120099,
  "gEl;": 10892,
  "gap;": 10886,
  "gcy;": 1075,
  "gel;": 8923,
  "geq;": 8805,
  "ges;": 10878,
  "gfr;": 120100,
  "ggg;": 8921,
  "glE;": 10898,
  "gla;": 10917,
  "glj;": 10916,
  "gnE;": 8809,
  "gne;": 10888,
  "hfr;": 120101,
  "icy;": 1080,
  "iff;": 8660,
  "ifr;": 120102,
  "int;": 8747,
  iuml: 239,
  "jcy;": 1081,
  "jfr;": 120103,
  "kcy;": 1082,
  "kfr;": 120104,
  "lEg;": 10891,
  "lap;": 10885,
  "lat;": 10923,
  "lcy;": 1083,
  "leg;": 8922,
  "leq;": 8804,
  "les;": 10877,
  "lfr;": 120105,
  "lgE;": 10897,
  "lnE;": 8808,
  "lne;": 10887,
  "loz;": 9674,
  "lrm;": 8206,
  "lsh;": 8624,
  macr: 175,
  "map;": 8614,
  "mcy;": 1084,
  "mfr;": 120106,
  "mho;": 8487,
  "mid;": 8739,
  "nGg;": 8921,
  "nGt;": 8811,
  "nLl;": 8920,
  "nLt;": 8810,
  "nap;": 8777,
  nbsp: 160,
  "ncy;": 1085,
  "nfr;": 120107,
  "ngE;": 8807,
  "nge;": 8817,
  "ngt;": 8815,
  "nis;": 8956,
  "niv;": 8715,
  "nlE;": 8806,
  "nle;": 8816,
  "nlt;": 8814,
  "not;": 172,
  "npr;": 8832,
  "nsc;": 8833,
  "num;": 35,
  "ocy;": 1086,
  "ofr;": 120108,
  "ogt;": 10689,
  "ohm;": 937,
  "olt;": 10688,
  "ord;": 10845,
  ordf: 170,
  ordm: 186,
  "orv;": 10843,
  ouml: 246,
  "par;": 8741,
  para: 182,
  "pcy;": 1087,
  "pfr;": 120109,
  "phi;": 966,
  "piv;": 982,
  "prE;": 10931,
  "pre;": 10927,
  "psi;": 968,
  "qfr;": 120110,
  quot: 34,
  "rcy;": 1088,
  "reg;": 174,
  "rfr;": 120111,
  "rho;": 961,
  "rlm;": 8207,
  "rsh;": 8625,
  "scE;": 10932,
  "sce;": 10928,
  "scy;": 1089,
  sect: 167,
  "sfr;": 120112,
  "shy;": 173,
  "sim;": 8764,
  "smt;": 10922,
  "sol;": 47,
  "squ;": 9633,
  "sub;": 8834,
  "sum;": 8721,
  sup1: 185,
  sup2: 178,
  sup3: 179,
  "sup;": 8835,
  "tau;": 964,
  "tcy;": 1090,
  "tfr;": 120113,
  "top;": 8868,
  "ucy;": 1091,
  "ufr;": 120114,
  "uml;": 168,
  uuml: 252,
  "vcy;": 1074,
  "vee;": 8744,
  "vfr;": 120115,
  "wfr;": 120116,
  "xfr;": 120117,
  "ycy;": 1099,
  "yen;": 165,
  "yfr;": 120118,
  yuml: 255,
  "zcy;": 1079,
  "zfr;": 120119,
  "zwj;": 8205,
  AMP: 38,
  "DD;": 8517,
  ETH: 208,
  "GT;": 62,
  "Gg;": 8921,
  "Gt;": 8811,
  "Im;": 8465,
  "LT;": 60,
  "Ll;": 8920,
  "Lt;": 8810,
  "Mu;": 924,
  "Nu;": 925,
  "Or;": 10836,
  "Pi;": 928,
  "Pr;": 10939,
  REG: 174,
  "Re;": 8476,
  "Sc;": 10940,
  "Xi;": 926,
  "ac;": 8766,
  "af;": 8289,
  amp: 38,
  "ap;": 8776,
  "dd;": 8518,
  deg: 176,
  "ee;": 8519,
  "eg;": 10906,
  "el;": 10905,
  eth: 240,
  "gE;": 8807,
  "ge;": 8805,
  "gg;": 8811,
  "gl;": 8823,
  "gt;": 62,
  "ic;": 8291,
  "ii;": 8520,
  "in;": 8712,
  "it;": 8290,
  "lE;": 8806,
  "le;": 8804,
  "lg;": 8822,
  "ll;": 8810,
  "lt;": 60,
  "mp;": 8723,
  "mu;": 956,
  "ne;": 8800,
  "ni;": 8715,
  not: 172,
  "nu;": 957,
  "oS;": 9416,
  "or;": 8744,
  "pi;": 960,
  "pm;": 177,
  "pr;": 8826,
  reg: 174,
  "rx;": 8478,
  "sc;": 8827,
  shy: 173,
  uml: 168,
  "wp;": 8472,
  "wr;": 8768,
  "xi;": 958,
  yen: 165,
  GT: 62,
  LT: 60,
  gt: 62,
  lt: 60
};

// node_modules/svelte/src/compiler/phases/1-parse/utils/html.js
var windows_1252 = [
  8364,
  129,
  8218,
  402,
  8222,
  8230,
  8224,
  8225,
  710,
  8240,
  352,
  8249,
  338,
  141,
  381,
  143,
  144,
  8216,
  8217,
  8220,
  8221,
  8226,
  8211,
  8212,
  732,
  8482,
  353,
  8250,
  339,
  157,
  382,
  376
];
function reg_exp_entity(entity_name, is_attribute_value) {
  if (is_attribute_value && !entity_name.endsWith(";")) {
    return `${entity_name}\\b(?!=)`;
  }
  return entity_name;
}
function get_entity_pattern(is_attribute_value) {
  const reg_exp_num = "#(?:x[a-fA-F\\d]+|\\d+)(?:;)?";
  const reg_exp_entities = Object.keys(entities_default).map(
    /** @param {any} entity_name */
    (entity_name) => reg_exp_entity(entity_name, is_attribute_value)
  );
  const entity_pattern = new RegExp(`&(${reg_exp_num}|${reg_exp_entities.join("|")})`, "g");
  return entity_pattern;
}
var entity_pattern_content = get_entity_pattern(false);
var entity_pattern_attr_value = get_entity_pattern(true);
function decode_character_references(html, is_attribute_value) {
  const entity_pattern = is_attribute_value ? entity_pattern_attr_value : entity_pattern_content;
  return html.replace(
    entity_pattern,
    /**
     * @param {any} match
     * @param {keyof typeof entities} entity
     */
    (match, entity) => {
      let code;
      if (entity[0] !== "#") {
        code = entities_default[entity];
      } else if (entity[1] === "x") {
        code = parseInt(entity.substring(2), 16);
      } else {
        code = parseInt(entity.substring(1), 10);
      }
      if (!code) {
        return match;
      }
      return String.fromCodePoint(validate_code(code));
    }
  );
}
var NUL = 0;
function validate_code(code) {
  if (code === 10) {
    return 32;
  }
  if (code < 128) {
    return code;
  }
  if (code <= 159) {
    return windows_1252[code - 128];
  }
  if (code < 55296) {
    return code;
  }
  if (code <= 57343) {
    return NUL;
  }
  if (code <= 65535) {
    return code;
  }
  if (code >= 65536 && code <= 131071) {
    return code;
  }
  if (code >= 131072 && code <= 196607) {
    return code;
  }
  if (code >= 917504 && code <= 917631 || code >= 917760 && code <= 917999) {
    return code;
  }
  return NUL;
}

// node_modules/svelte/src/compiler/phases/1-parse/utils/create.js
function create_fragment(transparent = false) {
  return {
    type: "Fragment",
    nodes: [],
    metadata: {
      transparent,
      dynamic: false
    }
  };
}

// node_modules/svelte/src/compiler/phases/nodes.js
var element_nodes = [
  "SvelteElement",
  "RegularElement",
  "SvelteFragment",
  "Component",
  "SvelteComponent",
  "SvelteSelf",
  "SlotElement"
];
function is_element_node(node) {
  return element_nodes.includes(node.type);
}
function is_custom_element_node(node) {
  return node.type === "RegularElement" && (node.name.includes("-") || node.attributes.some((attr) => attr.type === "Attribute" && attr.name === "is"));
}
function create_attribute(name, start, end, value) {
  return {
    type: "Attribute",
    start,
    end,
    name,
    value,
    metadata: {
      delegated: null,
      needs_clsx: false
    }
  };
}
function create_expression_metadata() {
  return {
    dependencies: /* @__PURE__ */ new Set(),
    has_state: false,
    has_call: false
  };
}
function get_name(node) {
  if (node.type === "Literal") return String(node.value);
  if (node.type === "PrivateIdentifier") return "#" + node.name;
  if (node.type === "Identifier") return node.name;
  return null;
}

// node_modules/svelte/src/html-tree-validation.js
var autoclosing_children = {
  // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
  li: { direct: ["li"] },
  // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dt#technical_summary
  dt: { descendant: ["dt", "dd"], reset_by: ["dl"] },
  dd: { descendant: ["dt", "dd"], reset_by: ["dl"] },
  p: {
    descendant: [
      "address",
      "article",
      "aside",
      "blockquote",
      "div",
      "dl",
      "fieldset",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "hr",
      "main",
      "menu",
      "nav",
      "ol",
      "p",
      "pre",
      "section",
      "table",
      "ul"
    ]
  },
  rt: { descendant: ["rt", "rp"] },
  rp: { descendant: ["rt", "rp"] },
  optgroup: { descendant: ["optgroup"] },
  option: { descendant: ["option", "optgroup"] },
  thead: { direct: ["tbody", "tfoot"] },
  tbody: { direct: ["tbody", "tfoot"] },
  tfoot: { direct: ["tbody"] },
  tr: { direct: ["tr", "tbody"] },
  td: { direct: ["td", "th", "tr"] },
  th: { direct: ["td", "th", "tr"] }
};
function closing_tag_omitted(current2, next2) {
  const disallowed = autoclosing_children[current2];
  if (disallowed) {
    if (!next2 || ("direct" in disallowed ? disallowed.direct : disallowed.descendant).includes(next2)) {
      return true;
    }
  }
  return false;
}
var disallowed_children = {
  ...autoclosing_children,
  optgroup: { only: ["option", "#text"] },
  // Strictly speaking, seeing an <option> doesn't mean we're in a <select>, but we assume it here
  option: { only: ["#text"] },
  form: { descendant: ["form"] },
  a: { descendant: ["a"] },
  button: { descendant: ["button"] },
  h1: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  h2: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  h3: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  h4: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  h5: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  h6: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
  select: { only: ["option", "optgroup", "#text", "hr", "script", "template"] },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
  // No special behavior since these rules fall back to "in body" mode for
  // all except special table nodes which cause bad parsing behavior anyway.
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
  tr: { only: ["th", "td", "style", "script", "template"] },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
  tbody: { only: ["tr", "style", "script", "template"] },
  thead: { only: ["tr", "style", "script", "template"] },
  tfoot: { only: ["tr", "style", "script", "template"] },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
  colgroup: { only: ["col", "template"] },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
  table: {
    only: ["caption", "colgroup", "tbody", "thead", "tfoot", "style", "script", "template"]
  },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
  head: {
    only: [
      "base",
      "basefont",
      "bgsound",
      "link",
      "meta",
      "title",
      "noscript",
      "noframes",
      "style",
      "script",
      "template"
    ]
  },
  // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
  html: { only: ["head", "body", "frameset"] },
  frameset: { only: ["frame"] },
  "#document": { only: ["html"] }
};
function is_tag_valid_with_ancestor(child_tag, ancestors, child_loc, ancestor_loc) {
  if (child_tag.includes("-")) return null;
  const ancestor_tag = ancestors[ancestors.length - 1];
  const disallowed = disallowed_children[ancestor_tag];
  if (!disallowed) return null;
  if ("reset_by" in disallowed && disallowed.reset_by) {
    for (let i = ancestors.length - 2; i >= 0; i--) {
      const ancestor = ancestors[i];
      if (ancestor.includes("-")) return null;
      if (disallowed.reset_by.includes(ancestors[i])) {
        return null;
      }
    }
  }
  if ("descendant" in disallowed && disallowed.descendant.includes(child_tag)) {
    const child = child_loc ? `\`<${child_tag}>\` (${child_loc})` : `\`<${child_tag}>\``;
    const ancestor = ancestor_loc ? `\`<${ancestor_tag}>\` (${ancestor_loc})` : `\`<${ancestor_tag}>\``;
    return `${child} cannot be a descendant of ${ancestor}`;
  }
  return null;
}
function is_tag_valid_with_parent(child_tag, parent_tag, child_loc, parent_loc) {
  if (child_tag.includes("-") || (parent_tag == null ? void 0 : parent_tag.includes("-"))) return null;
  if (parent_tag === "template") return null;
  const disallowed = disallowed_children[parent_tag];
  const child = child_loc ? `\`<${child_tag}>\` (${child_loc})` : `\`<${child_tag}>\``;
  const parent = parent_loc ? `\`<${parent_tag}>\` (${parent_loc})` : `\`<${parent_tag}>\``;
  if (disallowed) {
    if ("direct" in disallowed && disallowed.direct.includes(child_tag)) {
      return `${child} cannot be a direct child of ${parent}`;
    }
    if ("descendant" in disallowed && disallowed.descendant.includes(child_tag)) {
      return `${child} cannot be a child of ${parent}`;
    }
    if ("only" in disallowed && disallowed.only) {
      if (disallowed.only.includes(child_tag)) {
        return null;
      } else {
        return `${child} cannot be a child of ${parent}. \`<${parent_tag}>\` only allows these children: ${disallowed.only.map((d) => `\`<${d}>\``).join(", ")}`;
      }
    }
  }
  switch (child_tag) {
    case "body":
    case "caption":
    case "col":
    case "colgroup":
    case "frameset":
    case "frame":
    case "head":
    case "html":
      return `${child} cannot be a child of ${parent}`;
    case "thead":
    case "tbody":
    case "tfoot":
      return `${child} must be the child of a \`<table>\`, not a ${parent}`;
    case "td":
    case "th":
      return `${child} must be the child of a \`<tr>\`, not a ${parent}`;
    case "tr":
      return `\`<tr>\` must be the child of a \`<thead>\`, \`<tbody>\`, or \`<tfoot>\`, not a ${parent}`;
  }
  return null;
}

// node_modules/svelte/src/compiler/utils/string.js
function list(strings, conjunction = "or") {
  if (strings.length === 1) return strings[0];
  if (strings.length === 2) return `${strings[0]} ${conjunction} ${strings[1]}`;
  return `${strings.slice(0, -1).join(", ")} ${conjunction} ${strings[strings.length - 1]}`;
}

// node_modules/svelte/src/compiler/phases/1-parse/state/element.js
var regex_invalid_unquoted_attribute_value = /^(\/>|[\s"'=<>`])/;
var regex_closing_textarea_tag = /^<\/textarea(\s[^>]*)?>/i;
var regex_closing_comment = /-->/;
var regex_whitespace_or_slash_or_closing_tag = /(\s|\/|>)/;
var regex_token_ending_character = /[\s=/>"']/;
var regex_starts_with_quote_characters = /^["']/;
var regex_attribute_value = /^(?:"([^"]*)"|'([^'])*'|([^>\s]+))/;
var regex_valid_element_name = /^(?:![a-zA-Z]+|[a-zA-Z](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?|[a-zA-Z][a-zA-Z0-9]*:[a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])$/;
var regex_valid_component_name = (
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers adjusted for our needs
  // (must start with uppercase letter if no dots, can contain dots)
  new RegExp("^(?:\\p{Lu}[$\\u200c\\u200d\\p{ID_Continue}.]*|\\p{ID_Start}[$\\u200c\\u200d\\p{ID_Continue}]*(?:\\.[$\\u200c\\u200d\\p{ID_Continue}]+)+)$", "u")
);
var root_only_meta_tags = /* @__PURE__ */ new Map([
  ["svelte:head", "SvelteHead"],
  ["svelte:options", "SvelteOptions"],
  ["svelte:window", "SvelteWindow"],
  ["svelte:document", "SvelteDocument"],
  ["svelte:body", "SvelteBody"]
]);
var meta_tags = new Map([
  ...root_only_meta_tags,
  ["svelte:element", "SvelteElement"],
  ["svelte:component", "SvelteComponent"],
  ["svelte:self", "SvelteSelf"],
  ["svelte:fragment", "SvelteFragment"],
  ["svelte:boundary", "SvelteBoundary"]
]);
function element(parser) {
  var _a2, _b;
  const start = parser.index++;
  let parent = parser.current();
  if (parser.eat("!--")) {
    const data2 = parser.read_until(regex_closing_comment);
    parser.eat("-->", true);
    parser.append({
      type: "Comment",
      start,
      end: parser.index,
      data: data2
    });
    return;
  }
  const is_closing_tag = parser.eat("/");
  const name = parser.read_until(regex_whitespace_or_slash_or_closing_tag);
  if (is_closing_tag) {
    parser.allow_whitespace();
    parser.eat(">", true);
    if (is_void(name)) {
      void_element_invalid_content(start);
    }
    while (
      /** @type {AST.RegularElement} */
      parent.name !== name
    ) {
      if (parser.loose) {
        if (is_element_node(parent)) {
          const last = parent.attributes.at(-1);
          if ((last == null ? void 0 : last.type) === "Attribute" && last.name === `<${name}`) {
            parser.index = last.start;
            parent.attributes.pop();
            break;
          }
        }
      }
      if (parent.type === "RegularElement") {
        if (!parser.last_auto_closed_tag || parser.last_auto_closed_tag.tag !== name) {
          const end = ((_a2 = parent.fragment.nodes[0]) == null ? void 0 : _a2.start) ?? start;
          element_implicitly_closed(
            { start: parent.start, end },
            `</${name}>`,
            `</${parent.name}>`
          );
        }
      } else if (!parser.loose) {
        if (parser.last_auto_closed_tag && parser.last_auto_closed_tag.tag === name) {
          element_invalid_closing_tag_autoclosed(start, name, parser.last_auto_closed_tag.reason);
        } else {
          element_invalid_closing_tag(start, name);
        }
      }
      parent.end = start;
      parser.pop();
      parent = parser.current();
    }
    parent.end = parser.index;
    parser.pop();
    if (parser.last_auto_closed_tag && parser.stack.length < parser.last_auto_closed_tag.depth) {
      parser.last_auto_closed_tag = void 0;
    }
    return;
  }
  if (name.startsWith("svelte:") && !meta_tags.has(name)) {
    const bounds = { start: start + 1, end: start + 1 + name.length };
    svelte_meta_invalid_tag(bounds, list(Array.from(meta_tags.keys())));
  }
  if (!regex_valid_element_name.test(name) && !regex_valid_component_name.test(name)) {
    if (!parser.loose || !name.endsWith(".")) {
      const bounds = { start: start + 1, end: start + 1 + name.length };
      tag_invalid_name(bounds);
    }
  }
  if (root_only_meta_tags.has(name)) {
    if (name in parser.meta_tags) {
      svelte_meta_duplicate(start, name);
    }
    if (parent.type !== "Root") {
      svelte_meta_invalid_placement(start, name);
    }
    parser.meta_tags[name] = true;
  }
  const type = meta_tags.has(name) ? meta_tags.get(name) : regex_valid_component_name.test(name) || parser.loose && name.endsWith(".") ? "Component" : name === "title" && parent_is_head(parser.stack) ? "TitleElement" : (
    // TODO Svelte 6/7: once slots are removed in favor of snippets, always keep slot as a regular element
    name === "slot" && !parent_is_shadowroot_template(parser.stack) ? "SlotElement" : "RegularElement"
  );
  const element2 = type === "RegularElement" ? {
    type,
    start,
    end: -1,
    name,
    attributes: [],
    fragment: create_fragment(true),
    metadata: {
      svg: false,
      mathml: false,
      scoped: false,
      has_spread: false,
      path: []
    }
  } : (
    /** @type {AST.ElementLike} */
    {
      type,
      start,
      end: -1,
      name,
      attributes: [],
      fragment: create_fragment(true),
      metadata: {
        // unpopulated at first, differs between types
      }
    }
  );
  parser.allow_whitespace();
  if (parent.type === "RegularElement" && closing_tag_omitted(parent.name, name)) {
    const end = ((_b = parent.fragment.nodes[0]) == null ? void 0 : _b.start) ?? start;
    element_implicitly_closed({ start: parent.start, end }, `<${name}>`, `</${parent.name}>`);
    parent.end = start;
    parser.pop();
    parser.last_auto_closed_tag = {
      tag: parent.name,
      reason: name,
      depth: parser.stack.length
    };
  }
  const unique_names = [];
  const current2 = parser.current();
  const is_top_level_script_or_style = (name === "script" || name === "style") && current2.type === "Root";
  const read = is_top_level_script_or_style ? read_static_attribute : read_attribute;
  let attribute;
  while (attribute = read(parser)) {
    if (attribute.type === "Attribute" || attribute.type === "BindDirective" || attribute.type === "StyleDirective" || attribute.type === "ClassDirective") {
      const type2 = attribute.type === "BindDirective" ? "Attribute" : attribute.type;
      if (unique_names.includes(type2 + attribute.name)) {
        attribute_duplicate(attribute);
      } else if (attribute.name !== "this") {
        unique_names.push(type2 + attribute.name);
      }
    }
    element2.attributes.push(attribute);
    parser.allow_whitespace();
  }
  if (element2.type === "SvelteComponent") {
    const index = element2.attributes.findIndex(
      /** @param {any} attr */
      (attr) => attr.type === "Attribute" && attr.name === "this"
    );
    if (index === -1) {
      svelte_component_missing_this(start);
    }
    const definition = (
      /** @type {AST.Attribute} */
      element2.attributes.splice(index, 1)[0]
    );
    if (!is_expression_attribute(definition)) {
      svelte_component_invalid_this(definition.start);
    }
    element2.expression = get_attribute_expression(definition);
  }
  if (element2.type === "SvelteElement") {
    const index = element2.attributes.findIndex(
      /** @param {any} attr */
      (attr) => attr.type === "Attribute" && attr.name === "this"
    );
    if (index === -1) {
      svelte_element_missing_this(start);
    }
    const definition = (
      /** @type {AST.Attribute} */
      element2.attributes.splice(index, 1)[0]
    );
    if (definition.value === true) {
      svelte_element_missing_this(definition);
    }
    if (!is_expression_attribute(definition)) {
      svelte_element_invalid_this(definition);
      const chunk = (
        /** @type {Array<AST.ExpressionTag | AST.Text>} */
        definition.value[0]
      );
      element2.tag = chunk.type === "Text" ? {
        type: "Literal",
        value: chunk.data,
        raw: `'${chunk.raw}'`,
        start: chunk.start,
        end: chunk.end
      } : chunk.expression;
    } else {
      element2.tag = get_attribute_expression(definition);
    }
  }
  if (is_top_level_script_or_style) {
    parser.eat(">", true);
    let prev_comment = null;
    for (let i = current2.fragment.nodes.length - 1; i >= 0; i--) {
      const node = current2.fragment.nodes[i];
      if (i === current2.fragment.nodes.length - 1 && node.end !== start) {
        break;
      }
      if (node.type === "Comment") {
        prev_comment = node;
        break;
      } else if (node.type !== "Text" || node.data.trim()) {
        break;
      }
    }
    if (name === "script") {
      const content = read_script(parser, start, element2.attributes);
      if (prev_comment) {
        content.content.leadingComments = [{ type: "Line", value: prev_comment.data }];
      }
      if (content.context === "module") {
        if (current2.module) script_duplicate(start);
        current2.module = content;
      } else {
        if (current2.instance) script_duplicate(start);
        current2.instance = content;
      }
    } else {
      const content = read_style(parser, start, element2.attributes);
      content.content.comment = prev_comment;
      if (current2.css) style_duplicate(start);
      current2.css = content;
    }
    return;
  }
  parser.append(element2);
  const self_closing = parser.eat("/") || is_void(name);
  const closed = parser.eat(">", true, false);
  if (!closed) {
    const last = element2.attributes.at(-1);
    if ((last == null ? void 0 : last.type) === "Attribute" && last.name === "<") {
      parser.index = last.start;
      element2.attributes.pop();
    } else {
      const prev_1 = parser.template[parser.index - 1];
      const prev_2 = parser.template[parser.index - 2];
      const current3 = parser.template[parser.index];
      if (prev_2 === "{" && prev_1 === "/") {
        parser.index -= 2;
      } else if (prev_1 === "{" && (current3 === "#" || current3 === "@" || current3 === ":")) {
        parser.index -= 1;
      } else {
        parser.allow_whitespace();
        if (parser.index === parser.template.length) {
          while (parser.index < parser.template_untrimmed.length && regex_whitespace.test(parser.template_untrimmed[parser.index])) {
            parser.index++;
          }
        }
      }
    }
  }
  if (self_closing || !closed) {
    element2.end = parser.index;
  } else if (name === "textarea") {
    element2.fragment.nodes = read_sequence(
      parser,
      () => regex_closing_textarea_tag.test(parser.template.slice(parser.index)),
      "inside <textarea>"
    );
    parser.read(regex_closing_textarea_tag);
    element2.end = parser.index;
  } else if (name === "script" || name === "style") {
    const start2 = parser.index;
    const data2 = parser.read_until(new RegExp(`</${name}>`));
    const end = parser.index;
    const node = {
      start: start2,
      end,
      type: "Text",
      data: data2,
      raw: data2
    };
    element2.fragment.nodes.push(node);
    parser.eat(`</${name}>`, true);
    element2.end = parser.index;
  } else {
    parser.stack.push(element2);
    parser.fragments.push(element2.fragment);
  }
}
function parent_is_head(stack) {
  let i = stack.length;
  while (i--) {
    const { type } = stack[i];
    if (type === "SvelteHead") return true;
    if (type === "RegularElement" || type === "Component") return false;
  }
  return false;
}
function parent_is_shadowroot_template(stack) {
  let i = stack.length;
  while (i--) {
    if (stack[i].type === "RegularElement" && /** @type {AST.RegularElement} */
    stack[i].attributes.some(
      (a) => a.type === "Attribute" && a.name === "shadowrootmode"
    )) {
      return true;
    }
  }
  return false;
}
function read_static_attribute(parser) {
  const start = parser.index;
  const name = parser.read_until(regex_token_ending_character);
  if (!name) return null;
  let value = true;
  if (parser.eat("=")) {
    parser.allow_whitespace();
    let raw = parser.match_regex(regex_attribute_value);
    if (!raw) {
      expected_attribute_value(parser.index);
    }
    parser.index += raw.length;
    const quoted = raw[0] === '"' || raw[0] === "'";
    if (quoted) {
      raw = raw.slice(1, -1);
    }
    value = [
      {
        start: parser.index - raw.length - (quoted ? 1 : 0),
        end: quoted ? parser.index - 1 : parser.index,
        type: "Text",
        raw,
        data: decode_character_references(raw, true)
      }
    ];
  }
  if (parser.match_regex(regex_starts_with_quote_characters)) {
    expected_token(parser.index, "=");
  }
  return create_attribute(name, start, parser.index, value);
}
function read_attribute(parser) {
  const start = parser.index;
  if (parser.eat("{")) {
    parser.allow_whitespace();
    if (parser.eat("@attach")) {
      parser.require_whitespace();
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      const attachment = {
        type: "AttachTag",
        start,
        end: parser.index,
        expression,
        metadata: {
          expression: create_expression_metadata()
        }
      };
      return attachment;
    }
    if (parser.eat("...")) {
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      const spread2 = {
        type: "SpreadAttribute",
        start,
        end: parser.index,
        expression,
        metadata: {
          expression: create_expression_metadata()
        }
      };
      return spread2;
    } else {
      const value_start = parser.index;
      let name2 = parser.read_identifier();
      if (name2 === null) {
        if (parser.loose && (parser.match("#") || parser.match("/") || parser.match("@") || parser.match(":"))) {
          return null;
        } else if (parser.loose && parser.match("}")) {
          name2 = "";
        } else {
          attribute_empty_shorthand(start);
        }
      }
      parser.allow_whitespace();
      parser.eat("}", true);
      const expression = {
        type: "ExpressionTag",
        start: value_start,
        end: value_start + name2.length,
        expression: {
          start: value_start,
          end: value_start + name2.length,
          type: "Identifier",
          name: name2
        },
        metadata: {
          expression: create_expression_metadata()
        }
      };
      return create_attribute(name2, start, parser.index, expression);
    }
  }
  const name = parser.read_until(regex_token_ending_character);
  if (!name) return null;
  let end = parser.index;
  parser.allow_whitespace();
  const colon_index = name.indexOf(":");
  const type = colon_index !== -1 && get_directive_type(name.slice(0, colon_index));
  let value = true;
  if (parser.eat("=")) {
    parser.allow_whitespace();
    if (parser.template[parser.index] === "/" && parser.template[parser.index + 1] === ">") {
      const char_start = parser.index;
      parser.index++;
      value = [
        {
          start: char_start,
          end: char_start + 1,
          type: "Text",
          raw: "/",
          data: "/"
        }
      ];
      end = parser.index;
    } else {
      value = read_attribute_value2(parser);
      end = parser.index;
    }
  } else if (parser.match_regex(regex_starts_with_quote_characters)) {
    expected_token(parser.index, "=");
  }
  if (type) {
    const [directive_name, ...modifiers2] = name.slice(colon_index + 1).split("|");
    if (directive_name === "") {
      directive_missing_name({ start, end: start + colon_index + 1 }, name);
    }
    if (type === "StyleDirective") {
      return {
        start,
        end,
        type,
        name: directive_name,
        modifiers: (
          /** @type {Array<'important'>} */
          modifiers2
        ),
        value,
        metadata: {
          expression: create_expression_metadata()
        }
      };
    }
    const first_value = value === true ? void 0 : Array.isArray(value) ? value[0] : value;
    let expression = null;
    if (first_value) {
      const attribute_contains_text = (
        /** @type {any[]} */
        value.length > 1 || first_value.type === "Text"
      );
      if (attribute_contains_text) {
        directive_invalid_value(
          /** @type {number} */
          first_value.start
        );
      } else {
        expression = first_value.expression;
      }
    }
    const directive = {
      start,
      end,
      type,
      name: directive_name,
      expression,
      metadata: {
        expression: create_expression_metadata()
      }
    };
    directive.modifiers = modifiers2;
    if (directive.type === "TransitionDirective") {
      const direction = name.slice(0, colon_index);
      directive.intro = direction === "in" || direction === "transition";
      directive.outro = direction === "out" || direction === "transition";
    }
    if ((directive.type === "BindDirective" || directive.type === "ClassDirective") && !directive.expression) {
      directive.expression = /** @type {any} */
      {
        start: start + colon_index + 1,
        end,
        type: "Identifier",
        name: directive.name
      };
    }
    return directive;
  }
  return create_attribute(name, start, end, value);
}
function get_directive_type(name) {
  if (name === "use") return "UseDirective";
  if (name === "animate") return "AnimateDirective";
  if (name === "bind") return "BindDirective";
  if (name === "class") return "ClassDirective";
  if (name === "style") return "StyleDirective";
  if (name === "on") return "OnDirective";
  if (name === "let") return "LetDirective";
  if (name === "in" || name === "out" || name === "transition") return "TransitionDirective";
  return false;
}
function read_attribute_value2(parser) {
  var _a2;
  const quote_mark = parser.eat("'") ? "'" : parser.eat('"') ? '"' : null;
  if (quote_mark && parser.eat(quote_mark)) {
    return [
      {
        start: parser.index - 1,
        end: parser.index - 1,
        type: "Text",
        raw: "",
        data: ""
      }
    ];
  }
  let value;
  try {
    value = read_sequence(
      parser,
      () => {
        if (quote_mark) return parser.match(quote_mark);
        return !!parser.match_regex(regex_invalid_unquoted_attribute_value);
      },
      "in attribute value"
    );
  } catch (error) {
    if (error.code === "js_parse_error") {
      const pos = (_a2 = error.position) == null ? void 0 : _a2[0];
      if (pos !== void 0 && parser.template.slice(pos - 1, pos + 1) === "/>") {
        parser.index = pos;
        expected_token(pos, quote_mark || "}");
      }
    }
    throw error;
  }
  if (value.length === 0 && !quote_mark) {
    expected_attribute_value(parser.index);
  }
  if (quote_mark) parser.index += 1;
  if (quote_mark || value.length > 1 || value[0].type === "Text") {
    return value;
  } else {
    return value[0];
  }
}
function read_sequence(parser, done, location) {
  let current_chunk = {
    start: parser.index,
    end: -1,
    type: "Text",
    raw: "",
    data: ""
  };
  const chunks = [];
  function flush(end) {
    if (current_chunk.raw) {
      current_chunk.data = decode_character_references(current_chunk.raw, true);
      current_chunk.end = end;
      chunks.push(current_chunk);
    }
  }
  while (parser.index < parser.template.length) {
    const index = parser.index;
    if (done()) {
      flush(parser.index);
      return chunks;
    } else if (parser.eat("{")) {
      if (parser.match("#")) {
        const index2 = parser.index - 1;
        parser.eat("#");
        const name = parser.read_until(/[^a-z]/);
        block_invalid_placement(index2, name, location);
      } else if (parser.match("@")) {
        const index2 = parser.index - 1;
        parser.eat("@");
        const name = parser.read_until(/[^a-z]/);
        tag_invalid_placement(index2, name, location);
      }
      flush(parser.index - 1);
      parser.allow_whitespace();
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      const chunk = {
        type: "ExpressionTag",
        start: index,
        end: parser.index,
        expression,
        metadata: {
          expression: create_expression_metadata()
        }
      };
      chunks.push(chunk);
      current_chunk = {
        start: parser.index,
        end: -1,
        type: "Text",
        raw: "",
        data: ""
      };
    } else {
      current_chunk.raw += parser.template[parser.index++];
    }
  }
  if (parser.loose) {
    return chunks;
  } else {
    unexpected_eof(parser.template.length);
  }
}

// node_modules/svelte/src/compiler/phases/1-parse/read/context.js
function read_pattern(parser) {
  const start = parser.index;
  let i = parser.index;
  const name = parser.read_identifier();
  if (name !== null) {
    const annotation = read_type_annotation(parser);
    return {
      type: "Identifier",
      name,
      start,
      loc: {
        start: (
          /** @type {Location} */
          locator(start)
        ),
        end: (
          /** @type {Location} */
          locator(parser.index)
        )
      },
      end: parser.index,
      typeAnnotation: annotation
    };
  }
  const char = parser.template[i];
  if (char !== "{" && char !== "[") {
    expected_pattern(i);
  }
  i = match_bracket(parser, start);
  parser.index = i;
  const pattern_string = parser.template.slice(start, i);
  try {
    let space_with_newline = parser.template.slice(0, start).replace(regex_not_newline_characters, " ");
    const first_space = space_with_newline.indexOf(" ");
    space_with_newline = space_with_newline.slice(0, first_space) + space_with_newline.slice(first_space + 1);
    const expression = (
      /** @type {any} */
      parse_expression_at(`${space_with_newline}(${pattern_string} = 1)`, parser.ts, start - 1).left
    );
    expression.typeAnnotation = read_type_annotation(parser);
    if (expression.typeAnnotation) {
      expression.end = expression.typeAnnotation.end;
    }
    return expression;
  } catch (error) {
    parser.acorn_error(error);
  }
}
function read_type_annotation(parser) {
  const start = parser.index;
  parser.allow_whitespace();
  if (!parser.eat(":")) {
    parser.index = start;
    return void 0;
  }
  const insert = "_ as ";
  let a = parser.index - insert.length;
  const template2 = parser.template.slice(0, a).replace(/[^\n]/g, " ") + insert + // If this is a type annotation for a function parameter, Acorn-TS will treat subsequent
  // parameters as part of a sequence expression instead, and will then error on optional
  // parameters (`?:`). Therefore replace that sequence with something that will not error.
  parser.template.slice(parser.index).replace(/\?\s*:/g, ":");
  let expression = parse_expression_at(template2, parser.ts, a);
  if (expression.type === "AssignmentExpression") {
    let b = expression.right.start;
    while (template2[b] !== "=") b -= 1;
    expression = parse_expression_at(template2.slice(0, b), parser.ts, a);
  }
  if (expression.type === "SequenceExpression") {
    expression = expression.expressions[0];
  }
  parser.index = /** @type {number} */
  expression.end;
  return {
    type: "TSTypeAnnotation",
    start,
    end: parser.index,
    typeAnnotation: (
      /** @type {any} */
      expression.typeAnnotation
    )
  };
}

// node_modules/svelte/src/compiler/phases/1-parse/state/tag.js
var regex_whitespace_with_closing_curly_brace = /^\s*}/;
var pointy_bois = { "<": ">" };
function tag(parser) {
  const start = parser.index;
  parser.index += 1;
  parser.allow_whitespace();
  if (parser.eat("#")) return open(parser);
  if (parser.eat(":")) return next(parser);
  if (parser.eat("@")) return special(parser);
  if (parser.match("/")) {
    if (!parser.match("/*") && !parser.match("//")) {
      parser.eat("/");
      return close(parser);
    }
  }
  const expression = read_expression(parser);
  parser.allow_whitespace();
  parser.eat("}", true);
  parser.append({
    type: "ExpressionTag",
    start,
    end: parser.index,
    expression,
    metadata: {
      expression: create_expression_metadata()
    }
  });
}
function open(parser) {
  let start = parser.index - 2;
  while (parser.template[start] !== "{") start -= 1;
  if (parser.eat("if")) {
    parser.require_whitespace();
    const block2 = parser.append({
      type: "IfBlock",
      elseif: false,
      start,
      end: -1,
      test: read_expression(parser),
      consequent: create_fragment(),
      alternate: null
    });
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.stack.push(block2);
    parser.fragments.push(block2.consequent);
    return;
  }
  if (parser.eat("each")) {
    parser.require_whitespace();
    const template2 = parser.template;
    let end = parser.template.length;
    let expression;
    while (!expression) {
      try {
        expression = read_expression(parser, void 0, true);
      } catch (err) {
        end = /** @type {any} */
        err.position[0] - 2;
        while (end > start && parser.template.slice(end, end + 2) !== "as") {
          end -= 1;
        }
        if (end <= start) {
          if (parser.loose) {
            expression = get_loose_identifier(parser);
            if (expression) {
              break;
            }
          }
          throw err;
        }
        parser.template = template2.slice(0, end);
      }
    }
    parser.template = template2;
    parser.allow_whitespace();
    if (!parser.match("as")) {
      if (expression.type === "SequenceExpression") {
        expression = expression.expressions[0];
      }
      let assertion = null;
      let end2 = expression.end;
      expression = walk(expression, null, {
        // @ts-expect-error
        TSAsExpression(node, context2) {
          if (node.end === /** @type {Expression} */
          expression.end) {
            assertion = node;
            end2 = node.expression.end;
            return node.expression;
          }
          context2.next();
        }
      });
      expression.end = end2;
      if (assertion) {
        let end3 = (
          /** @type {any} */
          /** @type {any} */
          assertion.typeAnnotation.start - 2
        );
        while (parser.template.slice(end3, end3 + 2) !== "as") end3 -= 1;
        parser.index = end3;
      }
    }
    let context = null;
    let index;
    let key2;
    if (parser.eat("as")) {
      parser.require_whitespace();
      context = read_pattern(parser);
    } else {
      parser.index = /** @type {number} */
      expression.end;
    }
    parser.allow_whitespace();
    if (parser.eat(",")) {
      parser.allow_whitespace();
      index = parser.read_identifier();
      if (!index) {
        expected_identifier(parser.index);
      }
      parser.allow_whitespace();
    }
    if (parser.eat("(")) {
      parser.allow_whitespace();
      key2 = read_expression(parser, "(");
      parser.allow_whitespace();
      parser.eat(")", true);
      parser.allow_whitespace();
    }
    const matches = parser.eat("}", true, false);
    if (!matches) {
      if (parser.template.slice(parser.index - 4, parser.index) === " as ") {
        const prev_index = parser.index;
        context = read_pattern(parser);
        parser.eat("}", true);
        expression = {
          type: "Identifier",
          name: "",
          start: expression.start,
          end: prev_index - 4
        };
      } else {
        parser.eat("}", true);
      }
    }
    const block2 = parser.append({
      type: "EachBlock",
      start,
      end: -1,
      expression,
      body: create_fragment(),
      context,
      index,
      key: key2,
      metadata: (
        /** @type {any} */
        null
      )
      // filled in later
    });
    parser.stack.push(block2);
    parser.fragments.push(block2.body);
    return;
  }
  if (parser.eat("await")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    parser.allow_whitespace();
    const block2 = parser.append({
      type: "AwaitBlock",
      start,
      end: -1,
      expression,
      value: null,
      error: null,
      pending: null,
      then: null,
      catch: null
    });
    if (parser.eat("then")) {
      if (parser.match_regex(regex_whitespace_with_closing_curly_brace)) {
        parser.allow_whitespace();
      } else {
        parser.require_whitespace();
        block2.value = read_pattern(parser);
        parser.allow_whitespace();
      }
      block2.then = create_fragment();
      parser.fragments.push(block2.then);
    } else if (parser.eat("catch")) {
      if (parser.match_regex(regex_whitespace_with_closing_curly_brace)) {
        parser.allow_whitespace();
      } else {
        parser.require_whitespace();
        block2.error = read_pattern(parser);
        parser.allow_whitespace();
      }
      block2.catch = create_fragment();
      parser.fragments.push(block2.catch);
    } else {
      block2.pending = create_fragment();
      parser.fragments.push(block2.pending);
    }
    const matches = parser.eat("}", true, false);
    if (!matches) {
      if (parser.template.slice(parser.index - 6, parser.index) === " then ") {
        const prev_index = parser.index;
        block2.value = read_pattern(parser);
        parser.eat("}", true);
        block2.expression = {
          type: "Identifier",
          name: "",
          start: expression.start,
          end: prev_index - 6
        };
        block2.then = block2.pending;
        block2.pending = null;
      } else if (parser.template.slice(parser.index - 7, parser.index) === " catch ") {
        const prev_index = parser.index;
        block2.error = read_pattern(parser);
        parser.eat("}", true);
        block2.expression = {
          type: "Identifier",
          name: "",
          start: expression.start,
          end: prev_index - 7
        };
        block2.catch = block2.pending;
        block2.pending = null;
      } else {
        parser.eat("}", true);
      }
    }
    parser.stack.push(block2);
    return;
  }
  if (parser.eat("key")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    parser.allow_whitespace();
    parser.eat("}", true);
    const block2 = parser.append({
      type: "KeyBlock",
      start,
      end: -1,
      expression,
      fragment: create_fragment()
    });
    parser.stack.push(block2);
    parser.fragments.push(block2.fragment);
    return;
  }
  if (parser.eat("snippet")) {
    parser.require_whitespace();
    const name_start = parser.index;
    let name = parser.read_identifier();
    const name_end = parser.index;
    if (name === null) {
      if (parser.loose) {
        name = "";
      } else {
        expected_identifier(parser.index);
      }
    }
    parser.allow_whitespace();
    const params_start = parser.index;
    let type_params;
    if (parser.ts && parser.match("<")) {
      const start2 = parser.index;
      const end = match_bracket(parser, start2, pointy_bois);
      type_params = parser.template.slice(start2 + 1, end - 1);
      parser.index = end;
    }
    parser.allow_whitespace();
    const matched = parser.eat("(", true, false);
    if (matched) {
      let parentheses = 1;
      while (parser.index < parser.template.length && (!parser.match(")") || parentheses !== 1)) {
        if (parser.match("(")) parentheses++;
        if (parser.match(")")) parentheses--;
        parser.index += 1;
      }
      parser.eat(")", true);
    }
    const prelude = parser.template.slice(0, params_start).replace(/\S/g, " ");
    const params = parser.template.slice(params_start, parser.index);
    let function_expression = matched ? (
      /** @type {ArrowFunctionExpression} */
      parse_expression_at(prelude + `${params} => {}`, parser.ts, params_start)
    ) : { params: [] };
    parser.allow_whitespace();
    parser.eat("}", true);
    const block2 = parser.append({
      type: "SnippetBlock",
      start,
      end: -1,
      expression: {
        type: "Identifier",
        start: name_start,
        end: name_end,
        name
      },
      typeParams: type_params,
      parameters: function_expression.params,
      body: create_fragment(),
      metadata: {
        can_hoist: false,
        sites: /* @__PURE__ */ new Set()
      }
    });
    parser.stack.push(block2);
    parser.fragments.push(block2.body);
    return;
  }
  expected_block_type(parser.index);
}
function next(parser) {
  const start = parser.index - 1;
  const block2 = parser.current();
  if (block2.type === "IfBlock") {
    if (!parser.eat("else")) expected_token(start, "{:else} or {:else if}");
    if (parser.eat("if")) block_invalid_elseif(start);
    parser.allow_whitespace();
    parser.fragments.pop();
    block2.alternate = create_fragment();
    parser.fragments.push(block2.alternate);
    if (parser.eat("if")) {
      parser.require_whitespace();
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      let elseif_start = start - 1;
      while (parser.template[elseif_start] !== "{") elseif_start -= 1;
      const child = parser.append({
        start: elseif_start,
        end: -1,
        type: "IfBlock",
        elseif: true,
        test: expression,
        consequent: create_fragment(),
        alternate: null
      });
      parser.stack.push(child);
      parser.fragments.pop();
      parser.fragments.push(child.consequent);
    } else {
      parser.allow_whitespace();
      parser.eat("}", true);
    }
    return;
  }
  if (block2.type === "EachBlock") {
    if (!parser.eat("else")) expected_token(start, "{:else}");
    parser.allow_whitespace();
    parser.eat("}", true);
    block2.fallback = create_fragment();
    parser.fragments.pop();
    parser.fragments.push(block2.fallback);
    return;
  }
  if (block2.type === "AwaitBlock") {
    if (parser.eat("then")) {
      if (block2.then) {
        block_duplicate_clause(start, "{:then}");
      }
      if (!parser.eat("}")) {
        parser.require_whitespace();
        block2.value = read_pattern(parser);
        parser.allow_whitespace();
        parser.eat("}", true);
      }
      block2.then = create_fragment();
      parser.fragments.pop();
      parser.fragments.push(block2.then);
      return;
    }
    if (parser.eat("catch")) {
      if (block2.catch) {
        block_duplicate_clause(start, "{:catch}");
      }
      if (!parser.eat("}")) {
        parser.require_whitespace();
        block2.error = read_pattern(parser);
        parser.allow_whitespace();
        parser.eat("}", true);
      }
      block2.catch = create_fragment();
      parser.fragments.pop();
      parser.fragments.push(block2.catch);
      return;
    }
    expected_token(start, "{:then ...} or {:catch ...}");
  }
  block_invalid_continuation_placement(start);
}
function close(parser) {
  const start = parser.index - 1;
  let block2 = parser.current();
  let matched;
  switch (block2.type) {
    case "IfBlock":
      matched = parser.eat("if", true, false);
      if (!matched) {
        block2.end = start - 1;
        parser.pop();
        close(parser);
        return;
      }
      parser.allow_whitespace();
      parser.eat("}", true);
      while (block2.elseif) {
        block2.end = parser.index;
        parser.stack.pop();
        block2 = /** @type {AST.IfBlock} */
        parser.current();
      }
      block2.end = parser.index;
      parser.pop();
      return;
    case "EachBlock":
      matched = parser.eat("each", true, false);
      break;
    case "KeyBlock":
      matched = parser.eat("key", true, false);
      break;
    case "AwaitBlock":
      matched = parser.eat("await", true, false);
      break;
    case "SnippetBlock":
      matched = parser.eat("snippet", true, false);
      break;
    case "RegularElement":
      if (parser.loose) {
        matched = false;
      } else {
        block_unexpected_close(start);
      }
      break;
    default:
      block_unexpected_close(start);
  }
  if (!matched) {
    block2.end = start - 1;
    parser.pop();
    close(parser);
    return;
  }
  parser.allow_whitespace();
  parser.eat("}", true);
  block2.end = parser.index;
  parser.pop();
}
function special(parser) {
  let start = parser.index;
  while (parser.template[start] !== "{") start -= 1;
  if (parser.eat("html")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.append({
      type: "HtmlTag",
      start,
      end: parser.index,
      expression
    });
    return;
  }
  if (parser.eat("debug")) {
    let identifiers;
    if (parser.read(regex_whitespace_with_closing_curly_brace)) {
      identifiers = [];
    } else {
      const expression = read_expression(parser);
      identifiers = expression.type === "SequenceExpression" ? (
        /** @type {Identifier[]} */
        expression.expressions
      ) : [
        /** @type {Identifier} */
        expression
      ];
      identifiers.forEach(
        /** @param {any} node */
        (node) => {
          if (node.type !== "Identifier") {
            debug_tag_invalid_arguments(
              /** @type {number} */
              node.start
            );
          }
        }
      );
      parser.allow_whitespace();
      parser.eat("}", true);
    }
    parser.append({
      type: "DebugTag",
      start,
      end: parser.index,
      identifiers
    });
    return;
  }
  if (parser.eat("const")) {
    parser.require_whitespace();
    const id2 = read_pattern(parser);
    parser.allow_whitespace();
    parser.eat("=", true);
    parser.allow_whitespace();
    const expression_start = parser.index;
    const init3 = read_expression(parser);
    if (init3.type === "SequenceExpression" && !parser.template.substring(expression_start, init3.start).includes("(")) {
      const_tag_invalid_expression(init3);
    }
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.append({
      type: "ConstTag",
      start,
      end: parser.index,
      declaration: {
        type: "VariableDeclaration",
        kind: "const",
        declarations: [{ type: "VariableDeclarator", id: id2, init: init3, start: id2.start, end: init3.end }],
        start: start + 2,
        // start at const, not at @const
        end: parser.index - 1
      }
    });
  }
  if (parser.eat("render")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    if (expression.type !== "CallExpression" && (expression.type !== "ChainExpression" || expression.expression.type !== "CallExpression")) {
      render_tag_invalid_expression(expression);
    }
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.append({
      type: "RenderTag",
      start,
      end: parser.index,
      expression: (
        /** @type {AST.RenderTag['expression']} */
        expression
      ),
      metadata: {
        dynamic: false,
        arguments: [],
        path: [],
        snippets: /* @__PURE__ */ new Set()
      }
    });
  }
}

// node_modules/svelte/src/compiler/phases/1-parse/state/text.js
function text(parser) {
  const start = parser.index;
  let data2 = "";
  while (parser.index < parser.template.length && !parser.match("<") && !parser.match("{")) {
    data2 += parser.template[parser.index++];
  }
  parser.append({
    type: "Text",
    start,
    end: parser.index,
    raw: data2,
    data: decode_character_references(data2, false)
  });
}

// node_modules/svelte/src/compiler/phases/1-parse/state/fragment.js
function fragment(parser) {
  if (parser.match("<")) {
    return element;
  }
  if (parser.match("{")) {
    return tag;
  }
  return text;
}

// node_modules/svelte/src/compiler/phases/1-parse/read/options.js
function read_options(node) {
  var _a2, _b, _c, _d;
  const component_options = {
    start: node.start,
    end: node.end,
    // @ts-ignore
    attributes: node.attributes
  };
  if (!node) {
    return component_options;
  }
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute") {
      svelte_options_invalid_attribute(attribute);
    }
    const { name } = attribute;
    switch (name) {
      case "runes": {
        component_options.runes = get_boolean_value(attribute);
        break;
      }
      case "tag": {
        svelte_options_deprecated_tag(attribute);
        break;
      }
      case "customElement": {
        const ce = {};
        const { value: v } = attribute;
        const value = v === true || Array.isArray(v) ? v : [v];
        if (value === true) {
          svelte_options_invalid_customelement(attribute);
        } else if (value[0].type === "Text") {
          const tag3 = get_static_value(attribute);
          validate_tag(attribute, tag3);
          ce.tag = tag3;
          component_options.customElement = ce;
          break;
        } else if (value[0].expression.type !== "ObjectExpression") {
          if (value[0].expression.type === "Literal" && value[0].expression.value === null) {
            break;
          }
          svelte_options_invalid_customelement(attribute);
        }
        const properties = [];
        for (const property of value[0].expression.properties) {
          if (property.type !== "Property" || property.computed || property.key.type !== "Identifier") {
            svelte_options_invalid_customelement(attribute);
          }
          properties.push([property.key.name, property.value]);
        }
        const tag2 = properties.find(([name2]) => name2 === "tag");
        if (tag2) {
          const tag_value = (_a2 = tag2[1]) == null ? void 0 : _a2.value;
          validate_tag(tag2, tag_value);
          ce.tag = tag_value;
        }
        const props = (_b = properties.find(([name2]) => name2 === "props")) == null ? void 0 : _b[1];
        if (props) {
          if (props.type !== "ObjectExpression") {
            svelte_options_invalid_customelement_props(attribute);
          }
          ce.props = {};
          for (
            const property of
            /** @type {ObjectExpression} */
            props.properties
          ) {
            if (property.type !== "Property" || property.computed || property.key.type !== "Identifier" || property.value.type !== "ObjectExpression") {
              svelte_options_invalid_customelement_props(attribute);
            }
            ce.props[property.key.name] = {};
            for (const prop2 of property.value.properties) {
              if (prop2.type !== "Property" || prop2.computed || prop2.key.type !== "Identifier" || prop2.value.type !== "Literal") {
                svelte_options_invalid_customelement_props(attribute);
              }
              if (prop2.key.name === "type") {
                if (["String", "Number", "Boolean", "Array", "Object"].indexOf(
                  /** @type {string} */
                  prop2.value.value
                ) === -1) {
                  svelte_options_invalid_customelement_props(attribute);
                }
                ce.props[property.key.name].type = /** @type {any} */
                prop2.value.value;
              } else if (prop2.key.name === "reflect") {
                if (typeof prop2.value.value !== "boolean") {
                  svelte_options_invalid_customelement_props(attribute);
                }
                ce.props[property.key.name].reflect = prop2.value.value;
              } else if (prop2.key.name === "attribute") {
                if (typeof prop2.value.value !== "string") {
                  svelte_options_invalid_customelement_props(attribute);
                }
                ce.props[property.key.name].attribute = prop2.value.value;
              } else {
                svelte_options_invalid_customelement_props(attribute);
              }
            }
          }
        }
        const shadow = (_c = properties.find(([name2]) => name2 === "shadow")) == null ? void 0 : _c[1];
        if (shadow) {
          const shadowdom = shadow == null ? void 0 : shadow.value;
          if (shadowdom !== "open" && shadowdom !== "none") {
            svelte_options_invalid_customelement_shadow(shadow);
          }
          ce.shadow = shadowdom;
        }
        const extend2 = (_d = properties.find(([name2]) => name2 === "extend")) == null ? void 0 : _d[1];
        if (extend2) {
          ce.extend = extend2;
        }
        component_options.customElement = ce;
        break;
      }
      case "namespace": {
        const value = get_static_value(attribute);
        if (value === NAMESPACE_SVG) {
          component_options.namespace = "svg";
        } else if (value === NAMESPACE_MATHML) {
          component_options.namespace = "mathml";
        } else if (value === "html" || value === "mathml" || value === "svg") {
          component_options.namespace = value;
        } else {
          svelte_options_invalid_attribute_value(attribute, `"html", "mathml" or "svg"`);
        }
        break;
      }
      case "css": {
        const value = get_static_value(attribute);
        if (value === "injected") {
          component_options.css = value;
        } else {
          svelte_options_invalid_attribute_value(attribute, `"injected"`);
        }
        break;
      }
      case "immutable": {
        component_options.immutable = get_boolean_value(attribute);
        break;
      }
      case "preserveWhitespace": {
        component_options.preserveWhitespace = get_boolean_value(attribute);
        break;
      }
      case "accessors": {
        component_options.accessors = get_boolean_value(attribute);
        break;
      }
      default:
        svelte_options_unknown_attribute(attribute, name);
    }
  }
  return component_options;
}
function get_static_value(attribute) {
  const { value } = attribute;
  if (value === true) return true;
  const chunk = Array.isArray(value) ? value[0] : value;
  if (!chunk) return true;
  if (value.length > 1) {
    return null;
  }
  if (chunk.type === "Text") return chunk.data;
  if (chunk.expression.type !== "Literal") {
    return null;
  }
  return chunk.expression.value;
}
function get_boolean_value(attribute) {
  const value = get_static_value(attribute);
  if (typeof value !== "boolean") {
    svelte_options_invalid_attribute_value(attribute, "true or false");
  }
  return value;
}
var tag_name_char = "[a-z0-9_.·À-ÖØ-öø-ͽͿ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�𐀀-󯿿-]";
var regex_valid_tag_name = new RegExp(`^[a-z]${tag_name_char}*-${tag_name_char}*$`, "u");
var reserved_tag_names = [
  "annotation-xml",
  "color-profile",
  "font-face",
  "font-face-src",
  "font-face-uri",
  "font-face-format",
  "font-face-name",
  "missing-glyph"
];
function validate_tag(attribute, tag2) {
  if (typeof tag2 !== "string") {
    svelte_options_invalid_tagname(attribute);
  }
  if (tag2) {
    if (!regex_valid_tag_name.test(tag2)) {
      svelte_options_invalid_tagname(attribute);
    } else if (reserved_tag_names.includes(tag2)) {
      svelte_options_reserved_tagname(attribute);
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/special-element.js
function disallow_children(node) {
  const { nodes } = node.fragment;
  if (nodes.length > 0) {
    const first = nodes[0];
    const last = nodes[nodes.length - 1];
    svelte_meta_invalid_content({ start: first.start, end: last.end }, node.name);
  }
}

// node_modules/svelte/src/compiler/phases/1-parse/index.js
var regex_position_indicator = / \(\d+:\d+\)$/;
var regex_lang_attribute = /<!--[^]*?-->|<script\s+(?:[^>]*|(?:[^=>'"/]+=(?:"[^"]*"|'[^']*'|[^>\s]+)\s+)*)lang=(["'])?([^"' >]+)\1[^>]*>/g;
var Parser3 = class {
  /**
   * @param {string} template
   * @param {boolean} loose
   */
  constructor(template2, loose) {
    /**
     * @readonly
     * @type {string}
     */
    __publicField(this, "template");
    /**
     * @readonly
     * @type {string}
     */
    __publicField(this, "template_untrimmed");
    /**
     * Whether or not we're in loose parsing mode, in which
     * case we try to continue parsing as much as possible
     * @type {boolean}
     */
    __publicField(this, "loose");
    /** */
    __publicField(this, "index", 0);
    /** Whether we're parsing in TypeScript mode */
    __publicField(this, "ts", false);
    /** @type {AST.TemplateNode[]} */
    __publicField(this, "stack", []);
    /** @type {AST.Fragment[]} */
    __publicField(this, "fragments", []);
    /** @type {AST.Root} */
    __publicField(this, "root");
    /** @type {Record<string, boolean>} */
    __publicField(this, "meta_tags", {});
    /** @type {LastAutoClosedTag | undefined} */
    __publicField(this, "last_auto_closed_tag");
    if (typeof template2 !== "string") {
      throw new TypeError("Template must be a string");
    }
    this.loose = loose;
    this.template_untrimmed = template2;
    this.template = template2.trimEnd();
    let match_lang;
    do
      match_lang = regex_lang_attribute.exec(template2);
    while (match_lang && match_lang[0][1] !== "s");
    regex_lang_attribute.lastIndex = 0;
    this.ts = (match_lang == null ? void 0 : match_lang[2]) === "ts";
    this.root = {
      css: null,
      js: [],
      // @ts-ignore
      start: null,
      // @ts-ignore
      end: null,
      type: "Root",
      fragment: create_fragment(),
      options: null,
      metadata: {
        ts: this.ts
      }
    };
    this.stack.push(this.root);
    this.fragments.push(this.root.fragment);
    let state = fragment;
    while (this.index < this.template.length) {
      state = state(this) || fragment;
    }
    if (this.stack.length > 1) {
      const current2 = this.current();
      if (this.loose) {
        current2.end = this.template.length;
      } else if (current2.type === "RegularElement") {
        current2.end = current2.start + 1;
        element_unclosed(current2, current2.name);
      } else {
        current2.end = current2.start + 1;
        block_unclosed(current2);
      }
    }
    if (state !== fragment) {
      unexpected_eof(this.index);
    }
    if (this.root.fragment.nodes.length) {
      let start = (
        /** @type {number} */
        this.root.fragment.nodes[0].start
      );
      while (regex_whitespace.test(template2[start])) start += 1;
      let end = (
        /** @type {number} */
        this.root.fragment.nodes[this.root.fragment.nodes.length - 1].end
      );
      while (regex_whitespace.test(template2[end - 1])) end -= 1;
      this.root.start = start;
      this.root.end = end;
    } else {
      this.root.start = this.root.end = null;
    }
    const options_index = this.root.fragment.nodes.findIndex(
      /** @param {any} thing */
      (thing) => thing.type === "SvelteOptions"
    );
    if (options_index !== -1) {
      const options = (
        /** @type {AST.SvelteOptionsRaw} */
        this.root.fragment.nodes[options_index]
      );
      this.root.fragment.nodes.splice(options_index, 1);
      this.root.options = read_options(options);
      disallow_children(options);
      Object.defineProperty(this.root.options, "__raw__", {
        value: options,
        enumerable: false
      });
    }
  }
  current() {
    return this.stack[this.stack.length - 1];
  }
  /**
   * @param {any} err
   * @returns {never}
   */
  acorn_error(err) {
    js_parse_error(err.pos, err.message.replace(regex_position_indicator, ""));
  }
  /**
   * @param {string} str
   * @param {boolean} required
   * @param {boolean} required_in_loose
   */
  eat(str, required = false, required_in_loose = true) {
    if (this.match(str)) {
      this.index += str.length;
      return true;
    }
    if (required && (!this.loose || required_in_loose)) {
      expected_token(this.index, str);
    }
    return false;
  }
  /** @param {string} str */
  match(str) {
    const length = str.length;
    if (length === 1) {
      return this.template[this.index] === str;
    }
    return this.template.slice(this.index, this.index + length) === str;
  }
  /**
   * Match a regex at the current index
   * @param {RegExp} pattern  Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance
   */
  match_regex(pattern) {
    const match = pattern.exec(this.template.slice(this.index));
    if (!match || match.index !== 0) return null;
    return match[0];
  }
  allow_whitespace() {
    while (this.index < this.template.length && regex_whitespace.test(this.template[this.index])) {
      this.index++;
    }
  }
  /**
   * Search for a regex starting at the current index and return the result if it matches
   * @param {RegExp} pattern  Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance
   */
  read(pattern) {
    const result = this.match_regex(pattern);
    if (result) this.index += result.length;
    return result;
  }
  /** @param {any} allow_reserved */
  read_identifier(allow_reserved = false) {
    const start = this.index;
    let i = this.index;
    const code = (
      /** @type {number} */
      this.template.codePointAt(i)
    );
    if (!isIdentifierStart(code, true)) return null;
    i += code <= 65535 ? 1 : 2;
    while (i < this.template.length) {
      const code2 = (
        /** @type {number} */
        this.template.codePointAt(i)
      );
      if (!isIdentifierChar(code2, true)) break;
      i += code2 <= 65535 ? 1 : 2;
    }
    const identifier = this.template.slice(this.index, this.index = i);
    if (!allow_reserved && is_reserved(identifier)) {
      unexpected_reserved_word(start, identifier);
    }
    return identifier;
  }
  /** @param {RegExp} pattern */
  read_until(pattern) {
    if (this.index >= this.template.length) {
      if (this.loose) return "";
      unexpected_eof(this.template.length);
    }
    const start = this.index;
    const match = pattern.exec(this.template.slice(start));
    if (match) {
      this.index = start + match.index;
      return this.template.slice(start, this.index);
    }
    this.index = this.template.length;
    return this.template.slice(start);
  }
  require_whitespace() {
    if (!regex_whitespace.test(this.template[this.index])) {
      expected_whitespace(this.index);
    }
    this.allow_whitespace();
  }
  pop() {
    this.fragments.pop();
    return this.stack.pop();
  }
  /**
   * @template {AST.Fragment['nodes'][number]} T
   * @param {T} node
   * @returns {T}
   */
  append(node) {
    var _a2;
    (_a2 = this.fragments.at(-1)) == null ? void 0 : _a2.nodes.push(node);
    return node;
  }
};
function parse5(template2, loose = false) {
  const parser = new Parser3(template2, loose);
  return parser.root;
}

// node_modules/svelte/src/compiler/phases/1-parse/remove_typescript_nodes.js
function remove_this_param(node, context) {
  var _a2;
  if (((_a2 = node.params[0]) == null ? void 0 : _a2.type) === "Identifier" && node.params[0].name === "this") {
    node.params.shift();
  }
  return context.next();
}
var visitors = {
  _(node, context) {
    const n2 = context.next() ?? node;
    delete n2.typeAnnotation;
    delete n2.typeParameters;
    delete n2.typeArguments;
    delete n2.returnType;
    delete n2.accessibility;
  },
  Decorator(node) {
    typescript_invalid_feature(node, "decorators (related TSC proposal is not stage 4 yet)");
  },
  ImportDeclaration(node) {
    var _a2;
    if (node.importKind === "type") return empty2;
    if (((_a2 = node.specifiers) == null ? void 0 : _a2.length) > 0) {
      const specifiers = node.specifiers.filter((s) => s.importKind !== "type");
      if (specifiers.length === 0) return empty2;
      return { ...node, specifiers };
    }
    return node;
  },
  ExportNamedDeclaration(node, context) {
    var _a2;
    if (node.exportKind === "type") return empty2;
    if (node.declaration) {
      const result = context.next();
      if (((_a2 = result == null ? void 0 : result.declaration) == null ? void 0 : _a2.type) === "EmptyStatement") {
        return empty2;
      }
      return result;
    }
    if (node.specifiers) {
      const specifiers = node.specifiers.filter((s) => s.exportKind !== "type");
      if (specifiers.length === 0) return empty2;
      return { ...node, specifiers };
    }
    return node;
  },
  ExportDefaultDeclaration(node) {
    if (node.exportKind === "type") return empty2;
    return node;
  },
  ExportAllDeclaration(node) {
    if (node.exportKind === "type") return empty2;
    return node;
  },
  PropertyDefinition(node, { next: next2 }) {
    if (node.accessor) {
      typescript_invalid_feature(
        node,
        "accessor fields (related TSC proposal is not stage 4 yet)"
      );
    }
    return next2();
  },
  TSAsExpression(node, context) {
    return context.visit(node.expression);
  },
  TSSatisfiesExpression(node, context) {
    return context.visit(node.expression);
  },
  TSNonNullExpression(node, context) {
    return context.visit(node.expression);
  },
  TSInterfaceDeclaration() {
    return empty2;
  },
  TSTypeAliasDeclaration() {
    return empty2;
  },
  TSTypeAssertion(node, context) {
    return context.visit(node.expression);
  },
  TSEnumDeclaration(node) {
    typescript_invalid_feature(node, "enums");
  },
  TSParameterProperty(node, context) {
    var _a2;
    if ((node.readonly || node.accessibility) && ((_a2 = context.path.at(-2)) == null ? void 0 : _a2.kind) === "constructor") {
      typescript_invalid_feature(node, "accessibility modifiers on constructor parameters");
    }
    return context.visit(node.parameter);
  },
  TSInstantiationExpression(node, context) {
    return context.visit(node.expression);
  },
  FunctionExpression: remove_this_param,
  FunctionDeclaration: remove_this_param,
  TSDeclareFunction() {
    return empty2;
  },
  ClassDeclaration(node, context) {
    if (node.declare) {
      return empty2;
    }
    delete node.implements;
    return context.next();
  },
  MethodDefinition(node, context) {
    if (node.abstract) {
      return empty2;
    }
    return context.next();
  },
  VariableDeclaration(node, context) {
    if (node.declare) {
      return empty2;
    }
    return context.next();
  },
  TSModuleDeclaration(node, context) {
    if (!node.body) return empty2;
    const cleaned = (
      /** @type {any[]} */
      node.body.body.map((entry) => context.visit(entry))
    );
    if (cleaned.some((entry) => entry !== empty2)) {
      typescript_invalid_feature(node, "namespaces with non-type nodes");
    }
    return empty2;
  }
};
function remove_typescript_nodes(ast) {
  return walk(ast, null, visitors);
}

// node_modules/is-reference/src/index.js
function is_reference(node, parent) {
  if (node.type === "MemberExpression") {
    return !node.computed && is_reference(node.object, node);
  }
  if (node.type !== "Identifier") return false;
  switch (parent == null ? void 0 : parent.type) {
    case "MemberExpression":
      return parent.computed || node === parent.object;
    case "MethodDefinition":
      return parent.computed;
    case "MetaProperty":
      return parent.meta === node;
    case "PropertyDefinition":
      return parent.computed || node === parent.value;
    case "Property":
      return parent.computed || node === parent.value;
    case "ExportSpecifier":
    case "ImportSpecifier":
      return node === parent.local;
    case "LabeledStatement":
    case "BreakStatement":
    case "ContinueStatement":
      return false;
    default:
      return true;
  }
}

// node_modules/svelte/src/compiler/utils/slot.js
function determine_slot(node) {
  if (!is_element_node(node)) return null;
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute") continue;
    if (attribute.name !== "slot") continue;
    if (!is_text_attribute(attribute)) continue;
    return (
      /** @type {string} */
      attribute.value[0].data
    );
  }
  return null;
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/utils.js
function validate_assignment(node, argument, context) {
  var _a2;
  validate_no_const_assignment(node, argument, context.state.scope, node.type === "BindDirective");
  if (argument.type === "Identifier") {
    const binding = context.state.scope.get(argument.name);
    if (context.state.analysis.runes) {
      if ((binding == null ? void 0 : binding.node) === context.state.analysis.props_id) {
        constant_assignment(node, "$props.id()");
      }
      if ((binding == null ? void 0 : binding.kind) === "each") {
        each_item_invalid_assignment(node);
      }
    }
    if ((binding == null ? void 0 : binding.kind) === "snippet") {
      snippet_parameter_assignment(node);
    }
  }
  if (argument.type === "MemberExpression" && argument.object.type === "ThisExpression") {
    const name = argument.computed && argument.property.type !== "Literal" ? null : get_name(argument.property);
    const field = name !== null && ((_a2 = context.state.state_fields) == null ? void 0 : _a2.get(name));
    if (field && field.node.type === "AssignmentExpression" && node !== field.node) {
      let i = context.path.length;
      while (i--) {
        const parent = context.path[i];
        if (parent.type === "FunctionDeclaration" || parent.type === "FunctionExpression" || parent.type === "ArrowFunctionExpression") {
          const grandparent = get_parent(context.path, i - 1);
          if (grandparent.type === "MethodDefinition" && grandparent.kind === "constructor" && /** @type {number} */
          node.start < /** @type {number} */
          field.node.start) {
            state_field_invalid_assignment(node);
          }
          break;
        }
      }
    }
  }
}
function validate_no_const_assignment(node, argument, scope, is_binding) {
  if (argument.type === "ArrayPattern") {
    for (const element2 of argument.elements) {
      if (element2) {
        validate_no_const_assignment(node, element2, scope, is_binding);
      }
    }
  } else if (argument.type === "ObjectPattern") {
    for (const element2 of argument.properties) {
      if (element2.type === "Property") {
        validate_no_const_assignment(node, element2.value, scope, is_binding);
      }
    }
  } else if (argument.type === "Identifier") {
    const binding = scope.get(argument.name);
    if ((binding == null ? void 0 : binding.declaration_kind) === "import" || (binding == null ? void 0 : binding.declaration_kind) === "const" && binding.kind !== "each") {
      const thing = binding.declaration_kind === "import" ? "import" : "constant";
      if (is_binding) {
        constant_binding(node, thing);
      } else {
        constant_assignment(node, thing);
      }
    }
  }
}
function validate_opening_tag(node, state, expected) {
  if (state.analysis.source[node.start + 1] !== expected) {
    block_unexpected_character({ start: node.start, end: node.start + 5 }, expected);
  }
}
function validate_block_not_empty(node, context) {
  if (!node) return;
  if (node.nodes.length === 1 && node.nodes[0].type === "Text" && !node.nodes[0].raw.trim()) {
    block_empty(node.nodes[0]);
  }
}
function ensure_no_module_import_conflict(node, state) {
  var _a2;
  const ids = extract_identifiers(node.id);
  for (const id2 of ids) {
    if (state.ast_type === "instance" && state.scope === state.analysis.instance.scope && ((_a2 = state.analysis.module.scope.get(id2.name)) == null ? void 0 : _a2.declaration_kind) === "import") {
      declaration_duplicate_module_import(node.id);
    }
  }
}
function is_safe_identifier(expression, scope) {
  let node = expression;
  while (node.type === "MemberExpression") node = node.object;
  if (node.type !== "Identifier") return false;
  const binding = scope.get(node.name);
  if (!binding) return true;
  if (binding.kind === "store_sub") {
    return is_safe_identifier({ name: node.name.slice(1), type: "Identifier" }, scope);
  }
  return binding.declaration_kind !== "import" && binding.kind !== "prop" && binding.kind !== "bindable_prop" && binding.kind !== "rest_prop";
}
function is_pure(node, context) {
  if (node.type === "Literal") {
    return true;
  }
  if (node.type === "CallExpression") {
    if (!is_pure(node.callee, context)) {
      return false;
    }
    for (let arg of node.arguments) {
      if (!is_pure(arg.type === "SpreadElement" ? arg.argument : arg, context)) {
        return false;
      }
    }
    return true;
  }
  if (node.type !== "Identifier" && node.type !== "MemberExpression") {
    return false;
  }
  if (get_rune(call(node), context.state.scope) === "$effect.tracking") {
    return false;
  }
  let left = node;
  while (left.type === "MemberExpression") {
    left = left.object;
  }
  if (!left) return false;
  if (left.type === "Identifier") {
    const binding = context.state.scope.get(left.name);
    if (binding === null) return true;
  } else if (is_pure(left, context)) {
    return true;
  }
  return false;
}
function validate_identifier_name(binding, function_depth) {
  var _a2;
  if (!binding) return;
  const declaration_kind = binding.declaration_kind;
  if (declaration_kind !== "synthetic" && declaration_kind !== "param" && declaration_kind !== "rest_param" && (!function_depth || function_depth <= 1)) {
    const node = binding.node;
    if (node.name === "$") {
      dollar_binding_invalid(node);
    } else if (node.name.startsWith("$") && // import type { $Type } from "" - these are normally already filtered out,
    // but for the migration they aren't, and throwing here is preventing the migration to complete
    // TODO -> once migration script is gone we can remove this check
    !(((_a2 = binding.initial) == null ? void 0 : _a2.type) === "ImportDeclaration" && /** @type {any} */
    binding.initial.importKind === "type")) {
      dollar_prefix_invalid(node);
    }
  }
}
function validate_export(node, scope, name) {
  const binding = scope.get(name);
  if (!binding) return;
  if (binding.kind === "derived") {
    derived_invalid_export(node);
  }
  if ((binding.kind === "state" || binding.kind === "raw_state") && binding.reassigned) {
    state_invalid_export(node);
  }
}

// node_modules/svelte/src/compiler/phases/scope.js
var UNKNOWN = Symbol("unknown");
var NUMBER = Symbol("number");
var STRING = Symbol("string");
var FUNCTION = Symbol("string");
var globals = {
  BigInt: [NUMBER],
  "Math.min": [NUMBER, Math.min],
  "Math.max": [NUMBER, Math.max],
  "Math.random": [NUMBER],
  "Math.floor": [NUMBER, Math.floor],
  // @ts-ignore
  "Math.f16round": [NUMBER, Math.f16round],
  "Math.round": [NUMBER, Math.round],
  "Math.abs": [NUMBER, Math.abs],
  "Math.acos": [NUMBER, Math.acos],
  "Math.asin": [NUMBER, Math.asin],
  "Math.atan": [NUMBER, Math.atan],
  "Math.atan2": [NUMBER, Math.atan2],
  "Math.ceil": [NUMBER, Math.ceil],
  "Math.cos": [NUMBER, Math.cos],
  "Math.sin": [NUMBER, Math.sin],
  "Math.tan": [NUMBER, Math.tan],
  "Math.exp": [NUMBER, Math.exp],
  "Math.log": [NUMBER, Math.log],
  "Math.pow": [NUMBER, Math.pow],
  "Math.sqrt": [NUMBER, Math.sqrt],
  "Math.clz32": [NUMBER, Math.clz32],
  "Math.imul": [NUMBER, Math.imul],
  "Math.sign": [NUMBER, Math.sign],
  "Math.log10": [NUMBER, Math.log10],
  "Math.log2": [NUMBER, Math.log2],
  "Math.log1p": [NUMBER, Math.log1p],
  "Math.expm1": [NUMBER, Math.expm1],
  "Math.cosh": [NUMBER, Math.cosh],
  "Math.sinh": [NUMBER, Math.sinh],
  "Math.tanh": [NUMBER, Math.tanh],
  "Math.acosh": [NUMBER, Math.acosh],
  "Math.asinh": [NUMBER, Math.asinh],
  "Math.atanh": [NUMBER, Math.atanh],
  "Math.trunc": [NUMBER, Math.trunc],
  "Math.fround": [NUMBER, Math.fround],
  "Math.cbrt": [NUMBER, Math.cbrt],
  Number: [NUMBER, Number],
  "Number.isInteger": [NUMBER, Number.isInteger],
  "Number.isFinite": [NUMBER, Number.isFinite],
  "Number.isNaN": [NUMBER, Number.isNaN],
  "Number.isSafeInteger": [NUMBER, Number.isSafeInteger],
  "Number.parseFloat": [NUMBER, Number.parseFloat],
  "Number.parseInt": [NUMBER, Number.parseInt],
  String: [STRING, String],
  "String.fromCharCode": [STRING, String.fromCharCode],
  "String.fromCodePoint": [STRING, String.fromCodePoint]
};
var global_constants = {
  "Math.PI": Math.PI,
  "Math.E": Math.E,
  "Math.LN10": Math.LN10,
  "Math.LN2": Math.LN2,
  "Math.LOG10E": Math.LOG10E,
  "Math.LOG2E": Math.LOG2E,
  "Math.SQRT2": Math.SQRT2,
  "Math.SQRT1_2": Math.SQRT1_2
};
var Binding = class {
  /**
   *
   * @param {Scope} scope
   * @param {Identifier} node
   * @param {BindingKind} kind
   * @param {DeclarationKind} declaration_kind
   * @param {Binding['initial']} initial
   */
  constructor(scope, node, kind, declaration_kind, initial) {
    /** @type {Scope} */
    __publicField(this, "scope");
    /** @type {Identifier} */
    __publicField(this, "node");
    /** @type {BindingKind} */
    __publicField(this, "kind");
    /** @type {DeclarationKind} */
    __publicField(this, "declaration_kind");
    /**
     * What the value was initialized with.
     * For destructured props such as `let { foo = 'bar' } = $props()` this is `'bar'` and not `$props()`
     * @type {null | Expression | FunctionDeclaration | ClassDeclaration | ImportDeclaration | AST.EachBlock | AST.SnippetBlock}
     */
    __publicField(this, "initial", null);
    /** @type {Array<{ node: Identifier; path: AST.SvelteNode[] }>} */
    __publicField(this, "references", []);
    /**
     * For `legacy_reactive`: its reactive dependencies
     * @type {Binding[]}
     */
    __publicField(this, "legacy_dependencies", []);
    /**
     * Legacy props: the `class` in `{ export klass as class}`. $props(): The `class` in { class: klass } = $props()
     * @type {string | null}
     */
    __publicField(this, "prop_alias", null);
    /**
     * Additional metadata, varies per binding type
     * @type {null | { inside_rest?: boolean }}
     */
    __publicField(this, "metadata", null);
    __publicField(this, "mutated", false);
    __publicField(this, "reassigned", false);
    this.scope = scope;
    this.node = node;
    this.initial = initial;
    this.kind = kind;
    this.declaration_kind = declaration_kind;
  }
  get updated() {
    return this.mutated || this.reassigned;
  }
  /**
   * @returns {this is Binding & { initial: ArrowFunctionExpression | FunctionDeclaration | FunctionExpression }}
   */
  is_function() {
    var _a2;
    if (this.updated) {
      return false;
    }
    const type = (_a2 = this.initial) == null ? void 0 : _a2.type;
    return type === "ArrowFunctionExpression" || type === "FunctionExpression" || type === "FunctionDeclaration";
  }
};
var Evaluation = class {
  /**
   *
   * @param {Scope} scope
   * @param {Expression | FunctionDeclaration} expression
   * @param {Set<any>} values
   */
  constructor(scope, expression, values) {
    /** @type {Set<any>} */
    __publicField(this, "values");
    /**
     * True if there is exactly one possible value
     * @readonly
     * @type {boolean}
     */
    __publicField(this, "is_known", true);
    /**
     * True if the value is known to not be null/undefined
     * @readonly
     * @type {boolean}
     */
    __publicField(this, "is_defined", true);
    /**
     * True if the value is known to be a string
     * @readonly
     * @type {boolean}
     */
    __publicField(this, "is_string", true);
    /**
     * True if the value is known to be a number
     * @readonly
     * @type {boolean}
     */
    __publicField(this, "is_number", true);
    /**
     * True if the value is known to be a function
     * @readonly
     * @type {boolean}
     */
    __publicField(this, "is_function", true);
    /**
     * @readonly
     * @type {any}
     */
    __publicField(this, "value");
    var _a2, _b;
    current_evaluations.set(expression, this);
    this.values = values;
    switch (expression.type) {
      case "Literal": {
        this.values.add(expression.value);
        break;
      }
      case "Identifier": {
        const binding = scope.get(expression.name);
        if (binding) {
          if (((_a2 = binding.initial) == null ? void 0 : _a2.type) === "CallExpression" && get_rune(binding.initial, scope) === "$props.id") {
            this.values.add(STRING);
            break;
          }
          const is_prop = binding.kind === "prop" || binding.kind === "rest_prop" || binding.kind === "bindable_prop";
          if (((_b = binding.initial) == null ? void 0 : _b.type) === "EachBlock" && binding.initial.index === expression.name) {
            this.values.add(NUMBER);
            break;
          }
          if (!binding.updated && binding.initial !== null && !is_prop) {
            binding.scope.evaluate(
              /** @type {Expression} */
              binding.initial,
              this.values
            );
            break;
          }
        } else if (expression.name === "undefined") {
          this.values.add(void 0);
          break;
        }
        this.values.add(UNKNOWN);
        break;
      }
      case "BinaryExpression": {
        const a = scope.evaluate(
          /** @type {Expression} */
          expression.left
        );
        const b = scope.evaluate(expression.right);
        if (a.is_known && b.is_known) {
          this.values.add(binary2[expression.operator](a.value, b.value));
          break;
        }
        switch (expression.operator) {
          case "!=":
          case "!==":
          case "<":
          case "<=":
          case ">":
          case ">=":
          case "==":
          case "===":
          case "in":
          case "instanceof":
            this.values.add(true);
            this.values.add(false);
            break;
          case "%":
          case "&":
          case "*":
          case "**":
          case "-":
          case "/":
          case "<<":
          case ">>":
          case ">>>":
          case "^":
          case "|":
            this.values.add(NUMBER);
            break;
          case "+":
            if (a.is_string || b.is_string) {
              this.values.add(STRING);
            } else if (a.is_number && b.is_number) {
              this.values.add(NUMBER);
            } else {
              this.values.add(STRING);
              this.values.add(NUMBER);
            }
            break;
          default:
            this.values.add(UNKNOWN);
        }
        break;
      }
      case "ConditionalExpression": {
        const test = scope.evaluate(expression.test);
        const consequent = scope.evaluate(expression.consequent);
        const alternate = scope.evaluate(expression.alternate);
        if (test.is_known) {
          for (const value of (test.value ? consequent : alternate).values) {
            this.values.add(value);
          }
        } else {
          for (const value of consequent.values) {
            this.values.add(value);
          }
          for (const value of alternate.values) {
            this.values.add(value);
          }
        }
        break;
      }
      case "LogicalExpression": {
        const a = scope.evaluate(expression.left);
        const b = scope.evaluate(expression.right);
        if (a.is_known) {
          if (b.is_known) {
            this.values.add(logical2[expression.operator](a.value, b.value));
            break;
          }
          if (expression.operator === "&&" && !a.value || expression.operator === "||" && a.value || expression.operator === "??" && a.value != null) {
            this.values.add(a.value);
          } else {
            for (const value of b.values) {
              this.values.add(value);
            }
          }
          break;
        }
        for (const value of a.values) {
          this.values.add(value);
        }
        for (const value of b.values) {
          this.values.add(value);
        }
        break;
      }
      case "UnaryExpression": {
        const argument = scope.evaluate(expression.argument);
        if (argument.is_known) {
          this.values.add(unary2[expression.operator](argument.value));
          break;
        }
        switch (expression.operator) {
          case "!":
          case "delete":
            this.values.add(false);
            this.values.add(true);
            break;
          case "+":
          case "-":
          case "~":
            this.values.add(NUMBER);
            break;
          case "typeof":
            this.values.add(STRING);
            break;
          case "void":
            this.values.add(void 0);
            break;
          default:
            this.values.add(UNKNOWN);
        }
        break;
      }
      case "CallExpression": {
        const keypath = get_global_keypath(expression.callee, scope);
        if (keypath) {
          if (is_rune(keypath)) {
            const arg = (
              /** @type {Expression | undefined} */
              expression.arguments[0]
            );
            switch (keypath) {
              case "$state":
              case "$state.raw":
              case "$derived":
                if (arg) {
                  scope.evaluate(arg, this.values);
                } else {
                  this.values.add(void 0);
                }
                break;
              case "$props.id":
                this.values.add(STRING);
                break;
              case "$effect.tracking":
                this.values.add(false);
                this.values.add(true);
                break;
              case "$derived.by":
                if ((arg == null ? void 0 : arg.type) === "ArrowFunctionExpression" && arg.body.type !== "BlockStatement") {
                  scope.evaluate(arg.body, this.values);
                  break;
                }
                this.values.add(UNKNOWN);
                break;
              default: {
                this.values.add(UNKNOWN);
              }
            }
            break;
          }
          if (Object.hasOwn(globals, keypath) && expression.arguments.every((arg) => arg.type !== "SpreadElement")) {
            const [type, fn] = globals[keypath];
            const values2 = expression.arguments.map((arg) => scope.evaluate(arg));
            if (fn && values2.every((e2) => e2.is_known)) {
              this.values.add(fn(...values2.map((e2) => e2.value)));
            } else {
              this.values.add(type);
            }
            break;
          }
        }
        this.values.add(UNKNOWN);
        break;
      }
      case "TemplateLiteral": {
        let result = expression.quasis[0].value.cooked;
        for (let i = 0; i < expression.expressions.length; i += 1) {
          const e2 = scope.evaluate(expression.expressions[i]);
          if (e2.is_known) {
            result += e2.value + expression.quasis[i + 1].value.cooked;
          } else {
            this.values.add(STRING);
            break;
          }
        }
        this.values.add(result);
        break;
      }
      case "MemberExpression": {
        const keypath = get_global_keypath(expression, scope);
        if (keypath && Object.hasOwn(global_constants, keypath)) {
          this.values.add(global_constants[keypath]);
          break;
        }
        this.values.add(UNKNOWN);
        break;
      }
      case "ArrowFunctionExpression":
      case "FunctionExpression":
      case "FunctionDeclaration": {
        this.values.add(FUNCTION);
        break;
      }
      default: {
        this.values.add(UNKNOWN);
      }
    }
    for (const value of this.values) {
      this.value = value;
      if (value !== STRING && typeof value !== "string") {
        this.is_string = false;
      }
      if (value !== NUMBER && typeof value !== "number") {
        this.is_number = false;
      }
      if (value !== FUNCTION) {
        this.is_function = false;
      }
      if (value == null || value === UNKNOWN) {
        this.is_defined = false;
      }
    }
    if (this.values.size > 1 || typeof this.value === "symbol") {
      this.is_known = false;
    }
    current_evaluations.delete(expression);
  }
};
var _porous;
var _Scope = class _Scope {
  /**
   *
   * @param {ScopeRoot} root
   * @param {Scope | null} parent
   * @param {boolean} porous
   */
  constructor(root, parent, porous) {
    /** @type {ScopeRoot} */
    __publicField(this, "root");
    /**
     * The immediate parent scope
     * @type {Scope | null}
     */
    __publicField(this, "parent");
    /**
     * Whether or not `var` declarations are contained by this scope
     * @type {boolean}
     */
    __privateAdd(this, _porous);
    /**
     * A map of every identifier declared by this scope, and all the
     * identifiers that reference it
     * @type {Map<string, Binding>}
     */
    __publicField(this, "declarations", /* @__PURE__ */ new Map());
    /**
     * A map of declarators to the bindings they declare
     * @type {Map<VariableDeclarator | AST.LetDirective, Binding[]>}
     */
    __publicField(this, "declarators", /* @__PURE__ */ new Map());
    /**
     * A set of all the names referenced with this scope
     * — useful for generating unique names
     * @type {Map<string, { node: Identifier; path: AST.SvelteNode[] }[]>}
     */
    __publicField(this, "references", /* @__PURE__ */ new Map());
    /**
     * The scope depth allows us to determine if a state variable is referenced in its own scope,
     * which is usually an error. Block statements do not increase this value
     */
    __publicField(this, "function_depth", 0);
    /**
     * If tracing of reactive dependencies is enabled for this scope
     * @type {null | Expression}
     */
    __publicField(this, "tracing", null);
    this.root = root;
    this.parent = parent;
    __privateSet(this, _porous, porous);
    this.function_depth = parent ? parent.function_depth + (porous ? 0 : 1) : 0;
  }
  /**
   * @param {Identifier} node
   * @param {Binding['kind']} kind
   * @param {DeclarationKind} declaration_kind
   * @param {null | Expression | FunctionDeclaration | ClassDeclaration | ImportDeclaration | AST.EachBlock | AST.SnippetBlock} initial
   * @returns {Binding}
   */
  declare(node, kind, declaration_kind, initial = null) {
    if (this.parent) {
      if (declaration_kind === "var" && __privateGet(this, _porous)) {
        return this.parent.declare(node, kind, declaration_kind);
      }
      if (declaration_kind === "import") {
        return this.parent.declare(node, kind, declaration_kind, initial);
      }
    }
    if (this.declarations.has(node.name)) {
      const binding2 = this.declarations.get(node.name);
      if (binding2 && binding2.declaration_kind !== "var" && declaration_kind !== "var") {
        declaration_duplicate(node, node.name);
      }
    }
    const binding = new Binding(this, node, kind, declaration_kind, initial);
    validate_identifier_name(binding, this.function_depth);
    this.declarations.set(node.name, binding);
    this.root.conflicts.add(node.name);
    return binding;
  }
  child(porous = false) {
    return new _Scope(this.root, this, porous);
  }
  /**
   * @param {string} preferred_name
   * @returns {string}
   */
  generate(preferred_name) {
    if (__privateGet(this, _porous)) {
      return (
        /** @type {Scope} */
        this.parent.generate(preferred_name)
      );
    }
    preferred_name = preferred_name.replace(/[^a-zA-Z0-9_$]/g, "_").replace(/^[0-9]/, "_");
    let name = preferred_name;
    let n2 = 1;
    while (this.references.has(name) || this.declarations.has(name) || this.root.conflicts.has(name) || is_reserved(name)) {
      name = `${preferred_name}_${n2++}`;
    }
    this.references.set(name, []);
    this.root.conflicts.add(name);
    return name;
  }
  /**
   * @param {string} name
   * @returns {Binding | null}
   */
  get(name) {
    var _a2;
    return this.declarations.get(name) ?? ((_a2 = this.parent) == null ? void 0 : _a2.get(name)) ?? null;
  }
  /**
   * @param {VariableDeclarator | AST.LetDirective} node
   * @returns {Binding[]}
   */
  get_bindings(node) {
    const bindings = this.declarators.get(node);
    if (!bindings) {
      throw new Error("No binding found for declarator");
    }
    return bindings;
  }
  /**
   * @param {string} name
   * @returns {Scope | null}
   */
  owner(name) {
    return this.declarations.has(name) ? this : this.parent && this.parent.owner(name);
  }
  /**
   * @param {Identifier} node
   * @param {AST.SvelteNode[]} path
   */
  reference(node, path11) {
    path11 = [...path11];
    let references = this.references.get(node.name);
    if (!references) this.references.set(node.name, references = []);
    references.push({ node, path: path11 });
    const binding = this.declarations.get(node.name);
    if (binding) {
      binding.references.push({ node, path: path11 });
    } else if (this.parent) {
      this.parent.reference(node, path11);
    } else {
      this.root.conflicts.add(node.name);
    }
  }
  /**
   * Does partial evaluation to find an exact value or at least the rough type of the expression.
   * Only call this once scope has been fully generated in a first pass,
   * else this evaluates on incomplete data and may yield wrong results.
   * @param {Expression} expression
   * @param {Set<any>} [values]
   */
  evaluate(expression, values = /* @__PURE__ */ new Set()) {
    const current2 = current_evaluations.get(expression);
    if (current2) return current2;
    return new Evaluation(this, expression, values);
  }
};
_porous = new WeakMap();
var Scope3 = _Scope;
var current_evaluations = /* @__PURE__ */ new Map();
var binary2 = {
  "!=": (left, right) => left != right,
  "!==": (left, right) => left !== right,
  "<": (left, right) => left < right,
  "<=": (left, right) => left <= right,
  ">": (left, right) => left > right,
  ">=": (left, right) => left >= right,
  "==": (left, right) => left == right,
  "===": (left, right) => left === right,
  in: (left, right) => left in right,
  instanceof: (left, right) => left instanceof right,
  "%": (left, right) => left % right,
  "&": (left, right) => left & right,
  "*": (left, right) => left * right,
  "**": (left, right) => left ** right,
  "+": (left, right) => left + right,
  "-": (left, right) => left - right,
  "/": (left, right) => left / right,
  "<<": (left, right) => left << right,
  ">>": (left, right) => left >> right,
  ">>>": (left, right) => left >>> right,
  "^": (left, right) => left ^ right,
  "|": (left, right) => left | right
};
var unary2 = {
  "-": (argument) => -argument,
  "+": (argument) => +argument,
  "!": (argument) => !argument,
  "~": (argument) => ~argument,
  typeof: (argument) => typeof argument,
  void: () => void 0,
  delete: () => true
};
var logical2 = {
  "||": (left, right) => left || right,
  "&&": (left, right) => left && right,
  "??": (left, right) => left ?? right
};
var ScopeRoot = class {
  constructor() {
    /** @type {Set<string>} */
    __publicField(this, "conflicts", /* @__PURE__ */ new Set());
  }
  /**
   * @param {string} preferred_name
   */
  unique(preferred_name) {
    preferred_name = preferred_name.replace(/[^a-zA-Z0-9_$]/g, "_");
    let final_name = preferred_name;
    let n2 = 1;
    while (this.conflicts.has(final_name)) {
      final_name = `${preferred_name}_${n2++}`;
    }
    this.conflicts.add(final_name);
    const id2 = id(final_name);
    return id2;
  }
};
function create_scopes(ast, root, allow_reactive_declarations, parent) {
  const scopes = /* @__PURE__ */ new Map();
  const scope = new Scope3(root, parent, false);
  scopes.set(ast, scope);
  const state = { scope };
  const references = [];
  const updates = [];
  const possible_implicit_declarations = [];
  function add_params(scope2, params) {
    for (const param of params) {
      for (const node of extract_identifiers(param)) {
        scope2.declare(node, "normal", param.type === "RestElement" ? "rest_param" : "param");
      }
    }
  }
  const create_block_scope = (node, { state: state2, next: next2 }) => {
    const scope2 = state2.scope.child(true);
    scopes.set(node, scope2);
    next2({ scope: scope2 });
  };
  const SvelteFragment4 = (node, { state: state2, next: next2 }) => {
    const scope2 = state2.scope.child();
    scopes.set(node, scope2);
    next2({ scope: scope2 });
  };
  const Component4 = (node, context) => {
    node.metadata.scopes = {
      default: context.state.scope.child()
    };
    if (node.type === "SvelteComponent") {
      context.visit(node.expression);
    }
    const default_state = determine_slot(node) ? context.state : { scope: node.metadata.scopes.default };
    for (const attribute of node.attributes) {
      if (attribute.type === "LetDirective") {
        context.visit(attribute, default_state);
      } else {
        context.visit(attribute);
      }
    }
    for (const child of node.fragment.nodes) {
      let state2 = default_state;
      const slot_name = determine_slot(child);
      if (slot_name !== null) {
        node.metadata.scopes[slot_name] = context.state.scope.child();
        state2 = {
          scope: node.metadata.scopes[slot_name]
        };
      }
      context.visit(child, state2);
    }
  };
  const SvelteDirective = (node, { state: state2, path: path11, visit }) => {
    state2.scope.reference(id(node.name.split(".")[0]), path11);
    if (node.expression) {
      visit(node.expression);
    }
  };
  walk(ast, state, {
    // references
    Identifier(node, { path: path11, state: state2 }) {
      const parent2 = path11.at(-1);
      if (parent2 && is_reference(
        node,
        /** @type {Node} */
        parent2
      ) && // TSTypeAnnotation, TSInterfaceDeclaration etc - these are normally already filtered out,
      // but for the migration they aren't, so we need to filter them out here
      // TODO -> once migration script is gone we can remove this check
      !parent2.type.startsWith("TS")) {
        references.push([state2.scope, { node, path: path11.slice() }]);
      }
    },
    LabeledStatement(node, { path: path11, next: next2 }) {
      if (path11.length > 1 || !allow_reactive_declarations) return next2();
      if (node.label.name !== "$") return next2();
      const scope2 = state.scope.child();
      scopes.set(node, scope2);
      if (node.body.type === "ExpressionStatement" && node.body.expression.type === "AssignmentExpression") {
        for (const id2 of extract_identifiers(node.body.expression.left)) {
          if (!id2.name.startsWith("$")) {
            possible_implicit_declarations.push(id2);
          }
        }
      }
      next2({ scope: scope2 });
    },
    SvelteFragment: SvelteFragment4,
    SlotElement: SvelteFragment4,
    SvelteElement: SvelteFragment4,
    RegularElement: SvelteFragment4,
    LetDirective(node, context) {
      const scope2 = context.state.scope;
      const bindings = [];
      scope2.declarators.set(node, bindings);
      if (node.expression) {
        for (const id2 of extract_identifiers_from_destructuring(node.expression)) {
          const binding = scope2.declare(id2, "template", "const");
          scope2.reference(id2, [context.path[context.path.length - 1], node]);
          bindings.push(binding);
        }
      } else {
        const id2 = {
          name: node.name,
          type: "Identifier",
          start: node.start,
          end: node.end
        };
        const binding = scope2.declare(id2, "template", "const");
        scope2.reference(id2, [context.path[context.path.length - 1], node]);
        bindings.push(binding);
      }
    },
    Component: (node, context) => {
      context.state.scope.reference(id(node.name), context.path);
      Component4(node, context);
    },
    SvelteSelf: Component4,
    SvelteComponent: Component4,
    // updates
    AssignmentExpression(node, { state: state2, next: next2 }) {
      updates.push([state2.scope, node.left]);
      next2();
    },
    UpdateExpression(node, { state: state2, next: next2 }) {
      updates.push([
        state2.scope,
        /** @type {Identifier | MemberExpression} */
        node.argument
      ]);
      next2();
    },
    ImportDeclaration(node, { state: state2 }) {
      for (const specifier of node.specifiers) {
        state2.scope.declare(specifier.local, "normal", "import", node);
      }
    },
    FunctionExpression(node, { state: state2, next: next2 }) {
      const scope2 = state2.scope.child();
      scopes.set(node, scope2);
      if (node.id) scope2.declare(node.id, "normal", "function");
      add_params(scope2, node.params);
      next2({ scope: scope2 });
    },
    FunctionDeclaration(node, { state: state2, next: next2 }) {
      if (node.id) state2.scope.declare(node.id, "normal", "function", node);
      const scope2 = state2.scope.child();
      scopes.set(node, scope2);
      add_params(scope2, node.params);
      next2({ scope: scope2 });
    },
    ArrowFunctionExpression(node, { state: state2, next: next2 }) {
      const scope2 = state2.scope.child();
      scopes.set(node, scope2);
      add_params(scope2, node.params);
      next2({ scope: scope2 });
    },
    ForStatement: create_block_scope,
    ForInStatement: create_block_scope,
    ForOfStatement: create_block_scope,
    SwitchStatement: create_block_scope,
    BlockStatement(node, context) {
      const parent2 = context.path.at(-1);
      if ((parent2 == null ? void 0 : parent2.type) === "FunctionDeclaration" || (parent2 == null ? void 0 : parent2.type) === "FunctionExpression" || (parent2 == null ? void 0 : parent2.type) === "ArrowFunctionExpression") {
        context.next();
      } else {
        create_block_scope(node, context);
      }
    },
    ClassDeclaration(node, { state: state2, next: next2 }) {
      if (node.id) state2.scope.declare(node.id, "normal", "let", node);
      next2();
    },
    VariableDeclaration(node, { state: state2, path: path11, next: next2 }) {
      var _a2;
      const is_parent_const_tag = ((_a2 = path11.at(-1)) == null ? void 0 : _a2.type) === "ConstTag";
      for (const declarator2 of node.declarations) {
        const bindings = [];
        state2.scope.declarators.set(declarator2, bindings);
        for (const id2 of extract_identifiers(declarator2.id)) {
          const binding = state2.scope.declare(
            id2,
            is_parent_const_tag ? "template" : "normal",
            node.kind,
            declarator2.init
          );
          bindings.push(binding);
        }
      }
      next2();
    },
    CatchClause(node, { state: state2, next: next2 }) {
      if (node.param) {
        const scope2 = state2.scope.child(true);
        scopes.set(node, scope2);
        for (const id2 of extract_identifiers(node.param)) {
          scope2.declare(id2, "normal", "let");
        }
        next2({ scope: scope2 });
      } else {
        next2();
      }
    },
    EachBlock(node, { state: state2, visit }) {
      visit(node.expression);
      const scope2 = state2.scope.child();
      scopes.set(node, scope2);
      if (node.context) {
        for (const id2 of extract_identifiers(node.context)) {
          const binding = scope2.declare(id2, "each", "const");
          let inside_rest = false;
          let is_rest_id = false;
          walk(node.context, null, {
            Identifier(node2) {
              if (inside_rest && node2 === id2) {
                is_rest_id = true;
              }
            },
            RestElement(_, { next: next2 }) {
              const prev = inside_rest;
              inside_rest = true;
              next2();
              inside_rest = prev;
            }
          });
          binding.metadata = { inside_rest: is_rest_id };
        }
        visit(node.context, { scope: scope2 });
      }
      if (node.index) {
        const is_keyed = node.key && (node.key.type !== "Identifier" || !node.index || node.key.name !== node.index);
        scope2.declare(id(node.index), is_keyed ? "template" : "static", "const", node);
      }
      if (node.key) visit(node.key, { scope: scope2 });
      for (const child of node.body.nodes) {
        visit(child, { scope: scope2 });
      }
      if (node.fallback) visit(node.fallback, { scope: scope2 });
      node.metadata = {
        expression: create_expression_metadata(),
        keyed: false,
        contains_group_binding: false,
        index: scope2.root.unique("$$index"),
        declarations: scope2.declarations,
        is_controlled: false,
        // filled in during analysis
        transitive_deps: /* @__PURE__ */ new Set()
      };
    },
    AwaitBlock(node, context) {
      context.visit(node.expression);
      if (node.pending) {
        context.visit(node.pending);
      }
      if (node.then) {
        context.visit(node.then);
        if (node.value) {
          const then_scope = (
            /** @type {Scope} */
            scopes.get(node.then)
          );
          const value_scope = context.state.scope.child();
          scopes.set(node.value, value_scope);
          context.visit(node.value, { scope: value_scope });
          for (const id2 of extract_identifiers(node.value)) {
            then_scope.declare(id2, "template", "const");
            value_scope.declare(id2, "normal", "const");
          }
        }
      }
      if (node.catch) {
        context.visit(node.catch);
        if (node.error) {
          const catch_scope = (
            /** @type {Scope} */
            scopes.get(node.catch)
          );
          const error_scope = context.state.scope.child();
          scopes.set(node.error, error_scope);
          context.visit(node.error, { scope: error_scope });
          for (const id2 of extract_identifiers(node.error)) {
            catch_scope.declare(id2, "template", "const");
            error_scope.declare(id2, "normal", "const");
          }
        }
      }
    },
    SnippetBlock(node, context) {
      const state2 = context.state;
      let scope2 = state2.scope;
      scope2.declare(node.expression, "normal", "function", node);
      const child_scope = state2.scope.child();
      scopes.set(node, child_scope);
      for (const param of node.parameters) {
        for (const id2 of extract_identifiers(param)) {
          child_scope.declare(id2, "snippet", "let");
        }
      }
      context.next({ scope: child_scope });
    },
    Fragment: (node, context) => {
      const scope2 = context.state.scope.child(node.metadata.transparent);
      scopes.set(node, scope2);
      context.next({ scope: scope2 });
    },
    BindDirective(node, context) {
      updates.push([
        context.state.scope,
        /** @type {Identifier | MemberExpression} */
        node.expression
      ]);
      context.next();
    },
    TransitionDirective: SvelteDirective,
    AnimateDirective: SvelteDirective,
    UseDirective: SvelteDirective,
    // using it's own function instead of `SvelteDirective` because
    // StyleDirective doesn't have expressions and are generally already
    // handled by `Identifier`. This is the special case for the shorthand
    // eg <button style:height /> where the variable has the same name of
    // the css property
    StyleDirective(node, { path: path11, state: state2, next: next2 }) {
      if (node.value === true) {
        state2.scope.reference(id(node.name), path11.concat(node));
      }
      next2();
    }
    // TODO others
  });
  for (const id2 of possible_implicit_declarations) {
    const binding = scope.get(id2.name);
    if (binding) continue;
    scope.declare(id2, "legacy_reactive", "let");
  }
  for (const [scope2, { node, path: path11 }] of references) {
    scope2.reference(node, path11);
  }
  for (const [scope2, node] of updates) {
    for (const expression of unwrap_pattern(node)) {
      const left = object2(expression);
      const binding = left && scope2.get(left.name);
      if (binding !== null && left !== binding.node) {
        if (left === expression) {
          binding.reassigned = true;
        } else {
          binding.mutated = true;
        }
      }
    }
  }
  return {
    scope,
    scopes
  };
}
function set_scope(node, { next: next2, state }) {
  const scope = state.scopes.get(node);
  next2(scope !== void 0 && scope !== state.scope ? { ...state, scope } : state);
}
function get_rune(node, scope) {
  if (!node) return null;
  if (node.type !== "CallExpression") return null;
  const keypath = get_global_keypath(node.callee, scope);
  if (!keypath || !is_rune(keypath)) return null;
  return keypath;
}
function get_global_keypath(node, scope) {
  let n2 = node;
  let joined = "";
  while (n2.type === "MemberExpression") {
    if (n2.computed) return null;
    if (n2.property.type !== "Identifier") return null;
    joined = "." + n2.property.name + joined;
    n2 = n2.object;
  }
  if (n2.type === "CallExpression" && n2.callee.type === "Identifier") {
    joined = "()" + joined;
    n2 = n2.callee;
  }
  if (n2.type !== "Identifier") return null;
  const binding = scope.get(n2.name);
  if (binding !== null) return null;
  return n2.name + joined;
}

// node_modules/svelte/src/compiler/phases/2-analyze/utils/check_graph_for_cycles.js
function check_graph_for_cycles(edges) {
  const graph = edges.reduce((g, edge) => {
    const [u, v] = edge;
    if (!g.has(u)) g.set(u, []);
    if (!g.has(v)) g.set(v, []);
    g.get(u).push(v);
    return g;
  }, /* @__PURE__ */ new Map());
  const visited = /* @__PURE__ */ new Set();
  const on_stack = /* @__PURE__ */ new Set();
  const cycles = [];
  function visit(v) {
    var _a2;
    visited.add(v);
    on_stack.add(v);
    (_a2 = graph.get(v)) == null ? void 0 : _a2.forEach((w2) => {
      if (!visited.has(w2)) {
        visit(w2);
      } else if (on_stack.has(w2)) {
        cycles.push([...on_stack, w2]);
      }
    });
    on_stack.delete(v);
  }
  graph.forEach((_, v) => {
    if (!visited.has(v)) {
      visit(v);
    }
  });
  return cycles[0];
}

// node_modules/svelte/src/compiler/phases/css.js
var regex_css_browser_prefix = /^-((webkit)|(moz)|(o)|(ms))-/;
var regex_css_name_boundary = /^[\s,;}]$/;
function remove_css_prefix(name) {
  return name.replace(regex_css_browser_prefix, "");
}
var is_keyframes_node = (node) => remove_css_prefix(node.name) === "keyframes";

// node_modules/svelte/src/compiler/phases/2-analyze/css/utils.js
var UNKNOWN2 = {};
function gather_possible_values(node, is_class, set2, is_nested = false) {
  if (set2.has(UNKNOWN2)) {
    return;
  }
  if (node.type === "Literal") {
    set2.add(String(node.value));
  } else if (node.type === "ConditionalExpression") {
    gather_possible_values(node.consequent, is_class, set2, is_nested);
    gather_possible_values(node.alternate, is_class, set2, is_nested);
  } else if (node.type === "LogicalExpression") {
    if (node.operator === "&&") {
      const left = /* @__PURE__ */ new Set();
      gather_possible_values(node.left, is_class, left, is_nested);
      if (left.has(UNKNOWN2)) {
        if (!is_class || !is_nested) {
          set2.add("");
          set2.add(false);
          set2.add(NaN);
          set2.add(0);
        }
      } else {
        for (const value of left) {
          if (!value && value != void 0 && (!is_class || !is_nested)) {
            set2.add(value);
          }
        }
      }
      gather_possible_values(node.right, is_class, set2, is_nested);
    } else {
      gather_possible_values(node.left, is_class, set2, is_nested);
      gather_possible_values(node.right, is_class, set2, is_nested);
    }
  } else if (is_class && node.type === "ArrayExpression") {
    for (const entry of node.elements) {
      if (entry) {
        gather_possible_values(entry, is_class, set2, true);
      }
    }
  } else if (is_class && node.type === "ObjectExpression") {
    for (const property of node.properties) {
      if (property.type === "Property" && !property.computed && (property.key.type === "Identifier" || property.key.type === "Literal")) {
        set2.add(
          property.key.type === "Identifier" ? property.key.name : String(property.key.value)
        );
      } else {
        set2.add(UNKNOWN2);
      }
    }
  } else {
    set2.add(UNKNOWN2);
  }
}
function get_possible_values(chunk, is_class) {
  const values = /* @__PURE__ */ new Set();
  if (chunk.type === "Text") {
    values.add(chunk.data);
  } else {
    gather_possible_values(chunk.expression, is_class, values);
  }
  if (values.has(UNKNOWN2)) return null;
  return [...values].map((value) => String(value));
}
function get_parent_rules(rule) {
  const rules = [];
  while (rule) {
    rules.push(rule);
    rule = rule.metadata.parent_rule;
  }
  return rules;
}
function is_global(relative_selector) {
  const first = relative_selector.selectors[0];
  return first.type === "PseudoClassSelector" && first.name === "global" && (first.args === null || // Only these two selector types keep the whole selector global, because e.g.
  // :global(button).x means that the selector is still scoped because of the .x
  relative_selector.selectors.every(
    (selector) => is_unscoped_pseudo_class(selector) || selector.type === "PseudoElementSelector"
  ));
}
function is_unscoped_pseudo_class(selector) {
  return selector.type === "PseudoClassSelector" && // These make the selector scoped
  (selector.name !== "has" && selector.name !== "is" && selector.name !== "where" && // Not is special because we want to scope as specific as possible, but because :not
  // inverses the result, we want to leave the unscoped, too. The exception is more than
  // one selector in the :not (.e.g :not(.x .y)), then .x and .y should be scoped
  (selector.name !== "not" || selector.args === null || selector.args.children.every((c2) => c2.children.length === 1)) || // selectors with has/is/where/not can also be global if all their children are global
  selector.args === null || selector.args.children.every((c2) => c2.children.every((r) => is_global(r))));
}
function is_outer_global(relative_selector) {
  const first = relative_selector.selectors[0];
  return first.type === "PseudoClassSelector" && first.name === "global" && (first.args === null || // Only these two selector types can keep the whole selector global, because e.g.
  // :global(button).x means that the selector is still scoped because of the .x
  relative_selector.selectors.every(
    (selector) => selector.type === "PseudoClassSelector" || selector.type === "PseudoElementSelector"
  ));
}

// node_modules/svelte/src/compiler/phases/2-analyze/css/css-analyze.js
function is_global_block_selector(simple_selector) {
  return simple_selector.type === "PseudoClassSelector" && simple_selector.name === "global" && simple_selector.args === null;
}
function is_unscoped(path11) {
  return path11.filter((node) => node.type === "Rule").every((node) => node.metadata.has_global_selectors);
}
function is_in_global_block(path11) {
  return path11.some((node) => node.type === "Rule" && node.metadata.is_global_block);
}
var css_visitors = {
  Atrule(node, context) {
    var _a2;
    if (is_keyframes_node(node)) {
      if (!node.prelude.startsWith("-global-") && !is_in_global_block(context.path)) {
        context.state.keyframes.push(node.prelude);
      } else if (node.prelude.startsWith("-global-")) {
        (_a2 = context.state.analysis.css).has_global || (_a2.has_global = is_unscoped(context.path));
      }
    }
    context.next();
  },
  ComplexSelector(node, context) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    context.next();
    {
      const global = node.children.find(is_global);
      if (global) {
        const is_nested = ((_a2 = context.path.at(-2)) == null ? void 0 : _a2.type) === "PseudoClassSelector";
        if (is_nested && !global.selectors[0].args) {
          css_global_block_invalid_placement(global.selectors[0]);
        }
        const idx = node.children.indexOf(global);
        if (global.selectors[0].args !== null && idx !== 0 && idx !== node.children.length - 1) {
          for (let i = idx + 1; i < node.children.length; i++) {
            if (!is_global(node.children[i])) {
              css_global_invalid_placement(global.selectors[0]);
            }
          }
        }
      }
    }
    for (const relative_selector of node.children) {
      for (let i = 0; i < relative_selector.selectors.length; i++) {
        const selector = relative_selector.selectors[i];
        if (selector.type === "PseudoClassSelector" && selector.name === "global") {
          const child = (_b = selector.args) == null ? void 0 : _b.children[0].children[0];
          if ((child == null ? void 0 : child.selectors[0].type) === "TypeSelector" && i !== 0) {
            css_global_invalid_selector_list(selector);
          }
          if (((_c = relative_selector.selectors[i + 1]) == null ? void 0 : _c.type) === "TypeSelector") {
            css_type_selector_invalid_placement(relative_selector.selectors[i + 1]);
          }
          if (selector.args !== null && selector.args.children.length > 1 && (node.children.length > 1 || relative_selector.selectors.length > 1)) {
            css_global_invalid_selector(selector);
          }
        }
      }
    }
    node.metadata.rule = context.state.rule;
    node.metadata.is_global = node.children.every(
      ({ metadata }) => metadata.is_global || metadata.is_global_like
    );
    (_d = node.metadata).used || (_d.used = node.metadata.is_global);
    if (((_e = node.metadata.rule) == null ? void 0 : _e.metadata.parent_rule) && ((_g = (_f = node.children[0]) == null ? void 0 : _f.selectors[0]) == null ? void 0 : _g.type) === "NestingSelector") {
      const first = (_h = node.children[0]) == null ? void 0 : _h.selectors[1];
      const no_nesting_scope = (first == null ? void 0 : first.type) !== "PseudoClassSelector" || is_unscoped_pseudo_class(first);
      const parent_is_global = node.metadata.rule.metadata.parent_rule.prelude.children.some(
        (child) => child.children.length === 1 && child.children[0].metadata.is_global
      );
      if (no_nesting_scope && parent_is_global) {
        node.metadata.used = true;
      }
    }
  },
  RelativeSelector(node, context) {
    var _a2, _b, _c, _d;
    const parent = (
      /** @type {AST.CSS.ComplexSelector} */
      context.path.at(-1)
    );
    if (node.combinator != null && !((_a2 = context.state.rule) == null ? void 0 : _a2.metadata.parent_rule) && parent.children[0] === node && ((_b = context.path.at(-3)) == null ? void 0 : _b.type) !== "PseudoClassSelector") {
      css_selector_invalid(node.combinator);
    }
    node.metadata.is_global = node.selectors.length >= 1 && is_global(node);
    if (node.selectors.length >= 1 && node.selectors.every(
      (selector) => selector.type === "PseudoClassSelector" || selector.type === "PseudoElementSelector"
    )) {
      const first = node.selectors[0];
      (_c = node.metadata).is_global_like || (_c.is_global_like = first.type === "PseudoClassSelector" && first.name === "host" || first.type === "PseudoElementSelector" && [
        "view-transition",
        "view-transition-group",
        "view-transition-old",
        "view-transition-new",
        "view-transition-image-pair"
      ].includes(first.name));
    }
    (_d = node.metadata).is_global_like || (_d.is_global_like = node.selectors.some(
      (child) => child.type === "PseudoClassSelector" && child.name === "root"
    ) && // :root.y:has(.x) is not a global selector because while .y is unscoped, .x inside `:has(...)` should be scoped
    !node.selectors.some((child) => child.type === "PseudoClassSelector" && child.name === "has"));
    if (node.metadata.is_global_like || node.metadata.is_global) {
      for (const child of node.selectors) {
        walk(
          /** @type {AST.CSS.Node} */
          child,
          null,
          {
            ComplexSelector(node2, context2) {
              node2.metadata.used = true;
              context2.next();
            }
          }
        );
      }
    }
    context.next();
  },
  Rule(node, context) {
    var _a2, _b, _c;
    node.metadata.parent_rule = context.state.rule;
    for (const complex_selector of node.prelude.children) {
      let is_global_block = false;
      for (let selector_idx = 0; selector_idx < complex_selector.children.length; selector_idx++) {
        const child = complex_selector.children[selector_idx];
        const idx = child.selectors.findIndex(is_global_block_selector);
        if (is_global_block) {
          child.metadata.is_global_like = true;
        }
        if (idx === 0) {
          if (child.selectors.length > 1 && selector_idx === 0 && node.metadata.parent_rule === null) {
            css_global_block_invalid_modifier_start(child.selectors[1]);
          } else {
            node.metadata.is_global_block = is_global_block = true;
            for (let i = 1; i < child.selectors.length; i++) {
              walk(
                /** @type {AST.CSS.Node} */
                child.selectors[i],
                null,
                {
                  ComplexSelector(node2) {
                    node2.metadata.used = true;
                  }
                }
              );
            }
            if (child.combinator && child.combinator.name !== " ") {
              css_global_block_invalid_combinator(child, child.combinator.name);
            }
            const declaration2 = node.block.children.find((child2) => child2.type === "Declaration");
            const is_lone_global = complex_selector.children.length === 1 && complex_selector.children[0].selectors.length === 1;
            if (is_lone_global && node.prelude.children.length > 1) {
              css_global_block_invalid_list(node.prelude);
            }
            if (declaration2 && // :global { color: red; } is invalid, but foo :global { color: red; } is valid
            node.prelude.children.length === 1 && is_lone_global) {
              css_global_block_invalid_declaration(declaration2);
            }
          }
        } else if (idx !== -1) {
          css_global_block_invalid_modifier(child.selectors[idx]);
        }
      }
      if (node.metadata.is_global_block && !is_global_block) {
        css_global_block_invalid_list(node.prelude);
      }
    }
    const state = { ...context.state, rule: node };
    context.visit(node.prelude, state);
    for (const selector of node.prelude.children) {
      (_a2 = node.metadata).has_global_selectors || (_a2.has_global_selectors = selector.metadata.is_global);
      (_b = node.metadata).has_local_selectors || (_b.has_local_selectors = !selector.metadata.is_global);
    }
    (_c = context.state.analysis.css).has_global || (_c.has_global = node.metadata.has_global_selectors && node.block.children.filter((child) => child.type === "Declaration").length > 0 && is_unscoped(context.path));
    context.visit(node.block, state);
  },
  NestingSelector(node, context) {
    var _a2, _b;
    const rule = (
      /** @type {AST.CSS.Rule} */
      context.state.rule
    );
    const parent_rule = rule.metadata.parent_rule;
    if (!parent_rule) {
      const children = rule.prelude.children;
      const selectors = children[0].children[0].selectors;
      if (children.length > 1 || selectors.length > 1 || selectors[0].type !== "PseudoClassSelector" || selectors[0].name !== "global" || ((_b = (_a2 = selectors[0].args) == null ? void 0 : _a2.children[0]) == null ? void 0 : _b.children[0].selectors[0]) !== node) {
        css_nesting_selector_invalid_placement(node);
      }
    } else if (
      // :global { &.foo { ... } } is invalid
      parent_rule.metadata.is_global_block && !parent_rule.metadata.parent_rule && parent_rule.prelude.children[0].children.length === 1 && parent_rule.prelude.children[0].children[0].selectors.length === 1
    ) {
      css_global_block_invalid_modifier_start(node);
    }
    context.next();
  }
};
function analyze_css(stylesheet, analysis) {
  const css_state = {
    keyframes: analysis.css.keyframes,
    rule: null,
    analysis
  };
  walk(stylesheet, css_state, css_visitors);
}

// node_modules/svelte/src/compiler/phases/2-analyze/css/css-prune.js
var NODE_PROBABLY_EXISTS = 0;
var NODE_DEFINITELY_EXISTS = 1;
var FORWARD = 0;
var BACKWARD = 1;
var whitelist_attribute_selector = /* @__PURE__ */ new Map([
  ["details", ["open"]],
  ["dialog", ["open"]]
]);
var descendant_combinator = {
  type: "Combinator",
  name: " ",
  start: -1,
  end: -1
};
var nesting_selector = {
  type: "RelativeSelector",
  start: -1,
  end: -1,
  combinator: null,
  selectors: [
    {
      type: "NestingSelector",
      name: "&",
      start: -1,
      end: -1
    }
  ],
  metadata: {
    is_global: false,
    is_global_like: false,
    scoped: false
  }
};
var any_selector = {
  type: "RelativeSelector",
  start: -1,
  end: -1,
  combinator: null,
  selectors: [
    {
      type: "TypeSelector",
      name: "*",
      start: -1,
      end: -1
    }
  ],
  metadata: {
    is_global: false,
    is_global_like: false,
    scoped: false
  }
};
var seen = /* @__PURE__ */ new Set();
function prune(stylesheet, element2) {
  walk(
    /** @type {Compiler.AST.CSS.Node} */
    stylesheet,
    null,
    {
      Rule(node, context) {
        if (node.metadata.is_global_block) {
          context.visit(node.prelude);
        } else {
          context.next();
        }
      },
      ComplexSelector(node) {
        const selectors = get_relative_selectors(node);
        seen.clear();
        if (apply_selector(
          selectors,
          /** @type {Compiler.AST.CSS.Rule} */
          node.metadata.rule,
          element2,
          BACKWARD
        )) {
          node.metadata.used = true;
        }
      }
    }
  );
}
function get_relative_selectors(node) {
  var _a2;
  const selectors = truncate(node);
  if (((_a2 = node.metadata.rule) == null ? void 0 : _a2.metadata.parent_rule) && selectors.length > 0) {
    let has_explicit_nesting_selector = false;
    for (let selector of selectors) {
      walk(selector, null, {
        // @ts-ignore
        NestingSelector() {
          has_explicit_nesting_selector = true;
        }
      });
      if (has_explicit_nesting_selector) break;
    }
    if (!has_explicit_nesting_selector) {
      if (selectors[0].combinator === null) {
        selectors[0] = {
          ...selectors[0],
          combinator: descendant_combinator
        };
      }
      selectors.unshift(nesting_selector);
    }
  }
  return selectors;
}
function truncate(node) {
  const i = node.children.findLastIndex(({ metadata, selectors }) => {
    const first = selectors[0];
    return (
      // not after a :global selector
      !metadata.is_global_like && !(first.type === "PseudoClassSelector" && first.name === "global" && first.args === null) && // not a :global(...) without a :has/is/where(...) modifier that is scoped
      !metadata.is_global
    );
  });
  return node.children.slice(0, i + 1).map((child) => {
    const root = child.selectors.find((s) => s.type === "PseudoClassSelector" && s.name === "root");
    if (!root || child.metadata.is_global_like) return child;
    return {
      ...child,
      selectors: child.selectors.filter((s) => s.type === "PseudoClassSelector" && s.name === "has")
    };
  });
}
function apply_selector(relative_selectors, rule, element2, direction) {
  const rest_selectors = relative_selectors.slice();
  const relative_selector = direction === FORWARD ? rest_selectors.shift() : rest_selectors.pop();
  const matched = !!relative_selector && relative_selector_might_apply_to_node(relative_selector, rule, element2, direction) && apply_combinator(relative_selector, rest_selectors, rule, element2, direction);
  if (matched) {
    if (!is_outer_global(relative_selector)) {
      relative_selector.metadata.scoped = true;
    }
    element2.metadata.scoped = true;
  }
  return matched;
}
function apply_combinator(relative_selector, rest_selectors, rule, node, direction) {
  var _a2;
  const combinator = direction == FORWARD ? (_a2 = rest_selectors[0]) == null ? void 0 : _a2.combinator : relative_selector.combinator;
  if (!combinator) return true;
  switch (combinator.name) {
    case " ":
    case ">": {
      const is_adjacent = combinator.name === ">";
      const parents = direction === FORWARD ? get_descendant_elements(node, is_adjacent) : get_ancestor_elements(node, is_adjacent);
      let parent_matched = false;
      for (const parent of parents) {
        if (apply_selector(rest_selectors, rule, parent, direction)) {
          parent_matched = true;
        }
      }
      return parent_matched || direction === BACKWARD && (!is_adjacent || parents.length === 0) && rest_selectors.every((selector) => is_global2(selector, rule));
    }
    case "+":
    case "~": {
      const siblings = get_possible_element_siblings(node, direction, combinator.name === "+");
      let sibling_matched = false;
      for (const possible_sibling of siblings.keys()) {
        if (possible_sibling.type === "RenderTag" || possible_sibling.type === "SlotElement" || possible_sibling.type === "Component") {
          if (rest_selectors.length === 1 && rest_selectors[0].metadata.is_global) {
            sibling_matched = true;
          }
        } else if (apply_selector(rest_selectors, rule, possible_sibling, direction)) {
          sibling_matched = true;
        }
      }
      return sibling_matched || direction === BACKWARD && get_element_parent(node) === null && rest_selectors.every((selector) => is_global2(selector, rule));
    }
    default:
      return true;
  }
}
function is_global2(selector, rule) {
  if (selector.metadata.is_global || selector.metadata.is_global_like) {
    return true;
  }
  let explicitly_global = false;
  for (const s of selector.selectors) {
    let selector_list = null;
    let can_be_global = false;
    let owner = rule;
    if (s.type === "PseudoClassSelector") {
      if ((s.name === "is" || s.name === "where") && s.args) {
        selector_list = s.args;
      } else {
        can_be_global = is_unscoped_pseudo_class(s);
      }
    }
    if (s.type === "NestingSelector") {
      owner = /** @type {Compiler.AST.CSS.Rule} */
      rule.metadata.parent_rule;
      selector_list = owner.prelude;
    }
    const has_global_selectors = !!(selector_list == null ? void 0 : selector_list.children.some((complex_selector) => {
      return complex_selector.children.every(
        (relative_selector) => is_global2(relative_selector, owner)
      );
    }));
    explicitly_global || (explicitly_global = has_global_selectors);
    if (!has_global_selectors && !can_be_global) {
      return false;
    }
  }
  return explicitly_global || selector.selectors.length === 0;
}
var regex_backslash_and_following_character = /\\(.)/g;
function relative_selector_might_apply_to_node(relative_selector, rule, element2, direction) {
  var _a2;
  const has_selectors = [];
  const other_selectors = [];
  for (const selector of relative_selector.selectors) {
    if (selector.type === "PseudoClassSelector" && selector.name === "has" && selector.args) {
      has_selectors.push(selector);
    } else {
      other_selectors.push(selector);
    }
  }
  if (has_selectors.length > 0) {
    const rules = get_parent_rules(rule);
    const include_self = rules.some((r) => r.prelude.children.some((c2) => c2.children.some((s) => is_global2(s, r)))) || rules[rules.length - 1].prelude.children.some(
      (c2) => c2.children.some(
        (r) => r.selectors.some(
          (s) => s.type === "PseudoClassSelector" && (s.name === "root" || s.name === "global" && s.args)
        )
      )
    );
    for (const has_selector of has_selectors) {
      const complex_selectors = (
        /** @type {Compiler.AST.CSS.SelectorList} */
        has_selector.args.children
      );
      let matched = false;
      for (const complex_selector of complex_selectors) {
        const [first, ...rest2] = truncate(complex_selector);
        if (!first) {
          complex_selector.metadata.used = true;
          matched = true;
          continue;
        }
        if (include_self) {
          const selector_including_self = [
            first.combinator ? { ...first, combinator: null } : first,
            ...rest2
          ];
          if (apply_selector(selector_including_self, rule, element2, FORWARD)) {
            complex_selector.metadata.used = true;
            matched = true;
          }
        }
        const selector_excluding_self = [
          any_selector,
          first.combinator ? first : { ...first, combinator: descendant_combinator },
          ...rest2
        ];
        if (apply_selector(selector_excluding_self, rule, element2, FORWARD)) {
          complex_selector.metadata.used = true;
          matched = true;
        }
      }
      if (!matched) {
        return false;
      }
    }
  }
  for (const selector of other_selectors) {
    if (selector.type === "Percentage" || selector.type === "Nth") continue;
    const name = selector.name.replace(regex_backslash_and_following_character, "$1");
    switch (selector.type) {
      case "PseudoClassSelector": {
        if (name === "host" || name === "root") return false;
        if (name === "global" && selector.args !== null && relative_selector.selectors.length === 1) {
          const args = selector.args;
          const complex_selector = args.children[0];
          return apply_selector(complex_selector.children, rule, element2, BACKWARD);
        }
        if (name === "global" && selector.args === null) return true;
        if (name === "not" && selector.args) {
          for (const complex_selector of selector.args.children) {
            walk(complex_selector, null, {
              ComplexSelector(node, context) {
                node.metadata.used = true;
                context.next();
              }
            });
            const relative = truncate(complex_selector);
            if (complex_selector.children.length > 1) {
              for (const selector2 of relative) {
                selector2.metadata.scoped = true;
              }
              let el = element2;
              while (el) {
                el.metadata.scoped = true;
                el = get_element_parent(el);
              }
            }
          }
          break;
        }
        if ((name === "is" || name === "where") && selector.args) {
          let matched = false;
          for (const complex_selector of selector.args.children) {
            const relative = truncate(complex_selector);
            const is_global3 = relative.length === 0;
            if (is_global3) {
              complex_selector.metadata.used = true;
              matched = true;
            } else if (apply_selector(relative, rule, element2, BACKWARD)) {
              complex_selector.metadata.used = true;
              matched = true;
            } else if (complex_selector.children.length > 1 && (name == "is" || name == "where")) {
              complex_selector.metadata.used = true;
              matched = true;
              for (const selector2 of relative) {
                selector2.metadata.scoped = true;
              }
            }
          }
          if (!matched) {
            return false;
          }
        }
        break;
      }
      case "PseudoElementSelector": {
        break;
      }
      case "AttributeSelector": {
        const whitelisted = whitelist_attribute_selector.get(element2.name.toLowerCase());
        if (!(whitelisted == null ? void 0 : whitelisted.includes(selector.name.toLowerCase())) && !attribute_matches(
          element2,
          selector.name,
          selector.value && unquote(selector.value),
          selector.matcher,
          ((_a2 = selector.flags) == null ? void 0 : _a2.includes("i")) ?? false
        )) {
          return false;
        }
        break;
      }
      case "ClassSelector": {
        if (!attribute_matches(element2, "class", name, "~=", false) && !element2.attributes.some(
          (attribute) => attribute.type === "ClassDirective" && attribute.name === name
        )) {
          return false;
        }
        break;
      }
      case "IdSelector": {
        if (!attribute_matches(element2, "id", name, "=", false)) {
          return false;
        }
        break;
      }
      case "TypeSelector": {
        if (element2.name.toLowerCase() !== name.toLowerCase() && name !== "*" && element2.type !== "SvelteElement") {
          return false;
        }
        break;
      }
      case "NestingSelector": {
        let matched = false;
        const parent = (
          /** @type {Compiler.AST.CSS.Rule} */
          rule.metadata.parent_rule
        );
        for (const complex_selector of parent.prelude.children) {
          if (apply_selector(get_relative_selectors(complex_selector), parent, element2, direction) || complex_selector.children.every((s) => is_global2(s, parent))) {
            complex_selector.metadata.used = true;
            matched = true;
          }
        }
        if (!matched) {
          return false;
        }
        break;
      }
    }
  }
  return true;
}
function test_attribute(operator, expected_value, case_insensitive, value) {
  if (case_insensitive) {
    expected_value = expected_value.toLowerCase();
    value = value.toLowerCase();
  }
  switch (operator) {
    case "=":
      return value === expected_value;
    case "~=":
      return value.split(/\s/).includes(expected_value);
    case "|=":
      return `${value}-`.startsWith(`${expected_value}-`);
    case "^=":
      return value.startsWith(expected_value);
    case "$=":
      return value.endsWith(expected_value);
    case "*=":
      return value.includes(expected_value);
    default:
      throw new Error("this shouldn't happen");
  }
}
function attribute_matches(node, name, expected_value, operator, case_insensitive) {
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute") return true;
    if (attribute.type === "BindDirective" && attribute.name === name) return true;
    if (attribute.type !== "Attribute") continue;
    if (attribute.name.toLowerCase() !== name.toLowerCase()) continue;
    if (attribute.value === true) return operator === null;
    if (expected_value === null) return true;
    if (is_text_attribute(attribute)) {
      return test_attribute(operator, expected_value, case_insensitive, attribute.value[0].data);
    }
    const chunks = get_attribute_chunks(attribute.value);
    const possible_values = /* @__PURE__ */ new Set();
    let prev_values = [];
    for (const chunk of chunks) {
      const current_possible_values = get_possible_values(chunk, name === "class");
      if (!current_possible_values) return true;
      if (prev_values.length > 0) {
        const start_with_space = [];
        const remaining = [];
        current_possible_values.forEach((current_possible_value) => {
          if (regex_starts_with_whitespace.test(current_possible_value)) {
            start_with_space.push(current_possible_value);
          } else {
            remaining.push(current_possible_value);
          }
        });
        if (remaining.length > 0) {
          if (start_with_space.length > 0) {
            prev_values.forEach((prev_value) => possible_values.add(prev_value));
          }
          const combined = [];
          prev_values.forEach((prev_value) => {
            remaining.forEach((value) => {
              combined.push(prev_value + value);
            });
          });
          prev_values = combined;
          start_with_space.forEach((value) => {
            if (regex_ends_with_whitespace.test(value)) {
              possible_values.add(value);
            } else {
              prev_values.push(value);
            }
          });
          continue;
        } else {
          prev_values.forEach((prev_value) => possible_values.add(prev_value));
          prev_values = [];
        }
      }
      current_possible_values.forEach((current_possible_value) => {
        if (regex_ends_with_whitespace.test(current_possible_value)) {
          possible_values.add(current_possible_value);
        } else {
          prev_values.push(current_possible_value);
        }
      });
      if (prev_values.length < current_possible_values.length) {
        prev_values.push(" ");
      }
      if (prev_values.length > 20) {
        return true;
      }
    }
    prev_values.forEach((prev_value) => possible_values.add(prev_value));
    for (const value of possible_values) {
      if (test_attribute(operator, expected_value, case_insensitive, value)) return true;
    }
  }
  return false;
}
function unquote(str) {
  if (str[0] === str[str.length - 1] && str[0] === "'" || str[0] === '"') {
    return str.slice(1, str.length - 1);
  }
  return str;
}
function get_ancestor_elements(node, adjacent_only, seen2 = /* @__PURE__ */ new Set()) {
  const ancestors = [];
  const path11 = node.metadata.path;
  let i = path11.length;
  while (i--) {
    const parent = path11[i];
    if (parent.type === "SnippetBlock") {
      if (!seen2.has(parent)) {
        seen2.add(parent);
        for (const site of parent.metadata.sites) {
          ancestors.push(...get_ancestor_elements(site, adjacent_only, seen2));
        }
      }
      break;
    }
    if (parent.type === "RegularElement" || parent.type === "SvelteElement") {
      ancestors.push(parent);
      if (adjacent_only) {
        break;
      }
    }
  }
  return ancestors;
}
function get_descendant_elements(node, adjacent_only, seen2 = /* @__PURE__ */ new Set()) {
  const descendants = [];
  function walk_children(node2) {
    walk(node2, null, {
      _(node3, context) {
        if (node3.type === "RegularElement" || node3.type === "SvelteElement") {
          descendants.push(node3);
          if (!adjacent_only) {
            context.next();
          }
        } else if (node3.type === "RenderTag") {
          for (const snippet of node3.metadata.snippets) {
            if (seen2.has(snippet)) continue;
            seen2.add(snippet);
            walk_children(snippet.body);
          }
        } else {
          context.next();
        }
      }
    });
  }
  walk_children(node.type === "RenderTag" ? node : node.fragment);
  return descendants;
}
function get_element_parent(node) {
  let path11 = node.metadata.path;
  let i = path11.length;
  while (i--) {
    const parent = path11[i];
    if (parent.type === "RegularElement" || parent.type === "SvelteElement") {
      return parent;
    }
  }
  return null;
}
function get_possible_element_siblings(node, direction, adjacent_only, seen2 = /* @__PURE__ */ new Set()) {
  const result = /* @__PURE__ */ new Map();
  const path11 = node.metadata.path;
  let current2 = node;
  let i = path11.length;
  while (i--) {
    const fragment2 = (
      /** @type {Compiler.AST.Fragment} */
      path11[i--]
    );
    let j = fragment2.nodes.indexOf(current2) + (direction === FORWARD ? 1 : -1);
    while (j >= 0 && j < fragment2.nodes.length) {
      const node2 = fragment2.nodes[j];
      if (node2.type === "RegularElement") {
        const has_slot_attribute = node2.attributes.some(
          (attr) => attr.type === "Attribute" && attr.name.toLowerCase() === "slot"
        );
        if (!has_slot_attribute) {
          result.set(node2, NODE_DEFINITELY_EXISTS);
          if (adjacent_only) {
            return result;
          }
        }
      } else if (is_block(node2) || node2.type === "Component") {
        if (node2.type === "SlotElement" || node2.type === "Component") {
          result.set(node2, NODE_PROBABLY_EXISTS);
        }
        const possible_last_child = get_possible_nested_siblings(node2, direction, adjacent_only);
        add_to_map(possible_last_child, result);
        if (adjacent_only && node2.type !== "Component" && has_definite_elements(possible_last_child)) {
          return result;
        }
      } else if (node2.type === "SvelteElement") {
        result.set(node2, NODE_PROBABLY_EXISTS);
      } else if (node2.type === "RenderTag") {
        result.set(node2, NODE_PROBABLY_EXISTS);
        for (const snippet of node2.metadata.snippets) {
          add_to_map(get_possible_nested_siblings(snippet, direction, adjacent_only), result);
        }
      }
      j = direction === FORWARD ? j + 1 : j - 1;
    }
    current2 = path11[i];
    if (!current2) break;
    if (current2.type === "Component" || current2.type === "SvelteComponent" || current2.type === "SvelteSelf") {
      continue;
    }
    if (current2.type === "SnippetBlock") {
      if (seen2.has(current2)) break;
      seen2.add(current2);
      for (const site of current2.metadata.sites) {
        const siblings = get_possible_element_siblings(site, direction, adjacent_only, seen2);
        add_to_map(siblings, result);
        if (adjacent_only && current2.metadata.sites.size === 1 && has_definite_elements(siblings)) {
          return result;
        }
      }
    }
    if (!is_block(current2)) break;
    if (current2.type === "EachBlock" && fragment2 === current2.body) {
      add_to_map(get_possible_nested_siblings(current2, direction, adjacent_only), result);
    }
  }
  return result;
}
function get_possible_nested_siblings(node, direction, adjacent_only, seen2 = /* @__PURE__ */ new Set()) {
  let fragments = [];
  switch (node.type) {
    case "EachBlock":
      fragments.push(node.body, node.fallback);
      break;
    case "IfBlock":
      fragments.push(node.consequent, node.alternate);
      break;
    case "AwaitBlock":
      fragments.push(node.pending, node.then, node.catch);
      break;
    case "KeyBlock":
    case "SlotElement":
      fragments.push(node.fragment);
      break;
    case "SnippetBlock":
      if (seen2.has(node)) {
        return /* @__PURE__ */ new Map();
      }
      seen2.add(node);
      fragments.push(node.body);
      break;
    case "Component":
      fragments.push(node.fragment, ...[...node.metadata.snippets].map((s) => s.body));
      break;
  }
  const result = /* @__PURE__ */ new Map();
  let exhaustive = node.type !== "SlotElement" && node.type !== "SnippetBlock";
  for (const fragment2 of fragments) {
    if (fragment2 == null) {
      exhaustive = false;
      continue;
    }
    const map = loop_child(fragment2.nodes, direction, adjacent_only, seen2);
    exhaustive && (exhaustive = has_definite_elements(map));
    add_to_map(map, result);
  }
  if (!exhaustive) {
    for (const key2 of result.keys()) {
      result.set(key2, NODE_PROBABLY_EXISTS);
    }
  }
  return result;
}
function has_definite_elements(result) {
  if (result.size === 0) return false;
  for (const exist of result.values()) {
    if (exist === NODE_DEFINITELY_EXISTS) {
      return true;
    }
  }
  return false;
}
function add_to_map(from, to) {
  from.forEach((exist, element2) => {
    to.set(element2, higher_existence(exist, to.get(element2)));
  });
}
function higher_existence(exist1, exist2) {
  if (exist2 === void 0) return exist1;
  return exist1 > exist2 ? exist1 : exist2;
}
function loop_child(children, direction, adjacent_only, seen2) {
  const result = /* @__PURE__ */ new Map();
  let i = direction === FORWARD ? 0 : children.length - 1;
  while (i >= 0 && i < children.length) {
    const child = children[i];
    if (child.type === "RegularElement") {
      result.set(child, NODE_DEFINITELY_EXISTS);
      if (adjacent_only) {
        break;
      }
    } else if (child.type === "SvelteElement") {
      result.set(child, NODE_PROBABLY_EXISTS);
    } else if (child.type === "RenderTag") {
      for (const snippet of child.metadata.snippets) {
        add_to_map(get_possible_nested_siblings(snippet, direction, adjacent_only, seen2), result);
      }
    } else if (is_block(child)) {
      const child_result = get_possible_nested_siblings(child, direction, adjacent_only, seen2);
      add_to_map(child_result, result);
      if (adjacent_only && has_definite_elements(child_result)) {
        break;
      }
    }
    i = direction === FORWARD ? i + 1 : i - 1;
  }
  return result;
}
function is_block(node) {
  return node.type === "IfBlock" || node.type === "EachBlock" || node.type === "AwaitBlock" || node.type === "KeyBlock" || node.type === "SlotElement";
}

// node_modules/svelte/src/compiler/phases/2-analyze/css/css-warn.js
function warn_unused(stylesheet) {
  walk(stylesheet, { stylesheet }, visitors2);
}
var visitors2 = {
  Atrule(node, context) {
    if (!is_keyframes_node(node)) {
      context.next();
    }
  },
  PseudoClassSelector(node, context) {
    if (node.name === "is" || node.name === "where") {
      context.next();
    }
  },
  ComplexSelector(node, context) {
    var _a2, _b;
    if (!node.metadata.used && // prevent double-marking of `.unused:is(.unused)`
    (((_a2 = context.path.at(-2)) == null ? void 0 : _a2.type) !== "PseudoClassSelector" || /** @type {AST.CSS.ComplexSelector} */
    ((_b = context.path.at(-4)) == null ? void 0 : _b.metadata.used))) {
      const content = context.state.stylesheet.content;
      const text2 = content.styles.substring(node.start - content.start, node.end - content.start);
      css_unused_selector(node, text2);
    }
    context.next();
  },
  Rule(node, context) {
    if (node.metadata.is_global_block) {
      context.visit(node.prelude);
    } else {
      context.next();
    }
  }
};

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/function.js
function visit_function(node, context) {
  node.metadata = {
    hoisted: false,
    hoisted_params: [],
    scope: context.state.scope
  };
  context.next({
    ...context.state,
    function_depth: context.state.function_depth + 1,
    expression: null
  });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ArrowFunctionExpression.js
function ArrowFunctionExpression(node, context) {
  visit_function(node, context);
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/AssignmentExpression.js
function AssignmentExpression(node, context) {
  validate_assignment(node, node.left, context);
  if (context.state.reactive_statement) {
    const id2 = node.left.type === "MemberExpression" ? object2(node.left) : node.left;
    if (id2 !== null) {
      for (const id3 of extract_identifiers(node.left)) {
        const binding = context.state.scope.get(id3.name);
        if (binding) {
          context.state.reactive_statement.assignments.add(binding);
        }
      }
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/fragment.js
function mark_subtree_dynamic(path11) {
  let i = path11.length;
  while (i--) {
    const node = path11[i];
    if (node.type === "Fragment") {
      if (node.metadata.dynamic) return;
      node.metadata.dynamic = true;
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/AttachTag.js
function AttachTag(node, context) {
  mark_subtree_dynamic(context.path);
  context.next({ ...context.state, expression: node.metadata.expression });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/Attribute.js
function Attribute(node, context) {
  context.next();
  const parent = (
    /** @type {AST.SvelteNode} */
    context.path.at(-1)
  );
  if (parent.type === "RegularElement") {
    if (node.name === "value" && parent.name === "option") {
      mark_subtree_dynamic(context.path);
    }
  }
  if (is_event_attribute(node)) {
    mark_subtree_dynamic(context.path);
  }
  if (cannot_be_set_statically(node.name)) {
    mark_subtree_dynamic(context.path);
  }
  if (node.name === "class" && !Array.isArray(node.value) && node.value !== true && node.value.expression.type !== "Literal" && node.value.expression.type !== "TemplateLiteral" && node.value.expression.type !== "BinaryExpression") {
    mark_subtree_dynamic(context.path);
    node.metadata.needs_clsx = true;
  }
  if (node.value !== true) {
    for (const chunk of get_attribute_chunks(node.value)) {
      if (chunk.type !== "ExpressionTag") continue;
      if (chunk.expression.type === "FunctionExpression" || chunk.expression.type === "ArrowFunctionExpression") {
        continue;
      }
    }
    if (is_event_attribute(node)) {
      const parent2 = context.path.at(-1);
      if ((parent2 == null ? void 0 : parent2.type) === "RegularElement" || (parent2 == null ? void 0 : parent2.type) === "SvelteElement") {
        context.state.analysis.uses_event_attributes = true;
      }
      const expression = get_attribute_expression(node);
      const delegated_event = get_delegated_event(node.name.slice(2), expression, context);
      if (delegated_event !== null) {
        if (delegated_event.hoisted) {
          delegated_event.function.metadata.hoisted = true;
        }
        node.metadata.delegated = delegated_event;
      }
    }
  }
}
var unhoisted = { hoisted: false };
function get_delegated_event(event_name, handler, context) {
  var _a2, _b, _c;
  if (!handler || !is_delegated(event_name)) {
    return null;
  }
  const element2 = context.path.at(-1);
  if ((element2 == null ? void 0 : element2.type) !== "RegularElement") {
    return null;
  }
  let target_function = null;
  let binding = null;
  if (element2.metadata.has_spread) {
    return unhoisted;
  }
  if (handler.type === "ArrowFunctionExpression" || handler.type === "FunctionExpression") {
    target_function = handler;
  } else if (handler.type === "Identifier") {
    binding = context.state.scope.get(handler.name);
    if (context.state.analysis.module.scope.references.has(handler.name)) {
      return unhoisted;
    }
    if (binding != null) {
      for (const { path: path11 } of binding.references) {
        const parent = path11.at(-1);
        if (parent === void 0) return unhoisted;
        const grandparent = path11.at(-2);
        let element3 = null;
        let event_name2 = null;
        if (parent.type === "OnDirective") {
          element3 = /** @type {AST.RegularElement} */
          grandparent;
          event_name2 = parent.name;
        } else if (parent.type === "ExpressionTag" && (grandparent == null ? void 0 : grandparent.type) === "Attribute" && is_event_attribute(grandparent)) {
          element3 = /** @type {AST.RegularElement} */
          path11.at(-3);
          const attribute = (
            /** @type {AST.Attribute} */
            grandparent
          );
          event_name2 = get_attribute_event_name(attribute.name);
        }
        if (element3 && event_name2) {
          if (element3.type !== "RegularElement" || element3.metadata.has_spread || !is_delegated(event_name2)) {
            return unhoisted;
          }
        } else if (parent.type !== "FunctionDeclaration" && parent.type !== "VariableDeclarator") {
          return unhoisted;
        }
      }
    }
    if (context.state.analysis.exports.find((node) => node.name === handler.name)) {
      return unhoisted;
    }
    if (binding == null ? void 0 : binding.is_function()) {
      target_function = binding.initial;
    }
  }
  if (target_function == null || target_function.params.length > 1) {
    return unhoisted;
  }
  const visited_references = /* @__PURE__ */ new Set();
  const scope = target_function.metadata.scope;
  for (const [reference] of scope.references) {
    if (reference === "arguments" || reference === "$host") return unhoisted;
    if (((_a2 = scope.get(`$${reference}`)) == null ? void 0 : _a2.kind) === "store_sub") return unhoisted;
    const binding2 = scope.get(reference);
    const local_binding = context.state.scope.get(reference);
    if (local_binding !== null && ((_b = local_binding.initial) == null ? void 0 : _b.type) === "SnippetBlock" && !local_binding.initial.metadata.can_hoist) {
      return unhoisted;
    }
    if (local_binding !== null && binding2 !== null && local_binding.node !== binding2.node) {
      return unhoisted;
    }
    if (binding2 !== null && binding2.kind === "store_sub" && visited_references.has(reference.slice(1))) {
      return unhoisted;
    }
    if (binding2 !== null && ((_c = binding2.initial) == null ? void 0 : _c.type) === "EachBlock") return unhoisted;
    if (binding2 !== null && // Bail out if the binding is a rest param
    (binding2.declaration_kind === "rest_param" || // Bail out if we reference anything from the EachBlock (for now) that mutates in non-runes mode,
    (!context.state.analysis.runes && binding2.kind === "each" || // or any normal not reactive bindings that are mutated.
    binding2.kind === "normal") && binding2.updated)) {
      return unhoisted;
    }
    visited_references.add(reference);
  }
  return { hoisted: true, function: target_function };
}
function get_attribute_event_name(event_name) {
  event_name = event_name.slice(2);
  if (is_capture_event(event_name)) {
    event_name = event_name.slice(0, -7);
  }
  return event_name;
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/AwaitBlock.js
function AwaitBlock(node, context) {
  validate_block_not_empty(node.pending, context);
  validate_block_not_empty(node.then, context);
  validate_block_not_empty(node.catch, context);
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, "#");
    if (node.value) {
      const start = (
        /** @type {number} */
        node.value.start
      );
      const match = context.state.analysis.source.substring(start - 10, start).match(/{(\s*):then\s+$/);
      if (match && match[1] !== "") {
        block_unexpected_character({ start: start - 10, end: start }, ":");
      }
    }
    if (node.error) {
      const start = (
        /** @type {number} */
        node.error.start
      );
      const match = context.state.analysis.source.substring(start - 10, start).match(/{(\s*):catch\s+$/);
      if (match && match[1] !== "") {
        block_unexpected_character({ start: start - 10, end: start }, ":");
      }
    }
  }
  mark_subtree_dynamic(context.path);
  context.next();
}

// node_modules/svelte/src/compiler/phases/bindings.js
var binding_properties = {
  // media
  currentTime: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true,
    bidirectional: true
  },
  duration: {
    valid_elements: ["audio", "video"],
    event: "durationchange",
    omit_in_ssr: true
  },
  focused: {},
  paused: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true,
    bidirectional: true
  },
  buffered: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  seekable: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  played: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  volume: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true,
    bidirectional: true
  },
  muted: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true,
    bidirectional: true
  },
  playbackRate: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true,
    bidirectional: true
  },
  seeking: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  ended: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  readyState: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  // video
  videoHeight: {
    valid_elements: ["video"],
    event: "resize",
    omit_in_ssr: true
  },
  videoWidth: {
    valid_elements: ["video"],
    event: "resize",
    omit_in_ssr: true
  },
  // img
  naturalWidth: {
    valid_elements: ["img"],
    event: "load",
    omit_in_ssr: true
  },
  naturalHeight: {
    valid_elements: ["img"],
    event: "load",
    omit_in_ssr: true
  },
  // document
  activeElement: {
    valid_elements: ["svelte:document"],
    omit_in_ssr: true
  },
  fullscreenElement: {
    valid_elements: ["svelte:document"],
    event: "fullscreenchange",
    omit_in_ssr: true
  },
  pointerLockElement: {
    valid_elements: ["svelte:document"],
    event: "pointerlockchange",
    omit_in_ssr: true
  },
  visibilityState: {
    valid_elements: ["svelte:document"],
    event: "visibilitychange",
    omit_in_ssr: true
  },
  // window
  innerWidth: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  innerHeight: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  outerWidth: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  outerHeight: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  scrollX: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true,
    bidirectional: true
  },
  scrollY: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true,
    bidirectional: true
  },
  online: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  devicePixelRatio: {
    valid_elements: ["svelte:window"],
    event: "resize",
    omit_in_ssr: true
  },
  // dimensions
  clientWidth: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  clientHeight: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  offsetWidth: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  offsetHeight: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  contentRect: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  contentBoxSize: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  borderBoxSize: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  devicePixelContentBoxSize: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  // checkbox/radio
  indeterminate: {
    event: "change",
    bidirectional: true,
    valid_elements: ["input"],
    omit_in_ssr: true
    // no corresponding attribute
  },
  checked: {
    valid_elements: ["input"],
    bidirectional: true
  },
  group: {
    valid_elements: ["input"],
    bidirectional: true
  },
  // various
  this: {
    omit_in_ssr: true
  },
  innerText: {
    invalid_elements: ["svelte:window", "svelte:document"],
    bidirectional: true
  },
  innerHTML: {
    invalid_elements: ["svelte:window", "svelte:document"],
    bidirectional: true
  },
  textContent: {
    invalid_elements: ["svelte:window", "svelte:document"],
    bidirectional: true
  },
  open: {
    event: "toggle",
    bidirectional: true,
    valid_elements: ["details"]
  },
  value: {
    valid_elements: ["input", "textarea", "select"],
    bidirectional: true
  },
  files: {
    valid_elements: ["input"],
    omit_in_ssr: true,
    bidirectional: true
  }
};

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/BindDirective.js
function BindDirective(node, context) {
  var _a2, _b, _c, _d, _e;
  const parent = context.path.at(-1);
  if ((parent == null ? void 0 : parent.type) === "RegularElement" || (parent == null ? void 0 : parent.type) === "SvelteElement" || (parent == null ? void 0 : parent.type) === "SvelteWindow" || (parent == null ? void 0 : parent.type) === "SvelteDocument" || (parent == null ? void 0 : parent.type) === "SvelteBody") {
    if (node.name in binding_properties) {
      const property = binding_properties[node.name];
      if (property.valid_elements && !property.valid_elements.includes(parent.name)) {
        bind_invalid_target(
          node,
          node.name,
          property.valid_elements.map((valid_element) => `<${valid_element}>`).join(", ")
        );
      }
      if (property.invalid_elements && property.invalid_elements.includes(parent.name)) {
        const valid_bindings = Object.entries(binding_properties).filter(([_, binding_property]) => {
          var _a3, _b2;
          return ((_a3 = binding_property.valid_elements) == null ? void 0 : _a3.includes(parent.name)) || !binding_property.valid_elements && !((_b2 = binding_property.invalid_elements) == null ? void 0 : _b2.includes(parent.name));
        }).map(([property_name]) => property_name).sort();
        bind_invalid_name(
          node,
          node.name,
          `Possible bindings for <${parent.name}> are ${valid_bindings.join(", ")}`
        );
      }
      if (parent.name === "input" && node.name !== "this") {
        const type = (
          /** @type {AST.Attribute | undefined} */
          parent.attributes.find((a) => a.type === "Attribute" && a.name === "type")
        );
        if (type && !is_text_attribute(type)) {
          if (node.name !== "value" || type.value === true) {
            attribute_invalid_type(type);
          }
        } else {
          if (node.name === "checked" && (type == null ? void 0 : type.value[0].data) !== "checkbox") {
            bind_invalid_target(node, node.name, '<input type="checkbox">');
          }
          if (node.name === "files" && (type == null ? void 0 : type.value[0].data) !== "file") {
            bind_invalid_target(node, node.name, '<input type="file">');
          }
        }
      }
      if (parent.name === "select" && node.name !== "this") {
        const multiple = parent.attributes.find(
          (a) => a.type === "Attribute" && a.name === "multiple" && !is_text_attribute(a) && a.value !== true
        );
        if (multiple) {
          attribute_invalid_multiple(multiple);
        }
      }
      if (node.name === "offsetWidth" && is_svg(parent.name)) {
        bind_invalid_target(
          node,
          node.name,
          `non-<svg> elements. Use 'clientWidth' for <svg> instead`
        );
      }
      if (is_content_editable_binding(node.name)) {
        const contenteditable = (
          /** @type {AST.Attribute} */
          parent.attributes.find((a) => a.type === "Attribute" && a.name === "contenteditable")
        );
        if (!contenteditable) {
          attribute_contenteditable_missing(node);
        } else if (!is_text_attribute(contenteditable) && contenteditable.value !== true) {
          attribute_contenteditable_dynamic(contenteditable);
        }
      }
    } else {
      const match = fuzzymatch(node.name, Object.keys(binding_properties));
      if (match) {
        const property = binding_properties[match];
        if (!property.valid_elements || property.valid_elements.includes(parent.name)) {
          bind_invalid_name(node, node.name, `Did you mean '${match}'?`);
        }
      }
      bind_invalid_name(node, node.name);
    }
  }
  if (node.expression.type === "SequenceExpression") {
    if (node.name === "group") {
      bind_group_invalid_expression(node);
    }
    let i = (
      /** @type {number} */
      node.expression.start
    );
    let leading_comments_start = (
      /**@type {any}*/
      (_b = (_a2 = node.expression.leadingComments) == null ? void 0 : _a2.at(0)) == null ? void 0 : _b.start
    );
    let leading_comments_end = (
      /**@type {any}*/
      (_d = (_c = node.expression.leadingComments) == null ? void 0 : _c.at(-1)) == null ? void 0 : _d.end
    );
    while (context.state.analysis.source[--i] !== "{") {
      if (context.state.analysis.source[i] === "(" && // if the parenthesis is in a leading comment we don't need to throw the error
      !(leading_comments_start && leading_comments_end && i <= leading_comments_end && i >= leading_comments_start)) {
        bind_invalid_parens(node, node.name);
      }
    }
    if (node.expression.expressions.length !== 2) {
      bind_invalid_expression(node);
    }
    mark_subtree_dynamic(context.path);
    return;
  }
  validate_assignment(node, node.expression, context);
  const assignee = node.expression;
  const left = object2(assignee);
  if (left === null) {
    bind_invalid_expression(node);
  }
  const binding = context.state.scope.get(left.name);
  if (assignee.type === "Identifier") {
    if (node.name !== "this" && // bind:this also works for regular variables
    (!binding || binding.kind !== "state" && binding.kind !== "raw_state" && binding.kind !== "prop" && binding.kind !== "bindable_prop" && binding.kind !== "each" && binding.kind !== "store_sub" && !binding.updated)) {
      bind_invalid_value(node.expression);
    }
  }
  if (node.name === "group") {
    if (!binding) {
      throw new Error("Cannot find declaration for bind:group");
    }
    if (binding.kind === "snippet") {
      bind_group_invalid_snippet_parameter(node);
    }
    const each_blocks = [];
    const [keypath, expression_ids] = extract_all_identifiers_from_expression(node.expression);
    let ids = expression_ids;
    let i = context.path.length;
    while (i--) {
      const parent2 = context.path[i];
      if (parent2.type === "EachBlock") {
        const references = ids.filter((id2) => parent2.metadata.declarations.has(id2.name));
        if (references.length > 0) {
          parent2.metadata.contains_group_binding = true;
          each_blocks.push(parent2);
          ids = ids.filter((id2) => !references.includes(id2));
          ids.push(...extract_all_identifiers_from_expression(parent2.expression)[1]);
        }
      }
    }
    const bindings = expression_ids.map((id2) => context.state.scope.get(id2.name));
    let group_name;
    outer: for (const [[key2, b], group] of context.state.analysis.binding_groups) {
      if (b.length !== bindings.length || key2 !== keypath) continue;
      for (let i2 = 0; i2 < bindings.length; i2++) {
        if (bindings[i2] !== b[i2]) continue outer;
      }
      group_name = group;
    }
    if (!group_name) {
      group_name = context.state.scope.root.unique("binding_group");
      context.state.analysis.binding_groups.set([keypath, bindings], group_name);
    }
    node.metadata = {
      binding_group_name: group_name,
      parent_each_blocks: each_blocks
    };
  }
  if ((binding == null ? void 0 : binding.kind) === "each" && ((_e = binding.metadata) == null ? void 0 : _e.inside_rest)) {
    bind_invalid_each_rest(binding.node, binding.node.name);
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/CallExpression.js
function CallExpression(node, context) {
  var _a2, _b;
  const parent = (
    /** @type {AST.SvelteNode} */
    get_parent(context.path, -1)
  );
  const rune = get_rune(node, context.state.scope);
  if (rune && rune !== "$inspect") {
    for (const arg of node.arguments) {
      if (arg.type === "SpreadElement") {
        rune_invalid_spread(node, rune);
      }
    }
  }
  switch (rune) {
    case null:
      if (!is_safe_identifier(node.callee, context.state.scope)) {
        context.state.analysis.needs_context = true;
      }
      break;
    case "$bindable":
      if (node.arguments.length > 1) {
        rune_invalid_arguments_length(node, "$bindable", "zero or one arguments");
      }
      if (parent.type !== "AssignmentPattern" || ((_a2 = context.path.at(-3)) == null ? void 0 : _a2.type) !== "ObjectPattern" || ((_b = context.path.at(-4)) == null ? void 0 : _b.type) !== "VariableDeclarator" || get_rune(
        /** @type {VariableDeclarator} */
        context.path.at(-4).init,
        context.state.scope
      ) !== "$props") {
        bindable_invalid_location(node);
      }
      context.state.analysis.needs_context = true;
      break;
    case "$host":
      if (node.arguments.length > 0) {
        rune_invalid_arguments(node, "$host");
      } else if (context.state.ast_type === "module" || !context.state.analysis.custom_element) {
        host_invalid_placement(node);
      }
      break;
    case "$props":
      if (context.state.has_props_rune) {
        props_duplicate(node, rune);
      }
      context.state.has_props_rune = true;
      if (parent.type !== "VariableDeclarator" || context.state.ast_type !== "instance" || context.state.scope !== context.state.analysis.instance.scope) {
        props_invalid_placement(node);
      }
      if (node.arguments.length > 0) {
        rune_invalid_arguments(node, rune);
      }
      break;
    case "$props.id": {
      const grand_parent = get_parent(context.path, -2);
      if (context.state.analysis.props_id) {
        props_duplicate(node, rune);
      }
      if (parent.type !== "VariableDeclarator" || parent.id.type !== "Identifier" || context.state.ast_type !== "instance" || context.state.scope !== context.state.analysis.instance.scope || grand_parent.type !== "VariableDeclaration") {
        props_id_invalid_placement(node);
      }
      if (node.arguments.length > 0) {
        rune_invalid_arguments(node, rune);
      }
      context.state.analysis.props_id = parent.id;
      break;
    }
    case "$state":
    case "$state.raw":
    case "$derived":
    case "$derived.by": {
      const valid2 = is_variable_declaration(parent, context) || is_class_property_definition(parent) || is_class_property_assignment_at_constructor_root(parent, context);
      if (!valid2) {
        state_invalid_placement(node, rune);
      }
      if ((rune === "$derived" || rune === "$derived.by") && node.arguments.length !== 1) {
        rune_invalid_arguments_length(node, rune, "exactly one argument");
      } else if (node.arguments.length > 1) {
        rune_invalid_arguments_length(node, rune, "zero or one arguments");
      }
      break;
    }
    case "$effect":
    case "$effect.pre":
      if (parent.type !== "ExpressionStatement") {
        effect_invalid_placement(node);
      }
      if (node.arguments.length !== 1) {
        rune_invalid_arguments_length(node, rune, "exactly one argument");
      }
      context.state.analysis.needs_context = true;
      break;
    case "$effect.tracking":
      if (node.arguments.length !== 0) {
        rune_invalid_arguments(node, rune);
      }
      break;
    case "$effect.root":
      if (node.arguments.length !== 1) {
        rune_invalid_arguments_length(node, rune, "exactly one argument");
      }
      break;
    case "$inspect":
      if (node.arguments.length < 1) {
        rune_invalid_arguments_length(node, rune, "one or more arguments");
      }
      break;
    case "$inspect().with":
      if (node.arguments.length !== 1) {
        rune_invalid_arguments_length(node, rune, "exactly one argument");
      }
      break;
    case "$inspect.trace": {
      if (node.arguments.length > 1) {
        rune_invalid_arguments_length(node, rune, "zero or one arguments");
      }
      const grand_parent = context.path.at(-2);
      const fn = context.path.at(-3);
      if (parent.type !== "ExpressionStatement" || (grand_parent == null ? void 0 : grand_parent.type) !== "BlockStatement" || !((fn == null ? void 0 : fn.type) === "FunctionDeclaration" || (fn == null ? void 0 : fn.type) === "FunctionExpression" || (fn == null ? void 0 : fn.type) === "ArrowFunctionExpression") || grand_parent.body[0] !== parent) {
        inspect_trace_invalid_placement(node);
      }
      if (fn.generator) {
        inspect_trace_generator(node);
      }
      if (dev) {
        if (node.arguments[0]) {
          context.state.scope.tracing = thunk(
            /** @type {Expression} */
            node.arguments[0]
          );
        } else {
          const label = get_function_label(context.path.slice(0, -2)) ?? "trace";
          const loc = `(${locate_node(fn)})`;
          context.state.scope.tracing = thunk(literal2(label + " " + loc));
        }
        context.state.analysis.tracing = true;
      }
      break;
    }
    case "$state.snapshot":
      if (node.arguments.length !== 1) {
        rune_invalid_arguments_length(node, rune, "exactly one argument");
      }
      break;
  }
  if (rune === "$inspect" || rune === "$derived") {
    context.next({ ...context.state, function_depth: context.state.function_depth + 1 });
  } else {
    context.next();
  }
  if (context.state.expression) {
    if (!is_pure(node.callee, context) || context.state.expression.dependencies.size > 0) {
      context.state.expression.has_call = true;
      context.state.expression.has_state = true;
    }
  }
}
function get_function_label(nodes) {
  const fn = (
    /** @type {FunctionExpression | FunctionDeclaration | ArrowFunctionExpression} */
    nodes.at(-1)
  );
  if ((fn.type === "FunctionDeclaration" || fn.type === "FunctionExpression") && fn.id != null) {
    return fn.id.name;
  }
  const parent = nodes.at(-2);
  if (!parent) return;
  if (parent.type === "CallExpression") {
    return source.slice(parent.callee.start, parent.callee.end) + "(...)";
  }
  if (parent.type === "Property" && !parent.computed) {
    return (
      /** @type {Identifier} */
      parent.key.name
    );
  }
  if (parent.type === "VariableDeclarator" && parent.id.type === "Identifier") {
    return parent.id.name;
  }
}
function is_variable_declaration(parent, context) {
  return parent.type === "VariableDeclarator" && get_parent(context.path, -3).type !== "ConstTag";
}
function is_class_property_definition(parent) {
  return parent.type === "PropertyDefinition" && !parent.static && !parent.computed;
}
function is_class_property_assignment_at_constructor_root(node, context) {
  if (node.type === "AssignmentExpression" && node.operator === "=" && node.left.type === "MemberExpression" && node.left.object.type === "ThisExpression" && (node.left.property.type === "Identifier" && !node.left.computed || node.left.property.type === "PrivateIdentifier" || node.left.property.type === "Literal")) {
    const parent = get_parent(context.path, -5);
    return (parent == null ? void 0 : parent.type) === "MethodDefinition" && parent.kind === "constructor";
  }
  return false;
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ClassBody.js
function ClassBody(node, context) {
  if (!context.state.analysis.runes) {
    context.next();
    return;
  }
  const private_ids = [];
  for (const prop2 of node.body) {
    if ((prop2.type === "MethodDefinition" || prop2.type === "PropertyDefinition") && prop2.key.type === "PrivateIdentifier") {
      private_ids.push(prop2.key.name);
    }
  }
  const state_fields = /* @__PURE__ */ new Map();
  context.state.analysis.classes.set(node, state_fields);
  let constructor = null;
  function handle2(node2, key2, value) {
    const name = get_name(key2);
    if (name === null) return;
    const rune = get_rune(value, context.state.scope);
    if (rune && is_state_creation_rune(rune)) {
      if (state_fields.has(name)) {
        state_field_duplicate(node2, name);
      }
      state_fields.set(name, {
        node: node2,
        type: rune,
        // @ts-expect-error for public state this is filled out in a moment
        key: key2.type === "PrivateIdentifier" ? key2 : null,
        value: (
          /** @type {CallExpression} */
          value
        )
      });
    }
  }
  for (const child of node.body) {
    if (child.type === "PropertyDefinition" && !child.computed && !child.static) {
      handle2(child, child.key, child.value);
    }
    if (child.type === "MethodDefinition" && child.kind === "constructor") {
      constructor = child;
    }
  }
  if (constructor) {
    for (const statement of constructor.value.body.body) {
      if (statement.type !== "ExpressionStatement") continue;
      if (statement.expression.type !== "AssignmentExpression") continue;
      const { left, right } = statement.expression;
      if (left.type !== "MemberExpression") continue;
      if (left.object.type !== "ThisExpression") continue;
      if (left.computed && left.property.type !== "Literal") continue;
      handle2(statement.expression, left.property, right);
    }
  }
  for (const [name, field] of state_fields) {
    if (name[0] === "#") {
      continue;
    }
    let deconflicted = name.replace(regex_invalid_identifier_chars, "_");
    while (private_ids.includes(deconflicted)) {
      deconflicted = "_" + deconflicted;
    }
    private_ids.push(deconflicted);
    field.key = private_id(deconflicted);
  }
  context.next({ ...context.state, state_fields });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ClassDeclaration.js
function ClassDeclaration(node, context) {
  if (context.state.analysis.runes && node.id !== null) {
    validate_identifier_name(context.state.scope.get(node.id.name));
  }
  const allowed_depth = context.state.ast_type === "module" ? 0 : 1;
  if (context.state.scope.function_depth > allowed_depth) {
    perf_avoid_nested_class(node);
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ClassDirective.js
function ClassDirective(node, context) {
  mark_subtree_dynamic(context.path);
  context.next({ ...context.state, expression: node.metadata.expression });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/attribute.js
function validate_attribute_name(attribute) {
  if (attribute.name.includes(":") && !attribute.name.startsWith("xmlns:") && !attribute.name.startsWith("xlink:") && !attribute.name.startsWith("xml:")) {
    attribute_illegal_colon(attribute);
  }
}
function validate_attribute(attribute, parent) {
  var _a2;
  if (Array.isArray(attribute.value) && attribute.value.length === 1 && attribute.value[0].type === "ExpressionTag" && (parent.type === "Component" || parent.type === "SvelteComponent" || parent.type === "SvelteSelf" || parent.type === "RegularElement" && is_custom_element_node(parent))) {
    attribute_quoted(attribute);
  }
  if (attribute.value === true || !Array.isArray(attribute.value) || attribute.value.length === 1) {
    return;
  }
  const is_quoted = ((_a2 = attribute.value.at(-1)) == null ? void 0 : _a2.end) !== attribute.end;
  if (!is_quoted) {
    attribute_unquoted_sequence(attribute);
  }
}
function validate_slot_attribute(context, attribute, is_component = false) {
  const parent = context.path.at(-2);
  let owner = void 0;
  if ((parent == null ? void 0 : parent.type) === "SnippetBlock") {
    if (!is_text_attribute(attribute)) {
      slot_attribute_invalid(attribute);
    }
    return;
  }
  let i = context.path.length;
  while (i--) {
    const ancestor = context.path[i];
    if (!owner && (ancestor.type === "Component" || ancestor.type === "SvelteComponent" || ancestor.type === "SvelteSelf" || ancestor.type === "SvelteElement" || ancestor.type === "RegularElement" && is_custom_element_node(ancestor))) {
      owner = ancestor;
    }
  }
  if (owner) {
    if (owner.type === "Component" || owner.type === "SvelteComponent" || owner.type === "SvelteSelf") {
      if (owner !== parent) {
        if (!is_component) {
          slot_attribute_invalid_placement(attribute);
        }
      } else {
        if (!is_text_attribute(attribute)) {
          slot_attribute_invalid(attribute);
        }
        const name = attribute.value[0].data;
        if (context.state.component_slots.has(name)) {
          slot_attribute_duplicate(attribute, name, owner.name);
        }
        context.state.component_slots.add(name);
        if (name === "default") {
          for (const node of owner.fragment.nodes) {
            if (node.type === "Text" && regex_only_whitespaces.test(node.data)) {
              continue;
            }
            if (node.type === "RegularElement" || node.type === "SvelteFragment") {
              if (node.attributes.some((a) => a.type === "Attribute" && a.name === "slot")) {
                continue;
              }
            }
            slot_default_duplicate(node);
          }
        }
      }
    }
  } else if (!is_component) {
    slot_attribute_invalid_placement(attribute);
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/snippets.js
function is_resolved_snippet(binding) {
  var _a2;
  return !binding || binding.declaration_kind === "import" || binding.kind === "prop" || binding.kind === "rest_prop" || binding.kind === "bindable_prop" || ((_a2 = binding == null ? void 0 : binding.initial) == null ? void 0 : _a2.type) === "SnippetBlock";
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/component.js
function visit_component(node, context) {
  var _a2;
  node.metadata.path = [...context.path];
  node.metadata.snippets = /* @__PURE__ */ new Set();
  let resolved = true;
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute" || attribute.type === "BindDirective") {
      resolved = false;
      continue;
    }
    if (attribute.type !== "Attribute" || !is_expression_attribute(attribute)) {
      continue;
    }
    const expression = get_attribute_expression(attribute);
    if (expression.type === "Identifier") {
      const binding = context.state.scope.get(expression.name);
      resolved && (resolved = is_resolved_snippet(binding));
      if (((_a2 = binding == null ? void 0 : binding.initial) == null ? void 0 : _a2.type) === "SnippetBlock") {
        node.metadata.snippets.add(binding.initial);
      }
    } else if (expression.type !== "Literal") {
      resolved = false;
    }
  }
  if (resolved) {
    for (const child of node.fragment.nodes) {
      if (child.type === "SnippetBlock") {
        node.metadata.snippets.add(child);
      }
    }
  }
  context.state.analysis.snippet_renderers.set(node, resolved);
  mark_subtree_dynamic(context.path);
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute" && attribute.type !== "SpreadAttribute" && attribute.type !== "LetDirective" && attribute.type !== "OnDirective" && attribute.type !== "BindDirective" && attribute.type !== "AttachTag") {
      component_invalid_directive(attribute);
    }
    if (attribute.type === "OnDirective" && (attribute.modifiers.length > 1 || attribute.modifiers.some((m) => m !== "once"))) {
      event_handler_invalid_component_modifier(attribute);
    }
    if (attribute.type === "Attribute") {
      if (context.state.analysis.runes) {
        validate_attribute(attribute, node);
        if (is_expression_attribute(attribute)) {
          disallow_unparenthesized_sequences(
            get_attribute_expression(attribute),
            context.state.analysis.source
          );
        }
      }
      validate_attribute_name(attribute);
      if (attribute.name === "slot") {
        validate_slot_attribute(context, attribute, true);
      }
    }
    if (attribute.type === "BindDirective" && attribute.name !== "this") {
      context.state.analysis.uses_component_bindings = true;
    }
    if (attribute.type === "AttachTag") {
      disallow_unparenthesized_sequences(attribute.expression, context.state.analysis.source);
    }
  }
  const default_state = determine_slot(node) ? context.state : { ...context.state, scope: node.metadata.scopes.default };
  for (const attribute of node.attributes) {
    context.visit(attribute, attribute.type === "LetDirective" ? default_state : context.state);
  }
  let comments = [];
  const nodes = { default: [] };
  for (const child of node.fragment.nodes) {
    if (child.type === "Comment") {
      comments.push(child);
      continue;
    }
    const slot_name = determine_slot(child) ?? "default";
    (nodes[slot_name] ?? (nodes[slot_name] = [])).push(...comments, child);
    if (slot_name !== "default") comments = [];
  }
  const component_slots = /* @__PURE__ */ new Set();
  for (const slot_name in nodes) {
    const state = {
      ...context.state,
      scope: node.metadata.scopes[slot_name],
      parent_element: null,
      component_slots
    };
    context.visit({ ...node.fragment, nodes: nodes[slot_name] }, state);
  }
}
function disallow_unparenthesized_sequences(expression, source2) {
  if (expression.type === "SequenceExpression") {
    let i = (
      /** @type {number} */
      expression.start
    );
    while (--i > 0) {
      const char = source2[i];
      if (char === "(") break;
      if (char === "{") attribute_invalid_sequence_expression(expression);
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/Component.js
function Component(node, context) {
  const binding = context.state.scope.get(
    node.name.includes(".") ? node.name.slice(0, node.name.indexOf(".")) : node.name
  );
  node.metadata.dynamic = context.state.analysis.runes && // Svelte 4 required you to use svelte:component to switch components
  binding !== null && (binding.kind !== "normal" || node.name.includes("."));
  visit_component(node, context);
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ConstTag.js
function ConstTag(node, context) {
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, "@");
  }
  const parent = context.path.at(-1);
  const grand_parent = context.path.at(-2);
  if ((parent == null ? void 0 : parent.type) !== "Fragment" || (grand_parent == null ? void 0 : grand_parent.type) !== "IfBlock" && (grand_parent == null ? void 0 : grand_parent.type) !== "SvelteFragment" && (grand_parent == null ? void 0 : grand_parent.type) !== "Component" && (grand_parent == null ? void 0 : grand_parent.type) !== "SvelteComponent" && (grand_parent == null ? void 0 : grand_parent.type) !== "EachBlock" && (grand_parent == null ? void 0 : grand_parent.type) !== "AwaitBlock" && (grand_parent == null ? void 0 : grand_parent.type) !== "SnippetBlock" && (grand_parent == null ? void 0 : grand_parent.type) !== "SvelteBoundary" && (grand_parent == null ? void 0 : grand_parent.type) !== "KeyBlock" && ((grand_parent == null ? void 0 : grand_parent.type) !== "RegularElement" && (grand_parent == null ? void 0 : grand_parent.type) !== "SvelteElement" || !grand_parent.attributes.some((a) => a.type === "Attribute" && a.name === "slot"))) {
    const_tag_invalid_placement(node);
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/DebugTag.js
function DebugTag(node, context) {
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, "@");
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/EachBlock.js
function EachBlock(node, context) {
  validate_opening_tag(node, context.state, "#");
  validate_block_not_empty(node.body, context);
  validate_block_not_empty(node.fallback, context);
  const id2 = node.context;
  if ((id2 == null ? void 0 : id2.type) === "Identifier" && (id2.name === "$state" || id2.name === "$derived")) {
    state_invalid_placement(node, id2.name);
  }
  if (node.key) {
    node.metadata.keyed = node.key.type !== "Identifier" || !node.index || node.key.name !== node.index;
  }
  context.visit(node.expression, {
    ...context.state,
    expression: node.metadata.expression,
    scope: (
      /** @type {Scope} */
      context.state.scope.parent
    )
  });
  context.visit(node.body);
  if (node.key) context.visit(node.key);
  if (node.fallback) context.visit(node.fallback);
  if (!context.state.analysis.runes) {
    let mutated = !!node.context && extract_identifiers(node.context).some((id3) => {
      const binding = context.state.scope.get(id3.name);
      return !!(binding == null ? void 0 : binding.mutated);
    });
    for (const binding of node.metadata.expression.dependencies) {
      collect_transitive_dependencies(binding, node.metadata.transitive_deps);
    }
    if (mutated) {
      for (const binding of node.metadata.transitive_deps) {
        if (binding.kind === "normal" && (binding.declaration_kind === "const" || binding.declaration_kind === "let" || binding.declaration_kind === "var")) {
          binding.kind = "state";
        }
      }
    }
  }
  mark_subtree_dynamic(context.path);
}
function collect_transitive_dependencies(binding, bindings) {
  bindings.add(binding);
  if (binding.kind === "legacy_reactive") {
    for (const dep of binding.legacy_dependencies) {
      collect_transitive_dependencies(dep, bindings);
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ExportDefaultDeclaration.js
function ExportDefaultDeclaration(node, context) {
  if (!context.state.ast_type) {
    if (node.declaration.type === "Identifier") {
      validate_export(node, context.state.scope, node.declaration.name);
    }
  } else {
    module_illegal_default_export(node);
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ExportNamedDeclaration.js
function ExportNamedDeclaration(node, context) {
  var _a2;
  context.next();
  if (((_a2 = node.declaration) == null ? void 0 : _a2.type) === "VariableDeclaration") {
    if (context.state.analysis.runes && context.state.ast_type === "instance" && node.declaration.kind === "let") {
      legacy_export_invalid(node);
    }
    for (const declarator2 of node.declaration.declarations) {
      for (const id2 of extract_identifiers(declarator2.id)) {
        const binding = context.state.scope.get(id2.name);
        if (!binding) continue;
        if (binding.kind === "derived") {
          derived_invalid_export(node);
        }
        if ((binding.kind === "state" || binding.kind === "raw_state") && binding.reassigned) {
          state_invalid_export(node);
        }
      }
    }
  }
  if (context.state.analysis.runes) {
    if (node.declaration && context.state.ast_type === "instance") {
      if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
        context.state.analysis.exports.push({
          name: (
            /** @type {Identifier} */
            node.declaration.id.name
          ),
          alias: null
        });
      } else if (node.declaration.kind === "const") {
        for (const declarator2 of node.declaration.declarations) {
          for (const node2 of extract_identifiers(declarator2.id)) {
            context.state.analysis.exports.push({ name: node2.name, alias: null });
          }
        }
      }
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ExportSpecifier.js
function ExportSpecifier(node, context) {
  const local_name = node.local.type === "Identifier" ? node.local.name : (
    /** @type {string} */
    node.local.value
  );
  const exported_name = node.exported.type === "Identifier" ? node.exported.name : (
    /** @type {string} */
    node.exported.value
  );
  if (context.state.ast_type === "instance") {
    if (context.state.analysis.runes) {
      context.state.analysis.exports.push({
        name: local_name,
        alias: exported_name
      });
      const binding = context.state.scope.get(local_name);
      if (binding) binding.reassigned = true;
    }
  } else {
    validate_export(node, context.state.scope, local_name);
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ExpressionStatement.js
function ExpressionStatement(node, context) {
  if (node.expression.type === "NewExpression" && node.expression.callee.type === "Identifier" && node.expression.arguments.length === 1 && node.expression.arguments[0].type === "ObjectExpression" && node.expression.arguments[0].properties.some(
    (p) => p.type === "Property" && p.key.type === "Identifier" && p.key.name === "target"
  )) {
    const binding = context.state.scope.get(node.expression.callee.name);
    if ((binding == null ? void 0 : binding.kind) === "normal" && binding.declaration_kind === "import") {
      const declaration2 = (
        /** @type {ImportDeclaration} */
        binding.initial
      );
      if (
        /** @type {string} */
        declaration2.source.value.endsWith(".svelte") && declaration2.specifiers.find(
          (s) => s.local.name === binding.node.name && s.type === "ImportDefaultSpecifier"
        )
      ) {
        legacy_component_creation(node.expression);
      }
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ExpressionTag.js
function ExpressionTag(node, context) {
  var _a2;
  const in_template = ((_a2 = context.path.at(-1)) == null ? void 0 : _a2.type) === "Fragment";
  if (in_template && context.state.parent_element) {
    const message = is_tag_valid_with_parent("#text", context.state.parent_element);
    if (message) {
      node_invalid_placement(node, message);
    }
  }
  mark_subtree_dynamic(context.path);
  context.next({ ...context.state, expression: node.metadata.expression });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/FunctionDeclaration.js
function FunctionDeclaration(node, context) {
  if (context.state.analysis.runes && node.id !== null) {
    validate_identifier_name(context.state.scope.get(node.id.name));
  }
  visit_function(node, context);
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/FunctionExpression.js
function FunctionExpression(node, context) {
  visit_function(node, context);
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/HtmlTag.js
function HtmlTag(node, context) {
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, "@");
  }
  mark_subtree_dynamic(context.path);
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/utils.js
function memoize_expression(state, value) {
  const id2 = id(state.scope.generate("expression"));
  state.init.push(const_builder(id2, create_derived(state, thunk(value))));
  return call("$.get", id2);
}
function get_expression_id(expressions, value) {
  return id(`$${expressions.push(value) - 1}`);
}
function build_template_chunk(values, visit, state, memoize = (value, metadata) => metadata.has_call ? get_expression_id(state.expressions, value) : value) {
  const expressions = [];
  let quasi2 = quasi("");
  const quasis = [quasi2];
  let has_state = false;
  for (let i = 0; i < values.length; i++) {
    const node = values[i];
    if (node.type === "Text") {
      quasi2.value.cooked += node.data;
    } else if (node.expression.type === "Literal") {
      if (node.expression.value != null) {
        quasi2.value.cooked += node.expression.value + "";
      }
    } else if (node.expression.type !== "Identifier" || node.expression.name !== "undefined" || state.scope.get("undefined")) {
      let value2 = memoize(
        /** @type {Expression} */
        visit(node.expression, state),
        node.metadata.expression
      );
      const evaluated = state.scope.evaluate(value2);
      has_state || (has_state = node.metadata.expression.has_state && !evaluated.is_known);
      if (values.length === 1) {
        if (evaluated.is_known) {
          value2 = literal2((evaluated.value ?? "") + "");
        }
        return { value: value2, has_state };
      }
      if (value2.type === "LogicalExpression" && value2.right.type === "Literal" && (value2.operator === "??" || value2.operator === "||")) {
        if (value2.right.value === null) {
          value2 = { ...value2, right: literal2("") };
        }
      }
      if (evaluated.is_known) {
        quasi2.value.cooked += (evaluated.value ?? "") + "";
      } else {
        if (!evaluated.is_defined) {
          value2 = logical("??", value2, literal2(""));
        }
        expressions.push(value2);
        quasi2 = quasi("", i + 1 === values.length);
        quasis.push(quasi2);
      }
    }
  }
  for (const quasi3 of quasis) {
    quasi3.value.raw = sanitize_template_string(
      /** @type {string} */
      quasi3.value.cooked
    );
  }
  const value = expressions.length > 0 ? template(quasis, expressions) : literal2(
    /** @type {string} */
    quasi2.value.cooked
  );
  return { value, has_state };
}
function build_render_statement(state) {
  return stmt(
    call(
      "$.template_effect",
      arrow(
        state.expressions.map((_, i) => id(`$${i}`)),
        state.update.length === 1 && state.update[0].type === "ExpressionStatement" ? state.update[0].expression : block(state.update)
      ),
      state.expressions.length > 0 && array(state.expressions.map((expression) => thunk(expression))),
      state.expressions.length > 0 && !state.analysis.runes && id("$.derived_safe_equal")
    )
  );
}
function parse_directive_name(name) {
  const parts = name.split(".");
  let part = (
    /** @type {string} */
    parts.shift()
  );
  let expression = id(part);
  while (part = /** @type {string} */
  parts.shift()) {
    const computed = !regex_is_valid_identifier.test(part);
    expression = member(expression, computed ? literal2(part) : id(part), computed);
  }
  return expression;
}
function build_update_assignment(state, id2, init3, value, update2) {
  state.init.push(var_builder(id2, init3));
  state.update.push(
    if_builder(binary("!==", id(id2), assignment("=", id(id2), value)), block([update2]))
  );
}
function build_bind_this(expression, value, { state, visit }) {
  if (expression.type === "SequenceExpression") {
    const [get3, set3] = (
      /** @type {SequenceExpression} */
      visit(expression).expressions
    );
    return call("$.bind_this", value, set3, get3);
  }
  const ids = [];
  const values = [];
  const seen2 = [];
  const transform = { ...state.transform };
  walk(expression, null, {
    Identifier(node2, { path: path11 }) {
      if (seen2.includes(node2.name)) return;
      seen2.push(node2.name);
      const parent = (
        /** @type {Expression} */
        path11.at(-1)
      );
      if (!is_reference(node2, parent)) return;
      const binding = state.scope.get(node2.name);
      if (!binding) return;
      for (const [owner, scope] of state.scopes) {
        if (owner.type === "EachBlock" && scope === binding.scope) {
          ids.push(node2);
          values.push(
            /** @type {Expression} */
            visit(node2)
          );
          if (transform[node2.name]) {
            transform[node2.name] = {
              ...transform[node2.name],
              read: (node3) => node3
            };
          }
          break;
        }
      }
    }
  });
  const child_state = { ...state, transform };
  const get2 = (
    /** @type {Expression} */
    visit(expression, child_state)
  );
  const set2 = (
    /** @type {Expression} */
    visit(assignment("=", expression, id("$$value")), child_state)
  );
  let node = get2;
  while (node.type === "MemberExpression") {
    node.optional = true;
    node = node.object;
  }
  return call(
    "$.bind_this",
    value,
    arrow([id("$$value"), ...ids], set2),
    arrow([...ids], get2),
    values.length > 0 && thunk(array(values))
  );
}
function validate_binding(state, binding, expression) {
  if (binding.expression.type === "SequenceExpression") {
    return;
  }
  const left = object2(binding.expression);
  const left_binding = left && state.scope.get(left.name);
  if ((left_binding == null ? void 0 : left_binding.kind) === "store_sub") return;
  const loc = locator(binding.start);
  const obj = (
    /** @type {Expression} */
    expression.object
  );
  state.init.push(
    stmt(
      call(
        "$.validate_binding",
        literal2(state.analysis.source.slice(binding.start, binding.end)),
        thunk(
          state.store_to_invalidate ? sequence([call("$.mark_store_binding"), obj]) : obj
        ),
        thunk(
          /** @type {Expression} */
          expression.computed ? expression.property : literal2(
            /** @type {Identifier} */
            expression.property.name
          )
        ),
        loc && literal2(loc.line),
        loc && literal2(loc.column)
      )
    )
  );
}
function validate_mutation(node, context, expression) {
  let left = (
    /** @type {Expression | Super} */
    node.type === "AssignmentExpression" ? node.left : node.argument
  );
  if (!dev || left.type !== "MemberExpression" || is_ignored(node, "ownership_invalid_mutation")) {
    return expression;
  }
  const name = object2(left);
  if (!name) return expression;
  const binding = context.state.scope.get(name.name);
  if ((binding == null ? void 0 : binding.kind) !== "prop" && (binding == null ? void 0 : binding.kind) !== "bindable_prop") return expression;
  const state = (
    /** @type {ComponentClientTransformState} */
    context.state
  );
  state.analysis.needs_mutation_validation = true;
  const path11 = [];
  while (left.type === "MemberExpression") {
    if (left.property.type === "Literal") {
      path11.unshift(left.property);
    } else if (left.property.type === "Identifier") {
      const transform = Object.hasOwn(context.state.transform, left.property.name) ? context.state.transform[left.property.name] : null;
      if (left.computed) {
        path11.unshift((transform == null ? void 0 : transform.read) ? transform.read(left.property) : left.property);
      } else {
        path11.unshift(literal2(left.property.name));
      }
    } else {
      return expression;
    }
    left = left.object;
  }
  path11.unshift(literal2(name.name));
  const loc = locator(
    /** @type {number} */
    left.start
  );
  return call(
    "$$ownership_validator.mutation",
    literal2(binding.prop_alias),
    array(path11),
    expression,
    loc && literal2(loc.line),
    loc && literal2(loc.column)
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/client/utils.js
function is_state_source(binding, analysis) {
  return (binding.kind === "state" || binding.kind === "raw_state") && (!analysis.immutable || binding.reassigned || analysis.accessors);
}
function build_getter(node, state) {
  if (Object.hasOwn(state.transform, node.name)) {
    const binding = state.scope.get(node.name);
    if (node !== (binding == null ? void 0 : binding.node)) {
      return state.transform[node.name].read(node);
    }
  }
  return node;
}
function get_hoisted_params(node, context) {
  var _a2;
  const scope = context.state.scope;
  const params = [];
  function push_unique(id2) {
    if (!params.find((param) => param.name === id2.name)) {
      params.push(id2);
    }
  }
  for (const [reference] of scope.references) {
    let binding = scope.get(reference);
    if (binding !== null && !scope.declarations.has(reference) && binding.initial !== node) {
      if (binding.kind === "store_sub") {
        push_unique(id(binding.node.name));
        binding = /** @type {Binding} */
        scope.get(binding.node.name.slice(1));
      }
      let expression = (_a2 = context.state.transform[reference]) == null ? void 0 : _a2.read(id(binding.node.name));
      if (
        // If it's a destructured derived binding, then we can extract the derived signal reference and use that.
        // TODO this code is bad, we need to kill it
        expression != null && typeof expression !== "function" && expression.type === "MemberExpression" && expression.object.type === "CallExpression" && expression.object.callee.type === "Identifier" && expression.object.callee.name === "$.get" && expression.object.arguments[0].type === "Identifier"
      ) {
        push_unique(id(expression.object.arguments[0].name));
      } else if (
        // If we are referencing a simple $$props value, then we need to reference the object property instead
        (binding.kind === "prop" || binding.kind === "bindable_prop") && !is_prop_source(binding, context.state)
      ) {
        push_unique(id("$$props"));
      } else if (
        // imports don't need to be hoisted
        binding.declaration_kind !== "import"
      ) {
        push_unique(id(binding.node.name));
        if (binding.kind === "rest_prop" && context.state.analysis.runes) {
          push_unique(id("$$props"));
        }
      }
    }
  }
  if (dev) {
    let visit = function(node2, { next: next2, stop }) {
      if (validate_mutation(
        node2,
        /** @type {any} */
        context,
        node2
      ) !== node2) {
        params.push(id("$$ownership_validator"));
        stop();
      } else {
        next2();
      }
    };
    walk(
      /** @type {Node} */
      node,
      null,
      {
        AssignmentExpression: visit,
        UpdateExpression: visit
      }
    );
  }
  return params;
}
function build_hoisted_params(node, context) {
  const hoisted_params = get_hoisted_params(node, context);
  node.metadata.hoisted_params = hoisted_params;
  const params = [];
  if (node.params.length === 0) {
    if (hoisted_params.length > 0) {
      params.push(id(context.state.scope.generate("_")));
    }
  } else {
    for (const param of node.params) {
      params.push(
        /** @type {Pattern} */
        context.visit(param)
      );
    }
  }
  params.push(...hoisted_params);
  return params;
}
function get_prop_source(binding, state, name, initial) {
  const args = [id("$$props"), literal2(name)];
  let flags = 0;
  if (binding.kind === "bindable_prop") {
    flags |= PROPS_IS_BINDABLE;
  }
  if (state.analysis.immutable) {
    flags |= PROPS_IS_IMMUTABLE;
  }
  if (state.analysis.runes) {
    flags |= PROPS_IS_RUNES;
  }
  if (state.analysis.accessors || (state.analysis.immutable ? binding.reassigned || state.analysis.runes && binding.mutated : binding.updated)) {
    flags |= PROPS_IS_UPDATED;
  }
  let arg;
  if (initial) {
    if (is_simple_expression(initial)) {
      arg = initial;
    } else {
      if (initial.type === "CallExpression" && initial.callee.type === "Identifier" && initial.arguments.length === 0) {
        arg = initial.callee;
      } else {
        arg = thunk(initial);
      }
      flags |= PROPS_IS_LAZY_INITIAL;
    }
  }
  if (flags || arg) {
    args.push(literal2(flags));
    if (arg) args.push(arg);
  }
  return call("$.prop", ...args);
}
function is_prop_source(binding, state) {
  return (binding.kind === "prop" || binding.kind === "bindable_prop") && (!state.analysis.runes || state.analysis.accessors || binding.reassigned || binding.initial || // Until legacy mode is gone, we also need to use the prop source when only mutated is true,
  // because the parent could be a legacy component which needs coarse-grained reactivity
  binding.updated);
}
function should_proxy(node, scope) {
  if (!node || node.type === "Literal" || node.type === "TemplateLiteral" || node.type === "ArrowFunctionExpression" || node.type === "FunctionExpression" || node.type === "UnaryExpression" || node.type === "BinaryExpression" || node.type === "Identifier" && node.name === "undefined") {
    return false;
  }
  if (node.type === "Identifier" && scope !== null) {
    const binding = scope.get(node.name);
    if (binding !== null && !binding.reassigned && binding.initial !== null && binding.initial.type !== "FunctionDeclaration" && binding.initial.type !== "ClassDeclaration" && binding.initial.type !== "ImportDeclaration" && binding.initial.type !== "EachBlock" && binding.initial.type !== "SnippetBlock") {
      return should_proxy(binding.initial, null);
    }
  }
  return true;
}
function create_derived(state, arg) {
  return call(state.analysis.runes ? "$.derived" : "$.derived_safe_equal", arg);
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/Identifier.js
function Identifier(node, context) {
  var _a2, _b, _c;
  let i = context.path.length;
  let parent = (
    /** @type {Expression} */
    context.path[--i]
  );
  if (!is_reference(node, parent)) {
    return;
  }
  mark_subtree_dynamic(context.path);
  if (node.name === "arguments" && !context.path.some((n2) => n2.type === "FunctionDeclaration" || n2.type === "FunctionExpression")) {
    invalid_arguments_usage(node);
  }
  if (node.name === "$$slots") {
    context.state.analysis.uses_slots = true;
  }
  if (context.state.analysis.runes) {
    if (is_rune(node.name) && context.state.scope.get(node.name) === null && ((_a2 = context.state.scope.get(node.name.slice(1))) == null ? void 0 : _a2.kind) !== "store_sub") {
      let current2 = node;
      let name = node.name;
      while (parent.type === "MemberExpression") {
        if (parent.computed) rune_invalid_computed_property(parent);
        name += `.${/** @type {Identifier} */
        parent.property.name}`;
        current2 = parent;
        parent = /** @type {Expression} */
        context.path[--i];
        if (!is_rune(name)) {
          if (name === "$effect.active") {
            rune_renamed(parent, "$effect.active", "$effect.tracking");
          }
          if (name === "$state.frozen") {
            rune_renamed(parent, "$state.frozen", "$state.raw");
          }
          if (name === "$state.is") {
            rune_removed(parent, "$state.is");
          }
          rune_invalid_name(parent, name);
        }
      }
      if (parent.type !== "CallExpression") {
        rune_missing_parentheses(current2);
      }
    }
  }
  let binding = context.state.scope.get(node.name);
  if (!context.state.analysis.runes) {
    if (node.name === "$$props") {
      context.state.analysis.uses_props = true;
    }
    if (node.name === "$$restProps") {
      context.state.analysis.uses_rest_props = true;
    }
  }
  if (binding) {
    if (context.state.expression) {
      context.state.expression.dependencies.add(binding);
      (_b = context.state.expression).has_state || (_b.has_state = binding.kind !== "static" && !binding.is_function() && !context.state.scope.evaluate(node).is_known);
    }
    if (context.state.analysis.runes && node !== binding.node && context.state.function_depth === binding.scope.function_depth && // If we have $state that can be proxied or frozen and isn't re-assigned, then that means
    // it's likely not using a primitive value and thus this warning isn't that helpful.
    (binding.kind === "state" && (binding.reassigned || ((_c = binding.initial) == null ? void 0 : _c.type) === "CallExpression" && binding.initial.arguments.length === 1 && binding.initial.arguments[0].type !== "SpreadElement" && !should_proxy(binding.initial.arguments[0], context.state.scope)) || binding.kind === "raw_state" || binding.kind === "derived") && // We're only concerned with reads here
    (parent.type !== "AssignmentExpression" || parent.left !== node) && parent.type !== "UpdateExpression") {
      let type = "closure";
      let i2 = context.path.length;
      while (i2--) {
        const parent2 = context.path[i2];
        if (parent2.type === "ArrowFunctionExpression" || parent2.type === "FunctionDeclaration" || parent2.type === "FunctionExpression") {
          break;
        }
        if (parent2.type === "CallExpression" && parent2.arguments.includes(
          /** @type {any} */
          context.path[i2 + 1]
        )) {
          const rune = get_rune(parent2, context.state.scope);
          if (rune === "$state" || rune === "$state.raw") {
            type = "derived";
            break;
          }
        }
      }
      state_referenced_locally(node, node.name, type);
    }
    if (context.state.reactive_statement && binding.scope === context.state.analysis.module.scope && binding.reassigned) {
      reactive_declaration_module_script_dependency(node);
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/IfBlock.js
function IfBlock(node, context) {
  validate_block_not_empty(node.consequent, context);
  validate_block_not_empty(node.alternate, context);
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, node.elseif ? ":" : "#");
  }
  mark_subtree_dynamic(context.path);
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ImportDeclaration.js
function ImportDeclaration(node, context) {
  if (context.state.analysis.runes) {
    const source2 = (
      /** @type {string} */
      node.source.value
    );
    if (source2.startsWith("svelte/internal")) {
      import_svelte_internal_forbidden(node);
    }
    if (source2 === "svelte") {
      for (const specifier of node.specifiers) {
        if (specifier.type === "ImportSpecifier") {
          if (specifier.imported.type === "Identifier" && (specifier.imported.name === "beforeUpdate" || specifier.imported.name === "afterUpdate")) {
            runes_mode_invalid_import(specifier, specifier.imported.name);
          }
        }
      }
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/KeyBlock.js
function KeyBlock(node, context) {
  validate_block_not_empty(node.fragment, context);
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, "#");
  }
  mark_subtree_dynamic(context.path);
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/LabeledStatement.js
function LabeledStatement(node, context) {
  if (node.label.name === "$") {
    const parent = (
      /** @type {AST.SvelteNode} */
      context.path.at(-1)
    );
    const is_reactive_statement = context.state.ast_type === "instance" && parent.type === "Program";
    if (is_reactive_statement) {
      if (context.state.analysis.runes) {
        legacy_reactive_statement_invalid(node);
      }
      const reactive_statement = {
        assignments: /* @__PURE__ */ new Set(),
        dependencies: []
      };
      context.next({
        ...context.state,
        reactive_statement,
        function_depth: context.state.scope.function_depth + 1
      });
      for (const [name, nodes] of context.state.scope.references) {
        const binding = context.state.scope.get(name);
        if (binding === null) continue;
        for (const { node: node2, path: path11 } of nodes) {
          let left = node2;
          let i = path11.length - 1;
          let parent2 = (
            /** @type {Expression} */
            path11.at(i)
          );
          while (parent2.type === "MemberExpression") {
            left = parent2;
            parent2 = /** @type {Expression} */
            path11.at(--i);
          }
          if (parent2.type === "AssignmentExpression" && parent2.operator === "=" && parent2.left === left) {
            continue;
          }
          reactive_statement.dependencies.push(binding);
          break;
        }
      }
      context.state.analysis.reactive_statements.set(node, reactive_statement);
      if (node.body.type === "ExpressionStatement" && node.body.expression.type === "AssignmentExpression") {
        let ids = extract_identifiers(node.body.expression.left);
        if (node.body.expression.left.type === "MemberExpression") {
          const id2 = object2(node.body.expression.left);
          if (id2 !== null) {
            ids = [id2];
          }
        }
        for (const id2 of ids) {
          const binding = context.state.scope.get(id2.name);
          if ((binding == null ? void 0 : binding.kind) === "legacy_reactive") {
            binding.legacy_dependencies = Array.from(reactive_statement.dependencies);
          }
        }
      }
    } else if (!context.state.analysis.runes) {
      reactive_declaration_invalid_placement(node);
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/LetDirective.js
function LetDirective(node, context) {
  const parent = context.path.at(-1);
  if (parent === void 0 || parent.type !== "Component" && parent.type !== "RegularElement" && parent.type !== "SlotElement" && parent.type !== "SvelteElement" && parent.type !== "SvelteComponent" && parent.type !== "SvelteSelf" && parent.type !== "SvelteFragment") {
    let_directive_invalid_placement(node);
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/Literal.js
function Literal(node) {
  if (typeof node.value === "string") {
    if (regex_bidirectional_control_characters.test(node.value)) {
      bidirectional_control_characters(node);
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/MemberExpression.js
function MemberExpression(node, context) {
  if (node.object.type === "Identifier" && node.property.type === "Identifier") {
    const binding = context.state.scope.get(node.object.name);
    if ((binding == null ? void 0 : binding.kind) === "rest_prop" && node.property.name.startsWith("$$")) {
      props_illegal_name(node.property);
    }
  }
  if (context.state.expression && !is_pure(node, context)) {
    context.state.expression.has_state = true;
  }
  if (!is_safe_identifier(node, context.state.scope)) {
    context.state.analysis.needs_context = true;
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/NewExpression.js
function NewExpression(node, context) {
  if (node.callee.type === "ClassExpression" && context.state.scope.function_depth > 0) {
    perf_avoid_inline_class(node);
  }
  context.state.analysis.needs_context = true;
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/OnDirective.js
function OnDirective(node, context) {
  var _a2, _b;
  if (context.state.analysis.runes) {
    const parent_type = (_a2 = context.path.at(-1)) == null ? void 0 : _a2.type;
    if (parent_type === "RegularElement" || parent_type === "SvelteElement") {
      event_directive_deprecated(node, node.name);
    }
  }
  const parent = context.path.at(-1);
  if ((parent == null ? void 0 : parent.type) === "SvelteElement" || (parent == null ? void 0 : parent.type) === "RegularElement") {
    (_b = context.state.analysis).event_directive_node ?? (_b.event_directive_node = node);
  }
  mark_subtree_dynamic(context.path);
  context.next({ ...context.state, expression: node.metadata.expression });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/PropertyDefinition.js
function PropertyDefinition(node, context) {
  const name = get_name(node.key);
  const field = name && context.state.state_fields.get(name);
  if (field && node !== field.node && node.value) {
    if (
      /** @type {number} */
      node.start < /** @type {number} */
      field.node.start
    ) {
      state_field_invalid_assignment(node);
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/a11y.js
var import_aria_query = __toESM(require_lib(), 1);
var import_axobject_query = __toESM(require_lib2(), 1);
var aria_roles = import_aria_query.roles.keys();
var abstract_roles = aria_roles.filter((role) => {
  var _a2;
  return (_a2 = import_aria_query.roles.get(role)) == null ? void 0 : _a2.abstract;
});
var non_abstract_roles = aria_roles.filter((name) => !abstract_roles.includes(name));
var non_interactive_roles = non_abstract_roles.filter((name) => {
  const role = import_aria_query.roles.get(name);
  return (
    // 'toolbar' does not descend from widget, but it does support
    // aria-activedescendant, thus in practice we treat it as a widget.
    // focusable tabpanel elements are recommended if any panels in a set contain content where the first element in the panel is not focusable.
    // 'generic' is meant to have no semantic meaning.
    // 'cell' is treated as CellRole by the AXObject which is interactive, so we treat 'cell' it as interactive as well.
    !["toolbar", "tabpanel", "generic", "cell"].includes(name) && !(role == null ? void 0 : role.superClass.some((classes) => classes.includes("widget") || classes.includes("window")))
  );
}).concat(
  // The `progressbar` is descended from `widget`, but in practice, its
  // value is always `readonly`, so we treat it as a non-interactive role.
  "progressbar"
);
var interactive_roles = non_abstract_roles.filter(
  (name) => !non_interactive_roles.includes(name) && // 'generic' is meant to have no semantic meaning.
  name !== "generic"
);
function is_non_interactive_roles(role) {
  return non_interactive_roles.includes(role);
}
function is_interactive_roles(role) {
  return interactive_roles.includes(role);
}
function is_abstract_role(role) {
  return abstract_roles.includes(role);
}
var presentation_roles = ["presentation", "none"];
function is_presentation_role(role) {
  return presentation_roles.includes(role);
}
function is_hidden_from_screen_reader(tag_name, attribute_map) {
  if (tag_name === "input") {
    const type = get_static_value2(attribute_map.get("type"));
    if (type === "hidden") {
      return true;
    }
  }
  const aria_hidden = attribute_map.get("aria-hidden");
  if (!aria_hidden) return false;
  const aria_hidden_value = get_static_value2(aria_hidden);
  if (aria_hidden_value === null) return true;
  return aria_hidden_value === true || aria_hidden_value === "true";
}
function has_disabled_attribute(attribute_map) {
  const disabled_attr_value = get_static_value2(attribute_map.get("disabled"));
  if (disabled_attr_value) {
    return true;
  }
  const aria_disabled_attr = attribute_map.get("aria-disabled");
  if (aria_disabled_attr) {
    const aria_disabled_attr_value = get_static_value2(aria_disabled_attr);
    if (aria_disabled_attr_value === "true") {
      return true;
    }
  }
  return false;
}
var non_interactive_element_role_schemas = [];
import_aria_query.elementRoles.entries().forEach(([schema, roles]) => {
  if ([...roles].every((role) => role !== "generic" && non_interactive_roles.includes(role))) {
    non_interactive_element_role_schemas.push(schema);
  }
});
var interactive_element_role_schemas = [];
import_aria_query.elementRoles.entries().forEach(([schema, roles]) => {
  if ([...roles].every((role) => interactive_roles.includes(role))) {
    interactive_element_role_schemas.push(schema);
  }
});
var interactive_ax_objects = [...import_axobject_query.AXObjects.keys()].filter(
  (name) => import_axobject_query.AXObjects.get(name).type === "widget"
);
var non_interactive_ax_objects = [...import_axobject_query.AXObjects.keys()].filter(
  (name) => ["windows", "structure"].includes(import_axobject_query.AXObjects.get(name).type)
);
var interactive_element_ax_object_schemas = [];
import_axobject_query.elementAXObjects.entries().forEach(
  /**
   * @param {any} _
   */
  ([schema, ax_object]) => {
    if ([...ax_object].every((role) => interactive_ax_objects.includes(role))) {
      interactive_element_ax_object_schemas.push(schema);
    }
  }
);
var non_interactive_element_ax_object_schemas = [];
import_axobject_query.elementAXObjects.entries().forEach(
  /**
   * @param {any} _
   */
  ([schema, ax_object]) => {
    if ([...ax_object].every((role) => non_interactive_ax_objects.includes(role))) {
      non_interactive_element_ax_object_schemas.push(schema);
    }
  }
);
function match_schema(schema, tag_name, attribute_map) {
  if (schema.name !== tag_name) return false;
  if (!schema.attributes) return true;
  return schema.attributes.every((schema_attribute) => {
    const attribute = attribute_map.get(schema_attribute.name);
    if (!attribute) return false;
    if (schema_attribute.value && schema_attribute.value !== get_static_text_value(attribute)) {
      return false;
    }
    return true;
  });
}
var ElementInteractivity = (
  /** @type {const} */
  {
    Interactive: "interactive",
    NonInteractive: "non-interactive",
    Static: "static"
  }
);
function element_interactivity(tag_name, attribute_map) {
  if (interactive_element_role_schemas.some((schema) => match_schema(schema, tag_name, attribute_map))) {
    return ElementInteractivity.Interactive;
  }
  if (tag_name !== "header" && non_interactive_element_role_schemas.some(
    (schema) => match_schema(schema, tag_name, attribute_map)
  )) {
    return ElementInteractivity.NonInteractive;
  }
  if (interactive_element_ax_object_schemas.some(
    (schema) => match_schema(schema, tag_name, attribute_map)
  )) {
    return ElementInteractivity.Interactive;
  }
  if (non_interactive_element_ax_object_schemas.some(
    (schema) => match_schema(schema, tag_name, attribute_map)
  )) {
    return ElementInteractivity.NonInteractive;
  }
  return ElementInteractivity.Static;
}
function is_interactive_element(tag_name, attribute_map) {
  return element_interactivity(tag_name, attribute_map) === ElementInteractivity.Interactive;
}
function is_non_interactive_element(tag_name, attribute_map) {
  return element_interactivity(tag_name, attribute_map) === ElementInteractivity.NonInteractive;
}
function is_static_element(tag_name, attribute_map) {
  return element_interactivity(tag_name, attribute_map) === ElementInteractivity.Static;
}
function is_semantic_role_element(role, tag_name, attribute_map) {
  for (const [schema, ax_object] of import_axobject_query.elementAXObjects.entries()) {
    if (schema.name === tag_name && (!schema.attributes || schema.attributes.every(
      /** @param {any} attr */
      (attr) => attribute_map.has(attr.name) && get_static_value2(attribute_map.get(attr.name)) === attr.value
    ))) {
      for (const name of ax_object) {
        const roles = import_axobject_query.AXObjectRoles.get(name);
        if (roles) {
          for (const { name: name2 } of roles) {
            if (name2 === role) {
              return true;
            }
          }
        }
      }
    }
  }
  return false;
}
var address_type_tokens = ["shipping", "billing"];
var autofill_field_name_tokens = [
  "",
  "on",
  "off",
  "name",
  "honorific-prefix",
  "given-name",
  "additional-name",
  "family-name",
  "honorific-suffix",
  "nickname",
  "username",
  "new-password",
  "current-password",
  "one-time-code",
  "organization-title",
  "organization",
  "street-address",
  "address-line1",
  "address-line2",
  "address-line3",
  "address-level4",
  "address-level3",
  "address-level2",
  "address-level1",
  "country",
  "country-name",
  "postal-code",
  "cc-name",
  "cc-given-name",
  "cc-additional-name",
  "cc-family-name",
  "cc-number",
  "cc-exp",
  "cc-exp-month",
  "cc-exp-year",
  "cc-csc",
  "cc-type",
  "transaction-currency",
  "transaction-amount",
  "language",
  "bday",
  "bday-day",
  "bday-month",
  "bday-year",
  "sex",
  "url",
  "photo"
];
var contact_type_tokens = ["home", "work", "mobile", "fax", "pager"];
var autofill_contact_field_name_tokens = [
  "tel",
  "tel-country-code",
  "tel-national",
  "tel-area-code",
  "tel-local",
  "tel-local-prefix",
  "tel-local-suffix",
  "tel-extension",
  "email",
  "impp"
];
function is_valid_autocomplete(autocomplete) {
  if (autocomplete === true) {
    return false;
  } else if (!autocomplete) {
    return true;
  }
  const tokens = autocomplete.trim().toLowerCase().split(regex_whitespaces);
  if (typeof tokens[0] === "string" && tokens[0].startsWith("section-")) {
    tokens.shift();
  }
  if (address_type_tokens.includes(tokens[0])) {
    tokens.shift();
  }
  if (autofill_field_name_tokens.includes(tokens[0])) {
    tokens.shift();
  } else {
    if (contact_type_tokens.includes(tokens[0])) {
      tokens.shift();
    }
    if (autofill_contact_field_name_tokens.includes(tokens[0])) {
      tokens.shift();
    } else {
      return false;
    }
  }
  if (tokens[0] === "webauthn") {
    tokens.shift();
  }
  return tokens.length === 0;
}
var aria_attributes = "activedescendant atomic autocomplete busy checked colcount colindex colspan controls current describedby description details disabled dropeffect errormessage expanded flowto grabbed haspopup hidden invalid keyshortcuts label labelledby level live modal multiline multiselectable orientation owns placeholder posinset pressed readonly relevant required roledescription rowcount rowindex rowspan selected setsize sort valuemax valuemin valuenow valuetext".split(
  " "
);
var a11y_required_attributes = {
  a: ["href"],
  area: ["alt", "aria-label", "aria-labelledby"],
  // html-has-lang
  html: ["lang"],
  // iframe-has-title
  iframe: ["title"],
  img: ["alt"],
  object: ["title", "aria-label", "aria-labelledby"]
};
var a11y_distracting_elements2 = ["blink", "marquee"];
var a11y_required_content = [
  // heading-has-content
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6"
];
var a11y_labelable = [
  "button",
  "input",
  "keygen",
  "meter",
  "output",
  "progress",
  "select",
  "textarea"
];
var a11y_interactive_handlers = [
  // Keyboard events
  "keypress",
  "keydown",
  "keyup",
  // Click events
  "click",
  "contextmenu",
  "dblclick",
  "drag",
  "dragend",
  "dragenter",
  "dragexit",
  "dragleave",
  "dragover",
  "dragstart",
  "drop",
  "mousedown",
  "mouseenter",
  "mouseleave",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup"
];
var a11y_recommended_interactive_handlers = [
  "click",
  "mousedown",
  "mouseup",
  "keypress",
  "keydown",
  "keyup"
];
var a11y_nested_implicit_semantics = /* @__PURE__ */ new Map([
  ["header", "banner"],
  ["footer", "contentinfo"]
]);
var a11y_implicit_semantics = /* @__PURE__ */ new Map([
  ["a", "link"],
  ["area", "link"],
  ["article", "article"],
  ["aside", "complementary"],
  ["body", "document"],
  ["button", "button"],
  ["datalist", "listbox"],
  ["dd", "definition"],
  ["dfn", "term"],
  ["dialog", "dialog"],
  ["details", "group"],
  ["dt", "term"],
  ["fieldset", "group"],
  ["figure", "figure"],
  ["form", "form"],
  ["h1", "heading"],
  ["h2", "heading"],
  ["h3", "heading"],
  ["h4", "heading"],
  ["h5", "heading"],
  ["h6", "heading"],
  ["hr", "separator"],
  ["img", "img"],
  ["li", "listitem"],
  ["link", "link"],
  ["main", "main"],
  ["menu", "list"],
  ["meter", "progressbar"],
  ["nav", "navigation"],
  ["ol", "list"],
  ["option", "option"],
  ["optgroup", "group"],
  ["output", "status"],
  ["progress", "progressbar"],
  ["section", "region"],
  ["summary", "button"],
  ["table", "table"],
  ["tbody", "rowgroup"],
  ["textarea", "textbox"],
  ["tfoot", "rowgroup"],
  ["thead", "rowgroup"],
  ["tr", "row"],
  ["ul", "list"]
]);
var menuitem_type_to_implicit_role = /* @__PURE__ */ new Map([
  ["command", "menuitem"],
  ["checkbox", "menuitemcheckbox"],
  ["radio", "menuitemradio"]
]);
var input_type_to_implicit_role = /* @__PURE__ */ new Map([
  ["button", "button"],
  ["image", "button"],
  ["reset", "button"],
  ["submit", "button"],
  ["checkbox", "checkbox"],
  ["radio", "radio"],
  ["range", "slider"],
  ["number", "spinbutton"],
  ["email", "textbox"],
  ["search", "searchbox"],
  ["tel", "textbox"],
  ["text", "textbox"],
  ["url", "textbox"]
]);
var a11y_non_interactive_element_to_interactive_role_exceptions = {
  ul: ["listbox", "menu", "menubar", "radiogroup", "tablist", "tree", "treegrid"],
  ol: ["listbox", "menu", "menubar", "radiogroup", "tablist", "tree", "treegrid"],
  li: ["menuitem", "option", "row", "tab", "treeitem"],
  table: ["grid"],
  td: ["gridcell"],
  fieldset: ["radiogroup", "presentation"]
};
var combobox_if_list = ["email", "search", "tel", "text", "url"];
function input_implicit_role(attribute_map) {
  const type_attribute = attribute_map.get("type");
  if (!type_attribute) return;
  const type = get_static_text_value(type_attribute);
  if (!type) return;
  const list_attribute_exists = attribute_map.has("list");
  if (list_attribute_exists && combobox_if_list.includes(type)) {
    return "combobox";
  }
  return input_type_to_implicit_role.get(type);
}
function menuitem_implicit_role(attribute_map) {
  const type_attribute = attribute_map.get("type");
  if (!type_attribute) return;
  const type = get_static_text_value(type_attribute);
  if (!type) return;
  return menuitem_type_to_implicit_role.get(type);
}
function get_implicit_role(name, attribute_map) {
  if (name === "menuitem") {
    return menuitem_implicit_role(attribute_map);
  } else if (name === "input") {
    return input_implicit_role(attribute_map);
  } else {
    return a11y_implicit_semantics.get(name);
  }
}
var invisible_elements = ["meta", "html", "script", "style"];
function is_parent(path11, elements) {
  let i = path11.length;
  while (i--) {
    const parent = path11[i];
    if (parent.type === "SvelteElement") return true;
    if (parent.type === "RegularElement") {
      return elements.includes(parent.name);
    }
  }
  return false;
}
function validate_aria_attribute_value(attribute, name, schema, value) {
  const type = schema.type;
  if (value === null) return;
  if (value === true) value = "";
  if (type === "boolean" && value !== "true" && value !== "false") {
    a11y_incorrect_aria_attribute_type_boolean(attribute, name);
  } else if (type === "integer" && (value === "" || !Number.isInteger(+value))) {
    a11y_incorrect_aria_attribute_type_integer(attribute, name);
  } else if (type === "number" && (value === "" || isNaN(+value))) {
    a11y_incorrect_aria_attribute_type(attribute, name, "number");
  } else if ((type === "string" || type === "id") && value === "") {
    a11y_incorrect_aria_attribute_type(attribute, name, "non-empty string");
  } else if (type === "idlist" && value === "") {
    a11y_incorrect_aria_attribute_type_idlist(attribute, name);
  } else if (type === "token") {
    const values = (schema.values ?? []).map((value2) => value2.toString());
    if (!values.includes(value.toLowerCase())) {
      a11y_incorrect_aria_attribute_type_token(
        attribute,
        name,
        list(values.map((v) => `"${v}"`))
      );
    }
  } else if (type === "tokenlist") {
    const values = (schema.values ?? []).map((value2) => value2.toString());
    if (value.toLowerCase().split(regex_whitespaces).some((value2) => !values.includes(value2))) {
      a11y_incorrect_aria_attribute_type_tokenlist(
        attribute,
        name,
        list(values.map((v) => `"${v}"`))
      );
    }
  } else if (type === "tristate" && value !== "true" && value !== "false" && value !== "mixed") {
    a11y_incorrect_aria_attribute_type_tristate(attribute, name);
  }
}
function warn_missing_attribute(node, attributes, name = node.name) {
  const article = regex_starts_with_vowel.test(attributes[0]) || attributes[0] === "href" ? "an" : "a";
  const sequence3 = attributes.length > 1 ? attributes.slice(0, -1).join(", ") + ` or ${attributes[attributes.length - 1]}` : attributes[0];
  a11y_missing_attribute(node, name, article, sequence3);
}
function get_static_value2(attribute) {
  if (!attribute) return null;
  if (attribute.value === true) return true;
  if (is_text_attribute(attribute)) return attribute.value[0].data;
  return null;
}
function get_static_text_value(attribute) {
  const value = get_static_value2(attribute);
  if (value === true) return null;
  return value;
}
function check_element(node, context) {
  var _a2;
  const attribute_map = /* @__PURE__ */ new Map();
  const handlers2 = /* @__PURE__ */ new Set();
  const attributes = [];
  const is_dynamic_element = node.type === "SvelteElement";
  let has_spread = false;
  let has_contenteditable_attr = false;
  let has_contenteditable_binding = false;
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute") {
      has_spread = true;
    } else if (attribute.type === "OnDirective") {
      handlers2.add(attribute.name);
    } else if (attribute.type === "Attribute") {
      if (is_event_attribute(attribute)) {
        handlers2.add(attribute.name.slice(2));
      } else {
        attributes.push(attribute);
        attribute_map.set(attribute.name, attribute);
        if (attribute.name === "contenteditable") {
          has_contenteditable_attr = true;
        }
      }
    } else if (attribute.type === "BindDirective" && is_content_editable_binding(attribute.name)) {
      has_contenteditable_binding = true;
    }
  }
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute") continue;
    const name = attribute.name.toLowerCase();
    if (name.startsWith("aria-")) {
      if (invisible_elements.includes(node.name)) {
        a11y_aria_attributes(attribute, node.name);
      }
      const type = name.slice(5);
      if (!aria_attributes.includes(type)) {
        const match = fuzzymatch(type, aria_attributes);
        a11y_unknown_aria_attribute(attribute, type, match);
      }
      if (name === "aria-hidden" && regex_heading_tags.test(node.name)) {
        a11y_hidden(attribute, node.name);
      }
      let value = get_static_value2(attribute);
      const schema = import_aria_query.aria.get(
        /** @type {ARIAProperty} */
        name
      );
      if (schema !== void 0) {
        validate_aria_attribute_value(
          attribute,
          /** @type {ARIAProperty} */
          name,
          schema,
          value
        );
      }
      if (name === "aria-activedescendant" && !is_dynamic_element && !is_interactive_element(node.name, attribute_map) && !attribute_map.has("tabindex") && !has_spread) {
        a11y_aria_activedescendant_has_tabindex(attribute);
      }
    }
    if (name === "role") {
      if (invisible_elements.includes(node.name)) {
        a11y_misplaced_role(attribute, node.name);
      }
      const value = get_static_value2(attribute);
      if (typeof value === "string") {
        for (const c_r of value.split(regex_whitespaces)) {
          const current_role = (
            /** @type {ARIARoleDefinitionKey} current_role */
            c_r
          );
          if (current_role && is_abstract_role(current_role)) {
            a11y_no_abstract_role(attribute, current_role);
          } else if (current_role && !aria_roles.includes(current_role)) {
            const match = fuzzymatch(current_role, aria_roles);
            a11y_unknown_role(attribute, current_role, match);
          }
          if (current_role === get_implicit_role(node.name, attribute_map) && // <ul role="list"> is ok because CSS list-style:none removes the semantics and this is a way to bring them back
          !["ul", "ol", "li"].includes(node.name) && // <a role="link" /> is ok because without href the a tag doesn't have a role of link
          !(node.name === "a" && !attribute_map.has("href"))) {
            a11y_no_redundant_roles(attribute, current_role);
          }
          const is_parent_section_or_article = is_parent(context.path, ["section", "article"]);
          if (!is_parent_section_or_article) {
            const has_nested_redundant_role = current_role === a11y_nested_implicit_semantics.get(node.name);
            if (has_nested_redundant_role) {
              a11y_no_redundant_roles(attribute, current_role);
            }
          }
          if (!is_dynamic_element && !is_semantic_role_element(current_role, node.name, attribute_map)) {
            const role2 = import_aria_query.roles.get(current_role);
            if (role2) {
              const required_role_props = Object.keys(role2.requiredProps);
              const has_missing_props = !has_spread && required_role_props.some((prop2) => !attributes.find((a) => a.name === prop2));
              if (has_missing_props) {
                a11y_role_has_required_aria_props(
                  attribute,
                  current_role,
                  list(
                    required_role_props.map((v) => `"${v}"`),
                    "and"
                  )
                );
              }
            }
          }
          if (!has_spread && !has_disabled_attribute(attribute_map) && !is_hidden_from_screen_reader(node.name, attribute_map) && !is_presentation_role(current_role) && is_interactive_roles(current_role) && is_static_element(node.name, attribute_map) && !attribute_map.get("tabindex")) {
            const has_interactive_handlers = [...handlers2].some(
              (handler) => a11y_interactive_handlers.includes(handler)
            );
            if (has_interactive_handlers) {
              a11y_interactive_supports_focus(node, current_role);
            }
          }
          if (!has_spread && is_interactive_element(node.name, attribute_map) && (is_non_interactive_roles(current_role) || is_presentation_role(current_role))) {
            a11y_no_interactive_element_to_noninteractive_role(node, node.name, current_role);
          }
          if (!has_spread && is_non_interactive_element(node.name, attribute_map) && is_interactive_roles(current_role) && !((_a2 = a11y_non_interactive_element_to_interactive_role_exceptions[node.name]) == null ? void 0 : _a2.includes(
            current_role
          ))) {
            a11y_no_noninteractive_element_to_interactive_role(node, node.name, current_role);
          }
        }
      }
    }
    if (name === "accesskey") {
      a11y_accesskey(attribute);
    }
    if (name === "autofocus") {
      a11y_autofocus(attribute);
    }
    if (name === "scope" && !is_dynamic_element && node.name !== "th") {
      a11y_misplaced_scope(attribute);
    }
    if (name === "tabindex") {
      const value = get_static_value2(attribute);
      if (!isNaN(value) && +value > 0) {
        a11y_positive_tabindex(attribute);
      }
    }
  }
  const role = attribute_map.get("role");
  const role_static_value = (
    /** @type {ARIARoleDefinitionKey} */
    get_static_text_value(role)
  );
  if (handlers2.has("click")) {
    const is_non_presentation_role = role_static_value !== null && !is_presentation_role(role_static_value);
    if (!is_dynamic_element && !is_hidden_from_screen_reader(node.name, attribute_map) && (!role || is_non_presentation_role) && !is_interactive_element(node.name, attribute_map) && !has_spread) {
      const has_key_event = handlers2.has("keydown") || handlers2.has("keyup") || handlers2.has("keypress");
      if (!has_key_event) {
        a11y_click_events_have_key_events(node);
      }
    }
  }
  const role_value = (
    /** @type {ARIARoleDefinitionKey} */
    role ? role_static_value : get_implicit_role(node.name, attribute_map)
  );
  if (!is_dynamic_element && !is_interactive_element(node.name, attribute_map) && !is_interactive_roles(role_static_value)) {
    const tab_index = attribute_map.get("tabindex");
    const tab_index_value = get_static_text_value(tab_index);
    if (tab_index && (tab_index_value === null || Number(tab_index_value) >= 0)) {
      a11y_no_noninteractive_tabindex(node);
    }
  }
  if (typeof role_value === "string" && import_aria_query.roles.has(role_value)) {
    const { props } = (
      /** @type {ARIARoleDefinition} */
      import_aria_query.roles.get(role_value)
    );
    const invalid_aria_props = import_aria_query.aria.keys().filter((attribute) => !(attribute in props));
    const is_implicit = role_value && role === void 0;
    for (const attr of attributes) {
      if (invalid_aria_props.includes(
        /** @type {ARIAProperty} */
        attr.name
      )) {
        if (is_implicit) {
          a11y_role_supports_aria_props_implicit(attr, attr.name, role_value, node.name);
        } else {
          a11y_role_supports_aria_props(attr, attr.name, role_value);
        }
      }
    }
  }
  if (!has_spread && !has_contenteditable_attr && !is_hidden_from_screen_reader(node.name, attribute_map) && !is_presentation_role(role_static_value) && (!is_interactive_element(node.name, attribute_map) && is_non_interactive_roles(role_static_value) || is_non_interactive_element(node.name, attribute_map) && !role)) {
    const has_interactive_handlers = [...handlers2].some(
      (handler) => a11y_recommended_interactive_handlers.includes(handler)
    );
    if (has_interactive_handlers) {
      a11y_no_noninteractive_element_interactions(node, node.name);
    }
  }
  if (!has_spread && (!role || role_static_value !== null) && !is_hidden_from_screen_reader(node.name, attribute_map) && !is_presentation_role(role_static_value) && !is_interactive_element(node.name, attribute_map) && !is_interactive_roles(role_static_value) && !is_non_interactive_element(node.name, attribute_map) && !is_non_interactive_roles(role_static_value) && !is_abstract_role(role_static_value)) {
    const interactive_handlers = [...handlers2].filter(
      (handler) => a11y_interactive_handlers.includes(handler)
    );
    if (interactive_handlers.length > 0) {
      a11y_no_static_element_interactions(node, node.name, list(interactive_handlers));
    }
  }
  if (!has_spread && handlers2.has("mouseover") && !handlers2.has("focus")) {
    a11y_mouse_events_have_key_events(node, "mouseover", "focus");
  }
  if (!has_spread && handlers2.has("mouseout") && !handlers2.has("blur")) {
    a11y_mouse_events_have_key_events(node, "mouseout", "blur");
  }
  const is_labelled = attribute_map.has("aria-label") || attribute_map.has("aria-labelledby");
  if (node.name === "a" || node.name === "button") {
    const is_hidden = get_static_value2(attribute_map.get("aria-hidden")) === "true";
    if (!has_spread && !is_hidden && !is_labelled && !has_content(node)) {
      a11y_consider_explicit_label(node);
    }
  }
  if (node.name === "a") {
    const href = attribute_map.get("href") || attribute_map.get("xlink:href");
    if (href) {
      const href_value = get_static_text_value(href);
      if (href_value !== null) {
        if (href_value === "" || href_value === "#" || /^\W*javascript:/i.test(href_value)) {
          a11y_invalid_attribute(href, href_value, href.name);
        }
      }
    } else if (!has_spread) {
      const id_attribute = get_static_value2(attribute_map.get("id"));
      const name_attribute = get_static_value2(attribute_map.get("name"));
      const aria_disabled_attribute = get_static_value2(attribute_map.get("aria-disabled"));
      if (!id_attribute && !name_attribute && aria_disabled_attribute !== "true") {
        warn_missing_attribute(node, ["href"]);
      }
    }
  } else if (!has_spread) {
    const required_attributes = a11y_required_attributes[node.name];
    if (required_attributes) {
      const has_attribute = required_attributes.some((name) => attribute_map.has(name));
      if (!has_attribute) {
        warn_missing_attribute(node, required_attributes);
      }
    }
  }
  if (node.name === "input") {
    const type = attribute_map.get("type");
    const type_value = get_static_text_value(type);
    if (type_value === "image" && !has_spread) {
      const required_attributes = ["alt", "aria-label", "aria-labelledby"];
      const has_attribute = required_attributes.some((name) => attribute_map.has(name));
      if (!has_attribute) {
        warn_missing_attribute(node, required_attributes, 'input type="image"');
      }
    }
    const autocomplete = attribute_map.get("autocomplete");
    if (type && autocomplete) {
      const autocomplete_value = get_static_value2(autocomplete);
      if (!is_valid_autocomplete(autocomplete_value)) {
        a11y_autocomplete_valid(
          autocomplete,
          /** @type {string} */
          autocomplete_value,
          type_value ?? "..."
        );
      }
    }
  }
  if (node.name === "img") {
    const alt_attribute = get_static_text_value(attribute_map.get("alt"));
    const aria_hidden = get_static_value2(attribute_map.get("aria-hidden"));
    if (alt_attribute && !aria_hidden && !has_spread) {
      if (/\b(image|picture|photo)\b/i.test(alt_attribute)) {
        a11y_img_redundant_alt(node);
      }
    }
  }
  if (node.name === "label") {
    const has_input_child = (node2) => {
      let has = false;
      walk(
        node2,
        {},
        {
          _(node3, { next: next2 }) {
            if (node3.type === "SvelteElement" || node3.type === "SlotElement" || node3.type === "Component" || node3.type === "RenderTag" || node3.type === "RegularElement" && (a11y_labelable.includes(node3.name) || node3.name === "slot")) {
              has = true;
            } else {
              next2();
            }
          }
        }
      );
      return has;
    };
    if (!has_spread && !attribute_map.has("for") && !has_input_child(node)) {
      a11y_label_has_associated_control(node);
    }
  }
  if (node.name === "video") {
    const aria_hidden_attribute = attribute_map.get("aria-hidden");
    const aria_hidden_exist = aria_hidden_attribute && get_static_value2(aria_hidden_attribute);
    if (attribute_map.has("muted") || aria_hidden_exist === "true" || has_spread) {
      return;
    }
    let has_caption = false;
    const track = (
      /** @type {AST.RegularElement | undefined} */
      node.fragment.nodes.find((i) => i.type === "RegularElement" && i.name === "track")
    );
    if (track) {
      has_caption = track.attributes.some(
        (a) => a.type === "SpreadAttribute" || a.type === "Attribute" && a.name === "kind" && get_static_value2(a) === "captions"
      );
    }
    if (!has_caption) {
      a11y_media_has_caption(node);
    }
  }
  if (node.name === "figcaption") {
    if (!is_parent(context.path, ["figure"])) {
      a11y_figcaption_parent(node);
    }
  }
  if (node.name === "figure") {
    const children = node.fragment.nodes.filter((node2) => {
      if (node2.type === "Comment") return false;
      if (node2.type === "Text") return regex_not_whitespace.test(node2.data);
      return true;
    });
    const index = children.findIndex(
      (child) => child.type === "RegularElement" && child.name === "figcaption"
    );
    if (index !== -1 && index !== 0 && index !== children.length - 1) {
      a11y_figcaption_index(children[index]);
    }
  }
  if (a11y_distracting_elements2.includes(node.name)) {
    a11y_distracting_elements(node, node.name);
  }
  if (!has_spread && !is_labelled && !has_contenteditable_binding && a11y_required_content.includes(node.name) && !has_content(node)) {
    a11y_missing_content(node, node.name);
  }
}
function has_content(element2) {
  for (const node of element2.fragment.nodes) {
    if (node.type === "Text") {
      if (node.data.trim() === "") {
        continue;
      }
    }
    if (node.type === "RegularElement" || node.type === "SvelteElement") {
      if (node.name === "img" && node.attributes.some((node2) => node2.type === "Attribute" && node2.name === "alt")) {
        return true;
      }
      if (!has_content(node)) {
        continue;
      }
    }
    return true;
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/element.js
var EVENT_MODIFIERS = [
  "preventDefault",
  "stopPropagation",
  "stopImmediatePropagation",
  "capture",
  "once",
  "passive",
  "nonpassive",
  "self",
  "trusted"
];
function validate_element(node, context) {
  let has_animate_directive = false;
  let in_transition = null;
  let out_transition = null;
  for (const attribute of node.attributes) {
    if (attribute.type === "Attribute") {
      const is_expression = is_expression_attribute(attribute);
      if (context.state.analysis.runes) {
        validate_attribute(attribute, node);
        if (is_expression) {
          const expression = get_attribute_expression(attribute);
          if (expression.type === "SequenceExpression") {
            let i = (
              /** @type {number} */
              expression.start
            );
            while (--i > 0) {
              const char = context.state.analysis.source[i];
              if (char === "(") break;
              if (char === "{") attribute_invalid_sequence_expression(expression);
            }
          }
        }
      }
      if (regex_illegal_attribute_character.test(attribute.name)) {
        attribute_invalid_name(attribute, attribute.name);
      }
      if (attribute.name.startsWith("on") && attribute.name.length > 2) {
        if (!is_expression) {
          attribute_invalid_event_handler(attribute);
        }
        const value = get_attribute_expression(attribute);
        if (value.type === "Identifier" && value.name === attribute.name && !context.state.scope.get(value.name)) {
          attribute_global_event_reference(attribute, attribute.name);
        }
      }
      if (attribute.name === "slot") {
        validate_slot_attribute(context, attribute);
      }
      if (attribute.name === "is") {
        attribute_avoid_is(attribute);
      }
      const correct_name = react_attributes.get(attribute.name);
      if (correct_name) {
        attribute_invalid_property_name(attribute, attribute.name, correct_name);
      }
      validate_attribute_name(attribute);
    } else if (attribute.type === "AnimateDirective") {
      const parent = context.path.at(-2);
      if ((parent == null ? void 0 : parent.type) !== "EachBlock") {
        animation_invalid_placement(attribute);
      } else if (!parent.key) {
        animation_missing_key(attribute);
      } else if (parent.body.nodes.filter(
        (n2) => n2.type !== "Comment" && n2.type !== "ConstTag" && (n2.type !== "Text" || n2.data.trim() !== "")
      ).length > 1) {
        animation_invalid_placement(attribute);
      }
      if (has_animate_directive) {
        animation_duplicate(attribute);
      } else {
        has_animate_directive = true;
      }
    } else if (attribute.type === "TransitionDirective") {
      const existing = (
        /** @type {AST.TransitionDirective | null} */
        attribute.intro && in_transition || attribute.outro && out_transition
      );
      if (existing) {
        const a = existing.intro ? existing.outro ? "transition" : "in" : "out";
        const b = attribute.intro ? attribute.outro ? "transition" : "in" : "out";
        if (a === b) {
          transition_duplicate(attribute, a);
        } else {
          transition_conflict(attribute, a, b);
        }
      }
      if (attribute.intro) in_transition = attribute;
      if (attribute.outro) out_transition = attribute;
    } else if (attribute.type === "OnDirective") {
      let has_passive_modifier = false;
      let conflicting_passive_modifier = "";
      for (const modifier of attribute.modifiers) {
        if (!EVENT_MODIFIERS.includes(modifier)) {
          const list3 = `${EVENT_MODIFIERS.slice(0, -1).join(", ")} or ${EVENT_MODIFIERS.at(-1)}`;
          event_handler_invalid_modifier(attribute, list3);
        }
        if (modifier === "passive") {
          has_passive_modifier = true;
        } else if (modifier === "nonpassive" || modifier === "preventDefault") {
          conflicting_passive_modifier = modifier;
        }
        if (has_passive_modifier && conflicting_passive_modifier) {
          event_handler_invalid_modifier_combination(
            attribute,
            "passive",
            conflicting_passive_modifier
          );
        }
      }
    }
  }
}
var react_attributes = /* @__PURE__ */ new Map([
  ["className", "class"],
  ["htmlFor", "for"]
]);

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/RegularElement.js
function RegularElement(node, context) {
  var _a2;
  validate_element(node, context);
  check_element(node, context);
  node.metadata.path = [...context.path];
  context.state.analysis.elements.push(node);
  if (node.name === "textarea" && node.fragment.nodes.length > 0) {
    for (const attribute of node.attributes) {
      if (attribute.type === "Attribute" && attribute.name === "value") {
        textarea_invalid_content(node);
      }
    }
    if (node.fragment.nodes.length > 1 || node.fragment.nodes[0].type !== "Text") {
      const first = node.fragment.nodes[0];
      if (first.type === "Text") {
        first.data = first.data.replace(regex_starts_with_newline, "");
        first.raw = first.raw.replace(regex_starts_with_newline, "");
      }
      node.attributes.push(
        create_attribute(
          "value",
          /** @type {AST.Text} */
          node.fragment.nodes.at(0).start,
          /** @type {AST.Text} */
          node.fragment.nodes.at(-1).end,
          // @ts-ignore
          node.fragment.nodes
        )
      );
      node.fragment.nodes = [];
    }
  }
  if (node.name === "option" && ((_a2 = node.fragment.nodes) == null ? void 0 : _a2.length) === 1 && node.fragment.nodes[0].type === "ExpressionTag" && !node.attributes.some(
    (attribute) => attribute.type === "Attribute" && attribute.name === "value"
  )) {
    const child = node.fragment.nodes[0];
    node.attributes.push(create_attribute("value", child.start, child.end, [child]));
  }
  const binding = context.state.scope.get(node.name);
  if (binding !== null && binding.declaration_kind === "import" && binding.references.length === 0) {
    component_name_lowercase(node, node.name);
  }
  node.metadata.has_spread = node.attributes.some(
    (attribute) => attribute.type === "SpreadAttribute"
  );
  const is_svg_element = () => {
    if (is_svg(node.name)) {
      return true;
    }
    if (node.name === "a" || node.name === "title") {
      let i = context.path.length;
      while (i--) {
        const ancestor = context.path[i];
        if (ancestor.type === "RegularElement") {
          return ancestor.metadata.svg;
        }
      }
    }
    return false;
  };
  node.metadata.svg = is_svg_element();
  node.metadata.mathml = is_mathml(node.name);
  if (is_custom_element_node(node) && node.attributes.length > 0) {
    mark_subtree_dynamic(context.path);
  }
  if (context.state.parent_element) {
    let past_parent = false;
    let only_warn = false;
    const ancestors = [context.state.parent_element];
    for (let i = context.path.length - 1; i >= 0; i--) {
      const ancestor = context.path[i];
      if (ancestor.type === "IfBlock" || ancestor.type === "EachBlock" || ancestor.type === "AwaitBlock" || ancestor.type === "KeyBlock") {
        only_warn = true;
      }
      if (!past_parent) {
        if (ancestor.type === "RegularElement" && ancestor.name === context.state.parent_element) {
          const message = is_tag_valid_with_parent(node.name, context.state.parent_element);
          if (message) {
            if (only_warn) {
              node_invalid_placement_ssr(node, message);
            } else {
              node_invalid_placement(node, message);
            }
          }
          past_parent = true;
        }
      } else if (ancestor.type === "RegularElement") {
        ancestors.push(ancestor.name);
        const message = is_tag_valid_with_ancestor(node.name, ancestors);
        if (message) {
          if (only_warn) {
            node_invalid_placement_ssr(node, message);
          } else {
            node_invalid_placement(node, message);
          }
        }
      } else if (ancestor.type === "Component" || ancestor.type === "SvelteComponent" || ancestor.type === "SvelteElement" || ancestor.type === "SvelteSelf" || ancestor.type === "SnippetBlock") {
        break;
      }
    }
  }
  const node_name = node.name.replace(/[a-zA-Z-]*:/g, "");
  if (context.state.analysis.source[node.end - 2] === "/" && !is_void(node_name) && !is_svg(node_name) && !is_mathml(node_name)) {
    element_invalid_self_closing_tag(node, node.name);
  }
  context.next({ ...context.state, parent_element: node.name });
  if (node.name === "a" && !context.state.parent_element) {
    for (const child of node.fragment.nodes) {
      if (child.type === "RegularElement") {
        if (child.metadata.svg && child.name !== "svg") {
          node.metadata.svg = true;
          break;
        }
      }
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/RenderTag.js
function RenderTag(node, context) {
  var _a2;
  validate_opening_tag(node, context.state, "@");
  node.metadata.path = [...context.path];
  const expression = unwrap_optional(node.expression);
  const callee = expression.callee;
  const binding = callee.type === "Identifier" ? context.state.scope.get(callee.name) : null;
  node.metadata.dynamic = (binding == null ? void 0 : binding.kind) !== "normal";
  let resolved = callee.type === "Identifier" && is_resolved_snippet(binding);
  if (((_a2 = binding == null ? void 0 : binding.initial) == null ? void 0 : _a2.type) === "SnippetBlock") {
    node.metadata.snippets.add(binding.initial);
  }
  context.state.analysis.snippet_renderers.set(node, resolved);
  context.state.analysis.uses_render_tags = true;
  const raw_args = unwrap_optional(node.expression).arguments;
  for (const arg of raw_args) {
    if (arg.type === "SpreadElement") {
      render_tag_invalid_spread_argument(arg);
    }
  }
  if (callee.type === "MemberExpression" && callee.property.type === "Identifier" && ["bind", "apply", "call"].includes(callee.property.name)) {
    render_tag_invalid_call_expression(node);
  }
  mark_subtree_dynamic(context.path);
  context.visit(callee);
  for (const arg of expression.arguments) {
    const metadata = create_expression_metadata();
    node.metadata.arguments.push(metadata);
    context.visit(arg, {
      ...context.state,
      expression: metadata
    });
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SlotElement.js
function SlotElement(node, context) {
  if (context.state.analysis.runes && !context.state.analysis.custom_element) {
    slot_element_deprecated(node);
  }
  mark_subtree_dynamic(context.path);
  let name = "default";
  for (const attribute of node.attributes) {
    if (attribute.type === "Attribute") {
      if (attribute.name === "name") {
        if (!is_text_attribute(attribute)) {
          slot_element_invalid_name(attribute);
        }
        name = attribute.value[0].data;
        if (name === "default") {
          slot_element_invalid_name_default(attribute);
        }
      }
    } else if (attribute.type !== "SpreadAttribute" && attribute.type !== "LetDirective") {
      slot_element_invalid_attribute(attribute);
    }
  }
  context.state.analysis.slot_names.set(name, node);
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SnippetBlock.js
function SnippetBlock(node, context) {
  context.state.analysis.snippets.add(node);
  validate_block_not_empty(node.body, context);
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, "#");
  }
  for (const arg of node.parameters) {
    if (arg.type === "RestElement") {
      snippet_invalid_rest_parameter(arg);
    }
  }
  context.next({ ...context.state, parent_element: null });
  const can_hoist = context.path.length === 1 && context.path[0].type === "Fragment" && can_hoist_snippet(context.state.scope, context.state.scopes);
  const name = node.expression.name;
  if (can_hoist) {
    const binding = (
      /** @type {Binding} */
      context.state.scope.get(name)
    );
    context.state.analysis.module.scope.declarations.set(name, binding);
  } else {
    const undefined_export = context.state.analysis.undefined_exports.get(name);
    if (undefined_export) {
      snippet_invalid_export(undefined_export);
    }
  }
  node.metadata.can_hoist = can_hoist;
  const { path: path11 } = context;
  const parent = path11.at(-2);
  if (!parent) return;
  if (parent.type === "Component" && parent.attributes.some(
    (attribute) => (attribute.type === "Attribute" || attribute.type === "BindDirective") && attribute.name === node.expression.name
  )) {
    snippet_shadowing_prop(node, node.expression.name);
  }
  if (node.expression.name !== "children") return;
  if (parent.type === "Component" || parent.type === "SvelteComponent" || parent.type === "SvelteSelf") {
    if (parent.fragment.nodes.some(
      (node2) => node2.type !== "SnippetBlock" && (node2.type !== "Text" || node2.data.trim()) && node2.type !== "Comment"
    )) {
      snippet_conflict(node);
    }
  }
}
function can_hoist_snippet(scope, scopes, visited = /* @__PURE__ */ new Set()) {
  var _a2;
  for (const [reference] of scope.references) {
    const binding = scope.get(reference);
    if (!binding || binding.scope.function_depth === 0) {
      continue;
    }
    if (binding.scope.function_depth >= scope.function_depth) {
      continue;
    }
    if (((_a2 = binding.initial) == null ? void 0 : _a2.type) === "SnippetBlock") {
      if (visited.has(binding)) continue;
      visited.add(binding);
      const snippet_scope = (
        /** @type {Scope} */
        scopes.get(binding.initial)
      );
      if (can_hoist_snippet(snippet_scope, scopes, visited)) {
        continue;
      }
    }
    return false;
  }
  return true;
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SpreadAttribute.js
function SpreadAttribute(node, context) {
  mark_subtree_dynamic(context.path);
  context.next({ ...context.state, expression: node.metadata.expression });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SpreadElement.js
function SpreadElement(node, context) {
  if (context.state.expression) {
    context.state.expression.has_call = true;
    context.state.expression.has_state = true;
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/StyleDirective.js
function StyleDirective(node, context) {
  var _a2, _b;
  if (node.modifiers.length > 1 || node.modifiers.length && node.modifiers[0] !== "important") {
    style_directive_invalid_modifier(node);
  }
  mark_subtree_dynamic(context.path);
  if (node.value === true) {
    let binding = context.state.scope.get(node.name);
    if (binding) {
      if (binding.kind !== "normal") {
        node.metadata.expression.has_state = true;
      }
    }
  } else {
    context.next();
    for (const chunk of get_attribute_chunks(node.value)) {
      if (chunk.type !== "ExpressionTag") continue;
      (_a2 = node.metadata.expression).has_state || (_a2.has_state = chunk.metadata.expression.has_state);
      (_b = node.metadata.expression).has_call || (_b.has_call = chunk.metadata.expression.has_call);
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteBody.js
function SvelteBody(node, context) {
  disallow_children(node);
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute" || attribute.type === "Attribute" && !is_event_attribute(attribute)) {
      svelte_body_illegal_attribute(attribute);
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteComponent.js
function SvelteComponent(node, context) {
  if (context.state.analysis.runes) {
    svelte_component_deprecated(node);
  }
  context.visit(node.expression);
  visit_component(node, context);
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteDocument.js
function SvelteDocument(node, context) {
  disallow_children(node);
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute" || attribute.type === "Attribute" && !is_event_attribute(attribute)) {
      illegal_element_attribute(attribute, "svelte:document");
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteElement.js
function SvelteElement(node, context) {
  validate_element(node, context);
  check_element(node, context);
  node.metadata.path = [...context.path];
  context.state.analysis.elements.push(node);
  const xmlns = (
    /** @type {AST.Attribute & { value: [AST.Text] } | undefined} */
    node.attributes.find(
      (a) => a.type === "Attribute" && a.name === "xmlns" && is_text_attribute(a)
    )
  );
  if (xmlns) {
    node.metadata.svg = xmlns.value[0].data === NAMESPACE_SVG;
    node.metadata.mathml = xmlns.value[0].data === NAMESPACE_MATHML;
  } else {
    let i = context.path.length;
    while (i--) {
      const ancestor = context.path[i];
      if (ancestor.type === "Component" || ancestor.type === "SvelteComponent" || ancestor.type === "SvelteFragment" || ancestor.type === "SnippetBlock" || i === 0) {
        node.metadata.svg = context.state.options.namespace === "svg";
        node.metadata.mathml = context.state.options.namespace === "mathml";
        break;
      }
      if (ancestor.type === "SvelteElement" || ancestor.type === "RegularElement") {
        node.metadata.svg = ancestor.type === "RegularElement" && ancestor.name === "foreignObject" ? false : ancestor.metadata.svg;
        node.metadata.mathml = ancestor.type === "RegularElement" && ancestor.name === "foreignObject" ? false : ancestor.metadata.mathml;
        break;
      }
    }
  }
  mark_subtree_dynamic(context.path);
  context.next({ ...context.state, parent_element: null });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteFragment.js
function SvelteFragment(node, context) {
  const parent = context.path.at(-2);
  if ((parent == null ? void 0 : parent.type) !== "Component" && (parent == null ? void 0 : parent.type) !== "SvelteComponent") {
    svelte_fragment_invalid_placement(node);
  }
  for (const attribute of node.attributes) {
    if (attribute.type === "Attribute") {
      if (attribute.name === "slot") {
        validate_slot_attribute(context, attribute);
      }
    } else if (attribute.type !== "LetDirective") {
      svelte_fragment_invalid_attribute(attribute);
    }
  }
  context.next({ ...context.state, parent_element: null });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteHead.js
function SvelteHead(node, context) {
  for (const attribute of node.attributes) {
    svelte_head_illegal_attribute(attribute);
  }
  mark_subtree_dynamic(context.path);
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteSelf.js
function SvelteSelf(node, context) {
  const valid2 = context.path.some(
    (node2) => node2.type === "IfBlock" || node2.type === "EachBlock" || node2.type === "Component" || node2.type === "SnippetBlock"
  );
  if (!valid2) {
    svelte_self_invalid_placement(node);
  }
  if (context.state.analysis.runes) {
    const name = filename === "(unknown)" ? "Self" : context.state.analysis.name;
    const basename = filename === "(unknown)" ? "Self.svelte" : (
      /** @type {string} */
      filename.split(/[/\\]/).pop()
    );
    svelte_self_deprecated(node, name, basename);
  }
  visit_component(node, context);
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteWindow.js
function SvelteWindow(node, context) {
  disallow_children(node);
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute" || attribute.type === "Attribute" && !is_event_attribute(attribute)) {
      illegal_element_attribute(attribute, "svelte:window");
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteBoundary.js
var valid = ["onerror", "failed"];
function SvelteBoundary(node, context) {
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute" || !valid.includes(attribute.name)) {
      svelte_boundary_invalid_attribute(attribute);
    }
    if (attribute.value === true || Array.isArray(attribute.value) && (attribute.value.length !== 1 || attribute.value[0].type !== "ExpressionTag")) {
      svelte_boundary_invalid_attribute_value(attribute);
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/TaggedTemplateExpression.js
function TaggedTemplateExpression(node, context) {
  if (context.state.expression && !is_pure(node.tag, context)) {
    context.state.expression.has_call = true;
    context.state.expression.has_state = true;
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/TemplateElement.js
function TemplateElement(node) {
  if (regex_bidirectional_control_characters.test(node.value.cooked ?? "")) {
    bidirectional_control_characters(node);
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/Text.js
function Text(node, context) {
  const parent = (
    /** @type {AST.SvelteNode} */
    context.path.at(-1)
  );
  if (parent.type === "Fragment" && context.state.parent_element && regex_not_whitespace.test(node.data)) {
    const message = is_tag_valid_with_parent("#text", context.state.parent_element);
    if (message) {
      node_invalid_placement(node, message);
    }
  }
  regex_bidirectional_control_characters.lastIndex = 0;
  for (const match of node.data.matchAll(regex_bidirectional_control_characters)) {
    let is_ignored2 = false;
    if (parent.type === "Fragment") {
      for (const child of parent.nodes) {
        if (child === node) break;
        if (child.type === "Comment") {
          is_ignored2 || (is_ignored2 = extract_svelte_ignore(
            child.start + 4,
            child.data,
            context.state.analysis.runes
          ).includes("bidirectional_control_characters"));
        }
      }
    }
    if (!is_ignored2) {
      let start = match.index + node.start;
      bidirectional_control_characters({ start, end: start + match[0].length });
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/TitleElement.js
function TitleElement(node, context) {
  for (const attribute of node.attributes) {
    title_illegal_attribute(attribute);
  }
  for (const child of node.fragment.nodes) {
    if (child.type !== "Text" && child.type !== "ExpressionTag") {
      title_invalid_content(child);
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/TransitionDirective.js
function TransitionDirective(node, context) {
  mark_subtree_dynamic(context.path);
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/UpdateExpression.js
function UpdateExpression(node, context) {
  validate_assignment(node, node.argument, context);
  if (context.state.reactive_statement) {
    const id2 = node.argument.type === "MemberExpression" ? object2(node.argument) : node.argument;
    if ((id2 == null ? void 0 : id2.type) === "Identifier") {
      const binding = context.state.scope.get(id2.name);
      if (binding) {
        context.state.reactive_statement.assignments.add(binding);
      }
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/UseDirective.js
function UseDirective(node, context) {
  mark_subtree_dynamic(context.path);
  context.next();
}

// node_modules/svelte/src/compiler/utils/assert.js
function equal(actual, expected) {
  if (actual !== expected) throw new Error("Assertion failed");
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/VariableDeclarator.js
function VariableDeclarator(node, context) {
  var _a2, _b, _c;
  ensure_no_module_import_conflict(node, context.state);
  if (context.state.analysis.runes) {
    const init3 = node.init;
    const rune = get_rune(init3, context.state.scope);
    const { paths } = extract_paths(node.id, id("dummy"));
    for (const path11 of paths) {
      validate_identifier_name(context.state.scope.get(
        /** @type {Identifier} */
        path11.node.name
      ));
    }
    if (rune === "$state" || rune === "$state.raw" || rune === "$derived" || rune === "$derived.by" || rune === "$props") {
      for (const path11 of paths) {
        const binding = (
          /** @type {Binding} */
          context.state.scope.get(path11.node.name)
        );
        binding.kind = rune === "$state" ? "state" : rune === "$state.raw" ? "raw_state" : rune === "$derived" || rune === "$derived.by" ? "derived" : path11.is_rest ? "rest_prop" : "prop";
      }
    }
    if (rune === "$props") {
      if (node.id.type !== "ObjectPattern" && node.id.type !== "Identifier") {
        props_invalid_identifier(node);
      }
      if (context.state.analysis.custom_element && ((_a2 = context.state.options.customElementOptions) == null ? void 0 : _a2.props) == null) {
        let warn_on;
        if (node.id.type === "Identifier" || (warn_on = node.id.properties.find((p) => p.type === "RestElement")) != null) {
          custom_element_props_identifier(warn_on ?? node.id);
        }
      }
      context.state.analysis.needs_props = true;
      if (node.id.type === "Identifier") {
        const binding = (
          /** @type {Binding} */
          context.state.scope.get(node.id.name)
        );
        binding.initial = null;
        binding.kind = "rest_prop";
      } else {
        equal(node.id.type, "ObjectPattern");
        for (const property of node.id.properties) {
          if (property.type !== "Property") continue;
          if (property.computed) {
            props_invalid_pattern(property);
          }
          if (property.key.type === "Identifier" && property.key.name.startsWith("$$")) {
            props_illegal_name(property);
          }
          const value = property.value.type === "AssignmentPattern" ? property.value.left : property.value;
          if (value.type !== "Identifier") {
            props_invalid_pattern(property);
          }
          const alias = property.key.type === "Identifier" ? property.key.name : String(
            /** @type {Literal} */
            property.key.value
          );
          let initial = property.value.type === "AssignmentPattern" ? property.value.right : null;
          const binding = (
            /** @type {Binding} */
            context.state.scope.get(value.name)
          );
          binding.prop_alias = alias;
          if ((initial == null ? void 0 : initial.type) === "CallExpression" && initial.callee.type === "Identifier" && initial.callee.name === "$bindable") {
            binding.initial = /** @type {Expression | null} */
            initial.arguments[0] ?? null;
            binding.kind = "bindable_prop";
          } else {
            binding.initial = initial;
          }
        }
      }
    }
  } else {
    if (((_b = node.init) == null ? void 0 : _b.type) === "CallExpression") {
      const callee = node.init.callee;
      if (callee.type === "Identifier" && (callee.name === "$state" || callee.name === "$derived" || callee.name === "$props") && ((_c = context.state.scope.get(callee.name)) == null ? void 0 : _c.kind) !== "store_sub") {
        rune_invalid_usage(node.init, callee.name);
      }
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/index.js
var visitors3 = {
  _(node, { state, next: next2, path: path11 }) {
    const parent = path11.at(-1);
    const ignores = [];
    if ((parent == null ? void 0 : parent.type) === "Fragment" && node.type !== "Comment" && node.type !== "Text") {
      const idx = parent.nodes.indexOf(
        /** @type {any} */
        node
      );
      for (let i = idx - 1; i >= 0; i--) {
        const prev = parent.nodes[i];
        if (prev.type === "Comment") {
          ignores.push(
            ...extract_svelte_ignore(
              prev.start + 4,
              prev.data,
              state.analysis.runes
            )
          );
        } else if (prev.type !== "Text") {
          break;
        }
      }
    } else {
      const comments = (
        /** @type {any} */
        node.leadingComments
      );
      if (comments) {
        for (const comment of comments) {
          ignores.push(
            ...extract_svelte_ignore(
              comment.start + 2,
              comment.value,
              state.analysis.runes
            )
          );
        }
      }
    }
    if (ignores.length > 0) {
      push_ignore(ignores);
    }
    ignore_map.set(node, structuredClone(ignore_stack));
    const scope = state.scopes.get(node);
    next2(scope !== void 0 && scope !== state.scope ? { ...state, scope } : state);
    if (ignores.length > 0) {
      pop_ignore();
    }
  },
  ArrowFunctionExpression,
  AssignmentExpression,
  AttachTag,
  Attribute,
  AwaitBlock,
  BindDirective,
  CallExpression,
  ClassBody,
  ClassDeclaration,
  ClassDirective,
  Component,
  ConstTag,
  DebugTag,
  EachBlock,
  ExportDefaultDeclaration,
  ExportNamedDeclaration,
  ExportSpecifier,
  ExpressionStatement,
  ExpressionTag,
  FunctionDeclaration,
  FunctionExpression,
  HtmlTag,
  Identifier,
  IfBlock,
  ImportDeclaration,
  KeyBlock,
  LabeledStatement,
  LetDirective,
  Literal,
  MemberExpression,
  NewExpression,
  OnDirective,
  PropertyDefinition,
  RegularElement,
  RenderTag,
  SlotElement,
  SnippetBlock,
  SpreadAttribute,
  SpreadElement,
  StyleDirective,
  SvelteBody,
  SvelteComponent,
  SvelteDocument,
  SvelteElement,
  SvelteFragment,
  SvelteHead,
  SvelteSelf,
  SvelteWindow,
  SvelteBoundary,
  TaggedTemplateExpression,
  TemplateElement,
  Text,
  TransitionDirective,
  TitleElement,
  UpdateExpression,
  UseDirective,
  VariableDeclarator
};
function js(script, root, allow_reactive_declarations, parent) {
  const ast = (script == null ? void 0 : script.content) ?? {
    type: "Program",
    sourceType: "module",
    start: -1,
    end: -1,
    body: []
  };
  const { scope, scopes } = create_scopes(ast, root, allow_reactive_declarations, parent);
  return { ast, scope, scopes };
}
function get_component_name(filename2) {
  const parts = filename2.split(/[/\\]/);
  const basename = (
    /** @type {string} */
    parts.pop()
  );
  const last_dir = (
    /** @type {string} */
    parts.at(-1)
  );
  let name = basename.replace(".svelte", "");
  if (name === "index" && last_dir && last_dir !== "src") {
    name = last_dir;
  }
  return name[0].toUpperCase() + name.slice(1);
}
var RESERVED = ["$$props", "$$restProps", "$$slots"];
function analyze_module(ast, options) {
  const { scope, scopes } = create_scopes(ast, new ScopeRoot(), false, null);
  for (const [name, references] of scope.references) {
    if (name[0] !== "$" || RESERVED.includes(name)) continue;
    if (name === "$" || name[1] === "$") {
      global_reference_invalid(references[0].node, name);
    }
    const binding = scope.get(name.slice(1));
    if (binding !== null && !is_rune(name)) {
      store_invalid_subscription_module(references[0].node);
    }
  }
  const analysis = {
    module: { ast, scope, scopes },
    name: options.filename,
    accessors: false,
    runes: true,
    immutable: true,
    tracing: false,
    classes: /* @__PURE__ */ new Map()
  };
  walk(
    /** @type {Node} */
    ast,
    {
      scope,
      scopes,
      analysis: (
        /** @type {ComponentAnalysis} */
        analysis
      ),
      state_fields: /* @__PURE__ */ new Map(),
      // TODO the following are not needed for modules, but we have to pass them in order to avoid type error,
      // and reducing the type would result in a lot of tedious type casts elsewhere - find a good solution one day
      ast_type: (
        /** @type {any} */
        null
      ),
      component_slots: /* @__PURE__ */ new Set(),
      expression: null,
      function_depth: 0,
      has_props_rune: false,
      options: (
        /** @type {ValidatedCompileOptions} */
        options
      ),
      parent_element: null,
      reactive_statement: null
    },
    visitors3
  );
  return analysis;
}
function analyze_component(root, source2, options) {
  var _a2, _b, _c;
  const scope_root = new ScopeRoot();
  const module = js(root.module, scope_root, false, null);
  const instance = js(root.instance, scope_root, true, module.scope);
  const { scope, scopes } = create_scopes(root.fragment, scope_root, false, instance.scope);
  const template2 = { ast: root.fragment, scope, scopes };
  let synthetic_stores_legacy_check = [];
  for (const [name, references] of module.scope.references) {
    if (name[0] !== "$" || RESERVED.includes(name)) continue;
    if (name === "$" || name[1] === "$") {
      global_reference_invalid(references[0].node, name);
    }
    const store_name = name.slice(1);
    const declaration2 = instance.scope.get(store_name);
    const init3 = (
      /** @type {Node | undefined} */
      declaration2 == null ? void 0 : declaration2.initial
    );
    if (options.runes === false || !is_rune(name) || declaration2 !== null && // const state = $state(0) is valid
    (get_rune(init3, instance.scope) === null || // rune-line names received as props are valid too (but we have to protect against $props as store)
    store_name !== "props" && get_rune(init3, instance.scope) === "$props") && // allow `import { derived } from 'svelte/store'` in the same file as `const x = $derived(..)` because one is not a subscription to the other
    !(name === "$derived" && ((_a2 = declaration2.initial) == null ? void 0 : _a2.type) === "ImportDeclaration" && declaration2.initial.source.value === "svelte/store")) {
      let is_nested_store_subscription_node = void 0;
      search: for (const reference of references) {
        for (let i = reference.path.length - 1; i >= 0; i--) {
          const scope2 = scopes.get(reference.path[i]) || module.scopes.get(reference.path[i]) || instance.scopes.get(reference.path[i]);
          if (scope2) {
            const owner = scope2 == null ? void 0 : scope2.owner(store_name);
            if (!!owner && owner !== module.scope && owner !== instance.scope) {
              is_nested_store_subscription_node = reference.node;
              break search;
            }
            break;
          }
        }
      }
      if (is_nested_store_subscription_node) {
        store_invalid_scoped_subscription(is_nested_store_subscription_node);
      }
      if (options.runes !== false) {
        if (declaration2 === null && /[a-z]/.test(store_name[0])) {
          global_reference_invalid(references[0].node, name);
        } else if (declaration2 !== null && is_rune(name)) {
          for (const { node, path: path11 } of references) {
            if (((_b = path11.at(-1)) == null ? void 0 : _b.type) === "CallExpression") {
              store_rune_conflict(node, store_name);
            }
          }
        }
      }
      if (module.ast) {
        for (const { node, path: path11 } of references) {
          if (
            /** @type {number} */
            node.start > /** @type {number} */
            module.ast.start && /** @type {number} */
            node.end < /** @type {number} */
            module.ast.end && // const state = $state(0) is valid
            get_rune(
              /** @type {Node} */
              path11.at(-1),
              module.scope
            ) === null
          ) {
            store_invalid_subscription(node);
          }
        }
      }
      synthetic_stores_legacy_check.push(() => {
        if (declaration2 !== null && declaration2.kind === "normal" && declaration2.declaration_kind === "let" && declaration2.reassigned) {
          declaration2.kind = "state";
        }
      });
      const binding = instance.scope.declare(id(name), "store_sub", "synthetic");
      binding.references = references;
      instance.scope.references.set(name, references);
      module.scope.references.delete(name);
    }
  }
  const component_name = get_component_name(options.filename);
  const runes = options.runes ?? Array.from(module.scope.references.keys()).some(is_rune);
  if (!runes) {
    for (let check of synthetic_stores_legacy_check) {
      check();
    }
  }
  if (runes && root.module) {
    const context = root.module.attributes.find((attribute) => attribute.name === "context");
    if (context) {
      script_context_deprecated(context);
    }
  }
  const analysis = {
    name: module.scope.generate(options.name ?? component_name),
    root: scope_root,
    module,
    instance,
    template: template2,
    elements: [],
    runes,
    tracing: false,
    classes: /* @__PURE__ */ new Map(),
    immutable: runes || options.immutable,
    exports: [],
    uses_props: false,
    props_id: null,
    uses_rest_props: false,
    uses_slots: false,
    uses_component_bindings: false,
    uses_render_tags: false,
    needs_context: false,
    needs_mutation_validation: false,
    needs_props: false,
    event_directive_node: null,
    uses_event_attributes: false,
    custom_element: options.customElementOptions ?? options.customElement,
    inject_styles: options.css === "injected" || options.customElement,
    accessors: options.customElement ? true : (runes ? false : !!options.accessors) || // because $set method needs accessors
    ((_c = options.compatibility) == null ? void 0 : _c.componentApi) === 4,
    reactive_statements: /* @__PURE__ */ new Map(),
    binding_groups: /* @__PURE__ */ new Map(),
    slot_names: /* @__PURE__ */ new Map(),
    css: {
      ast: root.css,
      hash: root.css ? options.cssHash({
        css: root.css.content.styles,
        filename: options.filename,
        name: component_name,
        hash
      }) : "",
      keyframes: [],
      has_global: false
    },
    source: source2,
    undefined_exports: /* @__PURE__ */ new Map(),
    snippet_renderers: /* @__PURE__ */ new Map(),
    snippets: /* @__PURE__ */ new Set()
  };
  if (!runes) {
    for (const node of instance.ast.body) {
      if (node.type !== "ExportNamedDeclaration") continue;
      analysis.needs_props = true;
      if (node.declaration) {
        if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
          analysis.exports.push({
            name: (
              /** @type {import('estree').Identifier} */
              node.declaration.id.name
            ),
            alias: null
          });
        } else if (node.declaration.type === "VariableDeclaration") {
          if (node.declaration.kind === "const") {
            for (const declarator2 of node.declaration.declarations) {
              for (const node2 of extract_identifiers(declarator2.id)) {
                analysis.exports.push({ name: node2.name, alias: null });
              }
            }
          } else {
            for (const declarator2 of node.declaration.declarations) {
              for (const id2 of extract_identifiers(declarator2.id)) {
                const binding = (
                  /** @type {Binding} */
                  instance.scope.get(id2.name)
                );
                binding.kind = "bindable_prop";
              }
            }
          }
        }
      } else {
        for (const specifier of node.specifiers) {
          if (specifier.local.type !== "Identifier" || specifier.exported.type !== "Identifier") {
            continue;
          }
          const binding = instance.scope.get(specifier.local.name);
          if (binding && (binding.declaration_kind === "var" || binding.declaration_kind === "let")) {
            binding.kind = "bindable_prop";
            if (specifier.exported.name !== specifier.local.name) {
              binding.prop_alias = specifier.exported.name;
            }
          } else {
            analysis.exports.push({ name: specifier.local.name, alias: specifier.exported.name });
          }
        }
      }
    }
    for (const binding of instance.scope.declarations.values()) {
      if (binding.kind !== "normal") continue;
      for (const { node, path: path11 } of binding.references) {
        if (node === binding.node) continue;
        if (binding.updated) {
          if (path11[path11.length - 1].type === "StyleDirective" || path11.some((node2) => node2.type === "Fragment") || path11[1].type === "LabeledStatement" && path11[1].label.name === "$") {
            binding.kind = "state";
          }
        }
      }
    }
    walk(
      /** @type {AST.SvelteNode} */
      template2.ast,
      null,
      {
        EachBlock(node) {
          const scope2 = (
            /** @type {Scope} */
            template2.scopes.get(node)
          );
          for (const binding of scope2.declarations.values()) {
            if (binding.updated) {
              const state = { scope: (
                /** @type {Scope} */
                scope2.parent
              ), scopes: template2.scopes };
              walk(node.expression, state, {
                // @ts-expect-error
                _: set_scope,
                Identifier(node2, context) {
                  const parent = (
                    /** @type {Expression} */
                    context.path.at(-1)
                  );
                  if (is_reference(node2, parent)) {
                    const binding2 = context.state.scope.get(node2.name);
                    if (binding2 && binding2.kind === "normal" && binding2.declaration_kind !== "import") {
                      binding2.kind = "state";
                      binding2.mutated = true;
                    }
                  }
                }
              });
              break;
            }
          }
        }
      }
    );
  }
  if (root.options) {
    for (const attribute of root.options.attributes) {
      if (attribute.name === "accessors" && analysis.runes) {
        options_deprecated_accessors(attribute);
      }
      if (attribute.name === "customElement" && !options.customElement) {
        options_missing_custom_element(attribute);
      }
      if (attribute.name === "immutable" && analysis.runes) {
        options_deprecated_immutable(attribute);
      }
    }
  }
  if (analysis.runes) {
    const props_refs = module.scope.references.get("$$props");
    if (props_refs) {
      legacy_props_invalid(props_refs[0].node);
    }
    const rest_props_refs = module.scope.references.get("$$restProps");
    if (rest_props_refs) {
      legacy_rest_props_invalid(rest_props_refs[0].node);
    }
    for (const { ast, scope: scope2, scopes: scopes2 } of [module, instance, template2]) {
      const state = {
        scope: scope2,
        scopes: scopes2,
        analysis,
        options,
        ast_type: ast === instance.ast ? "instance" : ast === template2.ast ? "template" : "module",
        parent_element: null,
        has_props_rune: false,
        component_slots: /* @__PURE__ */ new Set(),
        expression: null,
        state_fields: /* @__PURE__ */ new Map(),
        function_depth: scope2.function_depth,
        reactive_statement: null
      };
      walk(
        /** @type {AST.SvelteNode} */
        ast,
        state,
        visitors3
      );
    }
    for (const scope2 of [module.scope, instance.scope]) {
      outer: for (const [name, binding] of scope2.declarations) {
        if (binding.kind === "normal" && binding.reassigned) {
          inner: for (const { path: path11 } of binding.references) {
            if (path11[0].type !== "Fragment") continue;
            for (let i = 1; i < path11.length; i += 1) {
              const type = path11[i].type;
              if (type === "FunctionDeclaration" || type === "FunctionExpression" || type === "ArrowFunctionExpression") {
                continue inner;
              }
              if (type === "BindDirective" && /** @type {AST.BindDirective} */
              path11[i].name === "this") {
                for (let j = i - 1; j >= 0; j -= 1) {
                  const type2 = path11[j].type;
                  if (type2 === "IfBlock" || type2 === "EachBlock" || type2 === "AwaitBlock" || type2 === "KeyBlock") {
                    non_reactive_update(binding.node, name);
                    continue outer;
                  }
                }
                continue inner;
              }
            }
            non_reactive_update(binding.node, name);
            continue outer;
          }
        }
      }
    }
  } else {
    instance.scope.declare(id("$$props"), "rest_prop", "synthetic");
    instance.scope.declare(id("$$restProps"), "rest_prop", "synthetic");
    for (const { ast, scope: scope2, scopes: scopes2 } of [module, instance, template2]) {
      const state = {
        scope: scope2,
        scopes: scopes2,
        analysis,
        options,
        parent_element: null,
        has_props_rune: false,
        ast_type: ast === instance.ast ? "instance" : ast === template2.ast ? "template" : "module",
        reactive_statement: null,
        component_slots: /* @__PURE__ */ new Set(),
        expression: null,
        state_fields: /* @__PURE__ */ new Map(),
        function_depth: scope2.function_depth
      };
      walk(
        /** @type {AST.SvelteNode} */
        ast,
        state,
        visitors3
      );
    }
    for (const [name, binding] of instance.scope.declarations) {
      if ((binding.kind === "prop" || binding.kind === "bindable_prop") && binding.node.name !== "$$props") {
        const references = binding.references.filter(
          (r) => {
            var _a3;
            return r.node !== binding.node && ((_a3 = r.path.at(-1)) == null ? void 0 : _a3.type) !== "ExportSpecifier";
          }
        );
        if (!references.length && !instance.scope.declarations.has(`$${name}`)) {
          export_let_unused(binding.node, name);
        }
      }
    }
    analysis.reactive_statements = order_reactive_statements(analysis.reactive_statements);
  }
  for (const node of analysis.module.ast.body) {
    if (node.type === "ExportNamedDeclaration" && node.specifiers !== null && node.source == null) {
      for (const specifier of node.specifiers) {
        if (specifier.local.type !== "Identifier") continue;
        const binding = analysis.module.scope.get(specifier.local.name);
        if (!binding) export_undefined(specifier, specifier.local.name);
      }
    }
  }
  if (analysis.event_directive_node && analysis.uses_event_attributes) {
    mixed_event_handler_syntaxes(
      analysis.event_directive_node,
      analysis.event_directive_node.name
    );
  }
  for (const [node, resolved] of analysis.snippet_renderers) {
    if (!resolved) {
      node.metadata.snippets = analysis.snippets;
    }
    for (const snippet of node.metadata.snippets) {
      snippet.metadata.sites.add(node);
    }
  }
  if (analysis.uses_render_tags && (analysis.uses_slots || !analysis.custom_element && analysis.slot_names.size > 0)) {
    const pos = analysis.slot_names.values().next().value ?? analysis.source.indexOf("$$slot");
    slot_snippet_conflict(pos);
  }
  if (analysis.css.ast) {
    analyze_css(analysis.css.ast, analysis);
    for (const node of analysis.elements) {
      prune(analysis.css.ast, node);
    }
    const { comment } = analysis.css.ast.content;
    const should_ignore_unused = comment && extract_svelte_ignore(comment.start, comment.data, analysis.runes).includes(
      "css_unused_selector"
    );
    if (!should_ignore_unused) {
      warn_unused(analysis.css.ast);
    }
  }
  for (const node of analysis.elements) {
    if (node.metadata.scoped && is_custom_element_node(node)) {
      mark_subtree_dynamic(node.metadata.path);
    }
    let has_class = false;
    let has_style = false;
    let has_spread = false;
    let has_class_directive = false;
    let has_style_directive = false;
    for (const attribute of node.attributes) {
      if (attribute.type === "SpreadAttribute") {
        has_spread = true;
        break;
      } else if (attribute.type === "Attribute") {
        has_class || (has_class = attribute.name.toLowerCase() === "class");
        has_style || (has_style = attribute.name.toLowerCase() === "style");
      } else if (attribute.type === "ClassDirective") {
        has_class_directive = true;
      } else if (attribute.type === "StyleDirective") {
        has_style_directive = true;
      }
    }
    if (!has_spread && !has_class && (node.metadata.scoped || has_class_directive)) {
      node.attributes.push(
        create_attribute("class", -1, -1, [
          {
            type: "Text",
            data: "",
            raw: "",
            start: -1,
            end: -1
          }
        ])
      );
    }
    if (!has_spread && !has_style && has_style_directive) {
      node.attributes.push(
        create_attribute("style", -1, -1, [
          {
            type: "Text",
            data: "",
            raw: "",
            start: -1,
            end: -1
          }
        ])
      );
    }
  }
  return analysis;
}
function order_reactive_statements(unsorted_reactive_declarations) {
  const lookup = /* @__PURE__ */ new Map();
  for (const [node, declaration2] of unsorted_reactive_declarations) {
    for (const binding of declaration2.assignments) {
      const statements = lookup.get(binding.node.name) ?? [];
      statements.push([node, declaration2]);
      lookup.set(binding.node.name, statements);
    }
  }
  const edges = [];
  for (const [, { assignments, dependencies }] of unsorted_reactive_declarations) {
    for (const assignment2 of assignments) {
      for (const dependency of dependencies) {
        if (!assignments.has(dependency)) {
          edges.push([assignment2.node.name, dependency.node.name]);
        }
      }
    }
  }
  const cycle = check_graph_for_cycles(edges);
  if (cycle == null ? void 0 : cycle.length) {
    const declaration2 = (
      /** @type {Tuple[]} */
      lookup.get(cycle[0])[0]
    );
    reactive_declaration_cycle(declaration2[0], cycle.join(" → "));
  }
  const reactive_declarations = /* @__PURE__ */ new Map();
  const add_declaration = (node, declaration2) => {
    if ([...reactive_declarations.values()].includes(declaration2)) return;
    for (const binding of declaration2.dependencies) {
      if (declaration2.assignments.has(binding)) continue;
      for (const [node2, earlier] of lookup.get(binding.node.name) ?? []) {
        add_declaration(node2, earlier);
      }
    }
    reactive_declarations.set(node, declaration2);
  };
  for (const [node, declaration2] of unsorted_reactive_declarations) {
    add_declaration(node, declaration2);
  }
  return reactive_declarations;
}

// node_modules/esrap/src/handlers.js
var newline = { type: "Newline" };
var indent = { type: "Indent" };
var dedent = { type: "Dedent" };
function create_sequence() {
  return [];
}
function measure(commands, from, to = commands.length) {
  let total = 0;
  for (let i = from; i < to; i += 1) {
    const command = commands[i];
    if (typeof command === "string") {
      total += command.length;
    } else if (Array.isArray(command)) {
      total += command.length === 0 ? 2 : measure(command, 0);
    }
  }
  return total;
}
function handle(node, state) {
  const node_with_comments = (
    /** @type {NodeWithComments} */
    node
  );
  const handler = handlers[node.type];
  if (!handler) {
    throw new Error(`Not implemented ${node.type}`);
  }
  if (node_with_comments.leadingComments) {
    prepend_comments(node_with_comments.leadingComments, state, false);
  }
  handler(node, state);
  if (node_with_comments.trailingComments) {
    state.comments.push(node_with_comments.trailingComments[0]);
  }
}
function l(line, column) {
  return {
    type: "Location",
    line,
    column
  };
}
function c(content, node) {
  return node.loc ? [
    l(node.loc.start.line, node.loc.start.column),
    content,
    l(node.loc.end.line, node.loc.end.column)
  ] : content;
}
function prepend_comments(comments, state, newlines) {
  for (const comment of comments) {
    state.commands.push({ type: "Comment", comment });
    if (newlines || comment.type === "Line" || /\n/.test(comment.value)) {
      state.commands.push(newline);
    } else {
      state.commands.push(" ");
    }
  }
}
function quote(string2, char) {
  let out = char;
  for (const c2 of string2) {
    if (c2 === "\\") {
      out += "\\\\";
    } else if (c2 === char) {
      out += "\\" + c2;
    } else if (c2 === "\n") {
      out += "\\n";
    } else if (c2 === "\r") {
      out += "\\r";
    } else {
      out += c2;
    }
  }
  return out + char;
}
var OPERATOR_PRECEDENCE = {
  "||": 2,
  "&&": 3,
  "??": 4,
  "|": 5,
  "^": 6,
  "&": 7,
  "==": 8,
  "!=": 8,
  "===": 8,
  "!==": 8,
  "<": 9,
  ">": 9,
  "<=": 9,
  ">=": 9,
  in: 9,
  instanceof: 9,
  "<<": 10,
  ">>": 10,
  ">>>": 10,
  "+": 11,
  "-": 11,
  "*": 12,
  "%": 12,
  "/": 12,
  "**": 13
};
var EXPRESSIONS_PRECEDENCE = {
  JSXFragment: 20,
  JSXElement: 20,
  ArrayPattern: 20,
  ObjectPattern: 20,
  ArrayExpression: 20,
  TaggedTemplateExpression: 20,
  ThisExpression: 20,
  Identifier: 20,
  TemplateLiteral: 20,
  Super: 20,
  SequenceExpression: 20,
  MemberExpression: 19,
  MetaProperty: 19,
  CallExpression: 19,
  ChainExpression: 19,
  ImportExpression: 19,
  NewExpression: 19,
  Literal: 18,
  TSSatisfiesExpression: 18,
  TSInstantiationExpression: 18,
  TSNonNullExpression: 18,
  TSTypeAssertion: 18,
  AwaitExpression: 17,
  ClassExpression: 17,
  FunctionExpression: 17,
  ObjectExpression: 17,
  TSAsExpression: 16,
  UpdateExpression: 16,
  UnaryExpression: 15,
  BinaryExpression: 14,
  LogicalExpression: 13,
  ConditionalExpression: 4,
  ArrowFunctionExpression: 3,
  AssignmentExpression: 3,
  YieldExpression: 2,
  RestElement: 1
};
function needs_parens(node, parent, is_right) {
  if (node.type === "PrivateIdentifier") return false;
  if (node.type === "LogicalExpression" && parent.type === "LogicalExpression" && (parent.operator === "??" && node.operator !== "??" || parent.operator !== "??" && node.operator === "??")) {
    return true;
  }
  const precedence = EXPRESSIONS_PRECEDENCE[node.type];
  const parent_precedence = EXPRESSIONS_PRECEDENCE[parent.type];
  if (precedence !== parent_precedence) {
    return !is_right && precedence === 15 && parent_precedence === 14 && parent.operator === "**" || precedence < parent_precedence;
  }
  if (precedence !== 13 && precedence !== 14) {
    return false;
  }
  if (
    /** @type {TSESTree.BinaryExpression} */
    node.operator === "**" && parent.operator === "**"
  ) {
    return !is_right;
  }
  if (is_right) {
    return OPERATOR_PRECEDENCE[
      /** @type {TSESTree.BinaryExpression} */
      node.operator
    ] <= OPERATOR_PRECEDENCE[parent.operator];
  }
  return OPERATOR_PRECEDENCE[
    /** @type {TSESTree.BinaryExpression} */
    node.operator
  ] < OPERATOR_PRECEDENCE[parent.operator];
}
function has_call_expression(node) {
  while (node) {
    if (node.type === "CallExpression") {
      return true;
    } else if (node.type === "MemberExpression") {
      node = node.object;
    } else {
      return false;
    }
  }
}
var grouped_expression_types = [
  "ImportDeclaration",
  "VariableDeclaration",
  "ExportDefaultDeclaration",
  "ExportNamedDeclaration"
];
var handle_body = (nodes, state) => {
  let last_statement = (
    /** @type {TSESTree.Node} */
    {
      type: "EmptyStatement"
    }
  );
  let first = true;
  let needs_margin = false;
  for (const statement of nodes) {
    if (statement.type === "EmptyStatement") continue;
    const margin = create_sequence();
    if (!first) state.commands.push(margin, newline);
    first = false;
    const statement_with_comments = (
      /** @type {NodeWithComments} */
      statement
    );
    const leading_comments = statement_with_comments.leadingComments;
    delete statement_with_comments.leadingComments;
    if (leading_comments && leading_comments.length > 0) {
      prepend_comments(leading_comments, state, true);
    }
    const child_state = { ...state, multiline: false };
    handle(statement, child_state);
    if (child_state.multiline || needs_margin || (grouped_expression_types.includes(statement.type) || grouped_expression_types.includes(last_statement.type)) && last_statement.type !== statement.type) {
      margin.push("\n");
    }
    let add_newline = false;
    while (state.comments.length) {
      const comment = (
        /** @type {TSESTree.Comment} */
        state.comments.shift()
      );
      state.commands.push(add_newline ? newline : " ", { type: "Comment", comment });
      add_newline = comment.type === "Line";
    }
    needs_margin = child_state.multiline;
    last_statement = statement;
  }
};
var handle_var_declaration = (node, state) => {
  const index = state.commands.length;
  const open2 = create_sequence();
  const join = create_sequence();
  const child_state = { ...state, multiline: false };
  state.commands.push(`${node.kind} `, open2);
  let first = true;
  for (const d of node.declarations) {
    if (!first) state.commands.push(join);
    first = false;
    handle(d, child_state);
  }
  const multiline = child_state.multiline || node.declarations.length > 1 && measure(state.commands, index) > 50;
  if (multiline) {
    state.multiline = true;
    if (node.declarations.length > 1) open2.push(indent);
    join.push(",", newline);
    if (node.declarations.length > 1) state.commands.push(dedent);
  } else {
    join.push(", ");
  }
};
function sequence2(nodes, state, spaces, fn, separator = ",") {
  if (nodes.length === 0) return;
  const index = state.commands.length;
  const open2 = create_sequence();
  const join = create_sequence();
  const close2 = create_sequence();
  state.commands.push(open2);
  const child_state = { ...state, multiline: false };
  let prev;
  for (let i = 0; i < nodes.length; i += 1) {
    const node = nodes[i];
    const is_first = i === 0;
    const is_last = i === nodes.length - 1;
    if (node) {
      if (!is_first && !prev) {
        state.commands.push(join);
      }
      fn(node, child_state);
      if (!is_last) {
        state.commands.push(separator);
      }
      if (state.comments.length > 0) {
        state.commands.push(" ");
        while (state.comments.length) {
          const comment = (
            /** @type {TSESTree.Comment} */
            state.comments.shift()
          );
          state.commands.push({ type: "Comment", comment });
          if (!is_last) state.commands.push(join);
        }
        child_state.multiline = true;
      } else {
        if (!is_last) state.commands.push(join);
      }
    } else {
      state.commands.push(separator);
    }
    prev = node;
  }
  state.commands.push(close2);
  const multiline = child_state.multiline || measure(state.commands, index) > 50;
  if (multiline) {
    state.multiline = true;
    open2.push(indent, newline);
    join.push(newline);
    close2.push(dedent, newline);
  } else {
    if (spaces) open2.push(" ");
    join.push(" ");
    if (spaces) close2.push(" ");
  }
}
function handle_type_annotation(node, state) {
  switch (node.type) {
    case "TSNumberKeyword":
      state.commands.push("number");
      break;
    case "TSStringKeyword":
      state.commands.push("string");
      break;
    case "TSBooleanKeyword":
      state.commands.push("boolean");
      break;
    case "TSAnyKeyword":
      state.commands.push("any");
      break;
    case "TSVoidKeyword":
      state.commands.push("void");
      break;
    case "TSUnknownKeyword":
      state.commands.push("unknown");
      break;
    case "TSNeverKeyword":
      state.commands.push("never");
      break;
    case "TSArrayType":
      handle_type_annotation(node.elementType, state);
      state.commands.push("[]");
      break;
    case "TSTypeAnnotation":
      state.commands.push(": ");
      handle_type_annotation(node.typeAnnotation, state);
      break;
    case "TSTypeLiteral":
      state.commands.push("{ ");
      sequence2(node.members, state, false, handle_type_annotation, ";");
      state.commands.push(" }");
      break;
    case "TSPropertySignature":
      handle(node.key, state);
      if (node.optional) state.commands.push("?");
      if (node.typeAnnotation) handle_type_annotation(node.typeAnnotation, state);
      break;
    case "TSTypeReference":
      handle(node.typeName, state);
      if (node.typeArguments) {
        handle_type_annotation(node.typeArguments, state);
      }
      break;
    case "TSTypeParameterInstantiation":
    case "TSTypeParameterDeclaration":
      state.commands.push("<");
      for (let i = 0; i < node.params.length; i++) {
        handle_type_annotation(node.params[i], state);
        if (i != node.params.length - 1) state.commands.push(", ");
      }
      state.commands.push(">");
      break;
    case "TSTypeParameter":
      state.commands.push(node.name);
      if (node.constraint) {
        state.commands.push(" extends ");
        handle_type_annotation(node.constraint, state);
      }
      break;
    case "TSTypeQuery":
      state.commands.push("typeof ");
      handle(node.exprName, state);
      break;
    case "TSEnumMember":
      handle(node.id, state);
      if (node.initializer) {
        state.commands.push(" = ");
        handle(node.initializer, state);
      }
      break;
    case "TSFunctionType":
      if (node.typeParameters) handle_type_annotation(node.typeParameters, state);
      const parameters = node.parameters;
      state.commands.push("(");
      sequence2(parameters, state, false, handle);
      state.commands.push(") => ");
      handle_type_annotation(node.typeAnnotation.typeAnnotation, state);
      break;
    case "TSIndexSignature":
      const indexParameters = node.parameters;
      state.commands.push("[");
      sequence2(indexParameters, state, false, handle);
      state.commands.push("]");
      handle_type_annotation(node.typeAnnotation, state);
      break;
    case "TSMethodSignature":
      handle(node.key, state);
      const parametersSignature = node.parameters;
      state.commands.push("(");
      sequence2(parametersSignature, state, false, handle);
      state.commands.push(")");
      handle_type_annotation(node.typeAnnotation, state);
      break;
    case "TSExpressionWithTypeArguments":
      handle(node.expression, state);
      break;
    case "TSTupleType":
      state.commands.push("[");
      sequence2(node.elementTypes, state, false, handle_type_annotation);
      state.commands.push("]");
      break;
    case "TSNamedTupleMember":
      handle(node.label, state);
      state.commands.push(": ");
      handle_type_annotation(node.elementType, state);
      break;
    case "TSUnionType":
      sequence2(node.types, state, false, handle_type_annotation, " |");
      break;
    case "TSIntersectionType":
      sequence2(node.types, state, false, handle_type_annotation, " &");
      break;
    case "TSLiteralType":
      handle(node.literal, state);
      break;
    case "TSConditionalType":
      handle_type_annotation(node.checkType, state);
      state.commands.push(" extends ");
      handle_type_annotation(node.extendsType, state);
      state.commands.push(" ? ");
      handle_type_annotation(node.trueType, state);
      state.commands.push(" : ");
      handle_type_annotation(node.falseType, state);
      break;
    case "TSIndexedAccessType":
      handle_type_annotation(node.objectType, state);
      state.commands.push("[");
      handle_type_annotation(node.indexType, state);
      state.commands.push("]");
      break;
    case "TSImportType":
      state.commands.push("import(");
      handle(node.argument, state);
      state.commands.push(")");
      if (node.qualifier) {
        state.commands.push(".");
        handle(node.qualifier, state);
      }
      break;
    default:
      throw new Error(`Not implemented type annotation ${node.type}`);
  }
}
var shared = {
  /**
   * @param {TSESTree.ArrayExpression | TSESTree.ArrayPattern} node
   * @param {State} state
   */
  "ArrayExpression|ArrayPattern": (node, state) => {
    state.commands.push("[");
    sequence2(
      /** @type {TSESTree.Node[]} */
      node.elements,
      state,
      false,
      handle
    );
    state.commands.push("]");
  },
  /**
   * @param {TSESTree.BinaryExpression | TSESTree.LogicalExpression} node
   * @param {State} state
   */
  "BinaryExpression|LogicalExpression": (node, state) => {
    if (needs_parens(node.left, node, false)) {
      state.commands.push("(");
      handle(node.left, state);
      state.commands.push(")");
    } else {
      handle(node.left, state);
    }
    state.commands.push(` ${node.operator} `);
    if (needs_parens(node.right, node, true)) {
      state.commands.push("(");
      handle(node.right, state);
      state.commands.push(")");
    } else {
      handle(node.right, state);
    }
  },
  /**
   * @param {TSESTree.BlockStatement | TSESTree.ClassBody} node
   * @param {State} state
   */
  "BlockStatement|ClassBody": (node, state) => {
    if (node.loc) {
      const { line, column } = node.loc.start;
      state.commands.push(l(line, column), "{", l(line, column + 1));
    } else {
      state.commands.push("{");
    }
    if (node.body.length > 0) {
      state.multiline = true;
      state.commands.push(indent, newline);
      handle_body(node.body, state);
      state.commands.push(dedent, newline);
    }
    if (node.loc) {
      const { line, column } = node.loc.end;
      state.commands.push(l(line, column - 1), "}", l(line, column));
    } else {
      state.commands.push("}");
    }
  },
  /**
   * @param {TSESTree.CallExpression | TSESTree.NewExpression} node
   * @param {State} state
   */
  "CallExpression|NewExpression": (node, state) => {
    if (node.type === "NewExpression") {
      state.commands.push("new ");
    }
    const needs_parens2 = EXPRESSIONS_PRECEDENCE[node.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression || node.type === "NewExpression" && has_call_expression(node.callee);
    if (needs_parens2) {
      state.commands.push("(");
      handle(node.callee, state);
      state.commands.push(")");
    } else {
      handle(node.callee, state);
    }
    if (
      /** @type {TSESTree.CallExpression} */
      node.optional
    ) {
      state.commands.push("?.");
    }
    if (node.typeArguments) handle_type_annotation(node.typeArguments, state);
    const open2 = create_sequence();
    const join = create_sequence();
    const close2 = create_sequence();
    state.commands.push("(", open2);
    const child_state = { ...state, multiline: false };
    const final_state = { ...state, multiline: false };
    for (let i = 0; i < node.arguments.length; i += 1) {
      if (i > 0) {
        if (state.comments.length > 0) {
          state.commands.push(", ");
          while (state.comments.length) {
            const comment = (
              /** @type {TSESTree.Comment} */
              state.comments.shift()
            );
            state.commands.push({ type: "Comment", comment });
            if (comment.type === "Line") {
              child_state.multiline = true;
              state.commands.push(newline);
            } else {
              state.commands.push(" ");
            }
          }
        } else {
          state.commands.push(join);
        }
      }
      const p = node.arguments[i];
      handle(p, i === node.arguments.length - 1 ? final_state : child_state);
    }
    state.commands.push(close2, ")");
    const multiline = child_state.multiline;
    if (multiline || final_state.multiline) {
      state.multiline = true;
    }
    if (multiline) {
      open2.push(indent, newline);
      join.push(",", newline);
      close2.push(dedent, newline);
    } else {
      join.push(", ");
    }
  },
  /**
   * @param {TSESTree.ClassDeclaration | TSESTree.ClassExpression} node
   * @param {State} state
   */
  "ClassDeclaration|ClassExpression": (node, state) => {
    state.commands.push("class ");
    if (node.id) {
      handle(node.id, state);
      state.commands.push(" ");
    }
    if (node.superClass) {
      state.commands.push("extends ");
      handle(node.superClass, state);
      state.commands.push(" ");
    }
    if (node.implements) {
      state.commands.push("implements ");
      sequence2(node.implements, state, false, handle_type_annotation);
    }
    handle(node.body, state);
  },
  /**
   * @param {TSESTree.ForInStatement | TSESTree.ForOfStatement} node
   * @param {State} state
   */
  "ForInStatement|ForOfStatement": (node, state) => {
    state.commands.push("for ");
    if (node.type === "ForOfStatement" && node.await) state.commands.push("await ");
    state.commands.push("(");
    if (node.left.type === "VariableDeclaration") {
      handle_var_declaration(node.left, state);
    } else {
      handle(node.left, state);
    }
    state.commands.push(node.type === "ForInStatement" ? ` in ` : ` of `);
    handle(node.right, state);
    state.commands.push(") ");
    handle(node.body, state);
  },
  /**
   * @param {TSESTree.FunctionDeclaration | TSESTree.FunctionExpression} node
   * @param {State} state
   */
  "FunctionDeclaration|FunctionExpression": (node, state) => {
    if (node.async) state.commands.push("async ");
    state.commands.push(node.generator ? "function* " : "function ");
    if (node.id) handle(node.id, state);
    if (node.typeParameters) {
      handle_type_annotation(node.typeParameters, state);
    }
    state.commands.push("(");
    sequence2(node.params, state, false, handle);
    state.commands.push(")");
    if (node.returnType) handle_type_annotation(node.returnType, state);
    state.commands.push(" ");
    handle(node.body, state);
  },
  /**
   * @param {TSESTree.RestElement | TSESTree.SpreadElement} node
   * @param {State} state
   */
  "RestElement|SpreadElement": (node, state) => {
    state.commands.push("...");
    handle(node.argument, state);
    if (node.typeAnnotation) handle_type_annotation(node.typeAnnotation, state);
  }
};
var handlers = {
  ArrayExpression: shared["ArrayExpression|ArrayPattern"],
  ArrayPattern: shared["ArrayExpression|ArrayPattern"],
  ArrowFunctionExpression: (node, state) => {
    if (node.async) state.commands.push("async ");
    state.commands.push("(");
    sequence2(node.params, state, false, handle);
    state.commands.push(") => ");
    if (node.body.type === "ObjectExpression" || node.body.type === "AssignmentExpression" && node.body.left.type === "ObjectPattern" || node.body.type === "LogicalExpression" && node.body.left.type === "ObjectExpression" || node.body.type === "ConditionalExpression" && node.body.test.type === "ObjectExpression") {
      state.commands.push("(");
      handle(node.body, state);
      state.commands.push(")");
    } else {
      handle(node.body, state);
    }
  },
  AssignmentExpression(node, state) {
    handle(node.left, state);
    state.commands.push(` ${node.operator} `);
    handle(node.right, state);
  },
  AssignmentPattern(node, state) {
    handle(node.left, state);
    state.commands.push(" = ");
    handle(node.right, state);
  },
  AwaitExpression(node, state) {
    if (node.argument) {
      const precedence = EXPRESSIONS_PRECEDENCE[node.argument.type];
      if (precedence && precedence < EXPRESSIONS_PRECEDENCE.AwaitExpression) {
        state.commands.push("await (");
        handle(node.argument, state);
        state.commands.push(")");
      } else {
        state.commands.push("await ");
        handle(node.argument, state);
      }
    } else {
      state.commands.push("await");
    }
  },
  BinaryExpression: shared["BinaryExpression|LogicalExpression"],
  BlockStatement: shared["BlockStatement|ClassBody"],
  BreakStatement(node, state) {
    if (node.label) {
      state.commands.push("break ");
      handle(node.label, state);
      state.commands.push(";");
    } else {
      state.commands.push("break;");
    }
  },
  CallExpression: shared["CallExpression|NewExpression"],
  ChainExpression(node, state) {
    handle(node.expression, state);
  },
  ClassBody: shared["BlockStatement|ClassBody"],
  ClassDeclaration: shared["ClassDeclaration|ClassExpression"],
  ClassExpression: shared["ClassDeclaration|ClassExpression"],
  ConditionalExpression(node, state) {
    if (EXPRESSIONS_PRECEDENCE[node.test.type] > EXPRESSIONS_PRECEDENCE.ConditionalExpression) {
      handle(node.test, state);
    } else {
      state.commands.push("(");
      handle(node.test, state);
      state.commands.push(")");
    }
    const if_true = create_sequence();
    const if_false = create_sequence();
    const child_state = { ...state, multiline: false };
    state.commands.push(if_true);
    handle(node.consequent, child_state);
    state.commands.push(if_false);
    handle(node.alternate, child_state);
    const multiline = child_state.multiline;
    if (multiline) {
      if_true.push(indent, newline, "? ");
      if_false.push(newline, ": ");
      state.commands.push(dedent);
    } else {
      if_true.push(" ? ");
      if_false.push(" : ");
    }
  },
  ContinueStatement(node, state) {
    if (node.label) {
      state.commands.push("continue ");
      handle(node.label, state);
      state.commands.push(";");
    } else {
      state.commands.push("continue;");
    }
  },
  DebuggerStatement(node, state) {
    state.commands.push(c("debugger", node), ";");
  },
  Decorator(node, state) {
    state.commands.push("@");
    handle(node.expression, state);
    state.commands.push(newline);
  },
  DoWhileStatement(node, state) {
    state.commands.push("do ");
    handle(node.body, state);
    state.commands.push(" while (");
    handle(node.test, state);
    state.commands.push(");");
  },
  EmptyStatement(node, state) {
    state.commands.push(";");
  },
  ExportAllDeclaration(node, state) {
    state.commands.push("export * ");
    if (node.exported) {
      state.commands.push("as ");
      handle(node.exported, state);
    }
    state.commands.push(" from ");
    handle(node.source, state);
    state.commands.push(";");
  },
  ExportDefaultDeclaration(node, state) {
    state.commands.push("export default ");
    handle(node.declaration, state);
    if (node.declaration.type !== "FunctionDeclaration") {
      state.commands.push(";");
    }
  },
  ExportNamedDeclaration(node, state) {
    state.commands.push("export ");
    if (node.declaration) {
      handle(node.declaration, state);
      return;
    }
    state.commands.push("{");
    sequence2(node.specifiers, state, true, (s, state2) => {
      handle(s.local, state2);
      if (s.local.name !== s.exported.name) {
        state2.commands.push(" as ");
        handle(s.exported, state2);
      }
    });
    state.commands.push("}");
    if (node.source) {
      state.commands.push(" from ");
      handle(node.source, state);
    }
    state.commands.push(";");
  },
  ExpressionStatement(node, state) {
    if (node.expression.type === "ObjectExpression" || node.expression.type === "AssignmentExpression" && node.expression.left.type === "ObjectPattern" || node.expression.type === "FunctionExpression") {
      state.commands.push("(");
      handle(node.expression, state);
      state.commands.push(");");
      return;
    }
    handle(node.expression, state);
    state.commands.push(";");
  },
  ForStatement: (node, state) => {
    state.commands.push("for (");
    if (node.init) {
      if (node.init.type === "VariableDeclaration") {
        handle_var_declaration(node.init, state);
      } else {
        handle(node.init, state);
      }
    }
    state.commands.push("; ");
    if (node.test) handle(node.test, state);
    state.commands.push("; ");
    if (node.update) handle(node.update, state);
    state.commands.push(") ");
    handle(node.body, state);
  },
  ForInStatement: shared["ForInStatement|ForOfStatement"],
  ForOfStatement: shared["ForInStatement|ForOfStatement"],
  FunctionDeclaration: shared["FunctionDeclaration|FunctionExpression"],
  FunctionExpression: shared["FunctionDeclaration|FunctionExpression"],
  Identifier(node, state) {
    let name = node.name;
    state.commands.push(c(name, node));
    if (node.typeAnnotation) handle_type_annotation(node.typeAnnotation, state);
  },
  IfStatement(node, state) {
    state.commands.push("if (");
    handle(node.test, state);
    state.commands.push(") ");
    handle(node.consequent, state);
    if (node.alternate) {
      state.commands.push(" else ");
      handle(node.alternate, state);
    }
  },
  ImportDeclaration(node, state) {
    if (node.specifiers.length === 0) {
      state.commands.push("import ");
      handle(node.source, state);
      state.commands.push(";");
      return;
    }
    let namespace_specifier = null;
    let default_specifier = null;
    const named_specifiers = [];
    for (const s of node.specifiers) {
      if (s.type === "ImportNamespaceSpecifier") {
        namespace_specifier = s;
      } else if (s.type === "ImportDefaultSpecifier") {
        default_specifier = s;
      } else {
        named_specifiers.push(s);
      }
    }
    state.commands.push("import ");
    if (node.importKind == "type") state.commands.push("type ");
    if (default_specifier) {
      state.commands.push(c(default_specifier.local.name, default_specifier));
      if (namespace_specifier || named_specifiers.length > 0) state.commands.push(", ");
    }
    if (namespace_specifier) {
      state.commands.push(c("* as " + namespace_specifier.local.name, namespace_specifier));
    }
    if (named_specifiers.length > 0) {
      state.commands.push("{");
      sequence2(named_specifiers, state, true, (s, state2) => {
        if (s.local.name !== s.imported.name) {
          handle(s.imported, state2);
          state2.commands.push(" as ");
        }
        if (s.importKind == "type") state2.commands.push("type ");
        handle(s.local, state2);
      });
      state.commands.push("}");
    }
    state.commands.push(" from ");
    handle(node.source, state);
    state.commands.push(";");
  },
  ImportExpression(node, state) {
    state.commands.push("import(");
    handle(node.source, state);
    state.commands.push(")");
  },
  LabeledStatement(node, state) {
    handle(node.label, state);
    state.commands.push(": ");
    handle(node.body, state);
  },
  Literal(node, state) {
    const value = node.raw || (typeof node.value === "string" ? quote(node.value, state.quote) : String(node.value));
    state.commands.push(c(value, node));
  },
  LogicalExpression: shared["BinaryExpression|LogicalExpression"],
  MemberExpression(node, state) {
    if (EXPRESSIONS_PRECEDENCE[node.object.type] < EXPRESSIONS_PRECEDENCE.MemberExpression) {
      state.commands.push("(");
      handle(node.object, state);
      state.commands.push(")");
    } else {
      handle(node.object, state);
    }
    if (node.computed) {
      if (node.optional) {
        state.commands.push("?.");
      }
      state.commands.push("[");
      handle(node.property, state);
      state.commands.push("]");
    } else {
      state.commands.push(node.optional ? "?." : ".");
      handle(node.property, state);
    }
  },
  MetaProperty(node, state) {
    handle(node.meta, state);
    state.commands.push(".");
    handle(node.property, state);
  },
  MethodDefinition(node, state) {
    if (node.decorators) {
      for (const decorator of node.decorators) {
        handle(decorator, state);
      }
    }
    if (node.static) {
      state.commands.push("static ");
    }
    if (node.kind === "get" || node.kind === "set") {
      state.commands.push(node.kind + " ");
    }
    if (node.value.async) {
      state.commands.push("async ");
    }
    if (node.value.generator) {
      state.commands.push("*");
    }
    if (node.computed) state.commands.push("[");
    handle(node.key, state);
    if (node.computed) state.commands.push("]");
    state.commands.push("(");
    sequence2(node.value.params, state, false, handle);
    state.commands.push(") ");
    if (node.value.body) handle(node.value.body, state);
  },
  NewExpression: shared["CallExpression|NewExpression"],
  ObjectExpression(node, state) {
    state.commands.push("{");
    sequence2(node.properties, state, true, (p, state2) => {
      if (p.type === "Property" && p.value.type === "FunctionExpression") {
        const fn = (
          /** @type {TSESTree.FunctionExpression} */
          p.value
        );
        if (p.kind === "get" || p.kind === "set") {
          state2.commands.push(p.kind + " ");
        } else {
          if (fn.async) state2.commands.push("async ");
          if (fn.generator) state2.commands.push("*");
        }
        if (p.computed) state2.commands.push("[");
        handle(p.key, state2);
        if (p.computed) state2.commands.push("]");
        state2.commands.push("(");
        sequence2(fn.params, state2, false, handle);
        state2.commands.push(") ");
        handle(fn.body, state2);
      } else {
        handle(p, state2);
      }
    });
    state.commands.push("}");
  },
  ObjectPattern(node, state) {
    state.commands.push("{");
    sequence2(node.properties, state, true, handle);
    state.commands.push("}");
    if (node.typeAnnotation) handle_type_annotation(node.typeAnnotation, state);
  },
  // @ts-expect-error this isn't a real node type, but Acorn produces it
  ParenthesizedExpression(node, state) {
    return handle(node.expression, state);
  },
  PrivateIdentifier(node, state) {
    state.commands.push("#", c(node.name, node));
  },
  Program(node, state) {
    handle_body(node.body, state);
  },
  Property(node, state) {
    const value = node.value.type === "AssignmentPattern" ? node.value.left : node.value;
    const shorthand = !node.computed && node.kind === "init" && node.key.type === "Identifier" && value.type === "Identifier" && node.key.name === value.name;
    if (shorthand) {
      handle(node.value, state);
      return;
    }
    if (node.computed) state.commands.push("[");
    handle(node.key, state);
    state.commands.push(node.computed ? "]: " : ": ");
    handle(node.value, state);
  },
  PropertyDefinition(node, state) {
    if (node.accessibility) {
      state.commands.push(node.accessibility, " ");
    }
    if (node.static) {
      state.commands.push("static ");
    }
    if (node.computed) {
      state.commands.push("[");
      handle(node.key, state);
      state.commands.push("]");
    } else {
      handle(node.key, state);
    }
    if (node.typeAnnotation) {
      state.commands.push(": ");
      handle_type_annotation(node.typeAnnotation.typeAnnotation, state);
    }
    if (node.value) {
      state.commands.push(" = ");
      handle(node.value, state);
    }
    state.commands.push(";");
  },
  RestElement: shared["RestElement|SpreadElement"],
  ReturnStatement(node, state) {
    if (node.argument) {
      const argumentWithComment = (
        /** @type {NodeWithComments} */
        node.argument
      );
      const contains_comment = argumentWithComment.leadingComments && argumentWithComment.leadingComments.some((comment) => comment.type === "Line");
      state.commands.push(contains_comment ? "return (" : "return ");
      handle(node.argument, state);
      state.commands.push(contains_comment ? ");" : ";");
    } else {
      state.commands.push("return;");
    }
  },
  SequenceExpression(node, state) {
    state.commands.push("(");
    sequence2(node.expressions, state, false, handle);
    state.commands.push(")");
  },
  SpreadElement: shared["RestElement|SpreadElement"],
  StaticBlock(node, state) {
    state.commands.push(indent, "static {", newline);
    handle_body(node.body, state);
    state.commands.push(dedent, newline, "}");
  },
  Super(node, state) {
    state.commands.push(c("super", node));
  },
  SwitchStatement(node, state) {
    state.commands.push("switch (");
    handle(node.discriminant, state);
    state.commands.push(") {", indent);
    let first = true;
    for (const block2 of node.cases) {
      if (!first) state.commands.push("\n");
      first = false;
      if (block2.test) {
        state.commands.push(newline, `case `);
        handle(block2.test, state);
        state.commands.push(":");
      } else {
        state.commands.push(newline, `default:`);
      }
      state.commands.push(indent);
      for (const statement of block2.consequent) {
        state.commands.push(newline);
        handle(statement, state);
      }
      state.commands.push(dedent);
    }
    state.commands.push(dedent, newline, `}`);
  },
  TaggedTemplateExpression(node, state) {
    handle(node.tag, state);
    handle(node.quasi, state);
  },
  TemplateLiteral(node, state) {
    state.commands.push("`");
    const { quasis, expressions } = node;
    for (let i = 0; i < expressions.length; i++) {
      const raw2 = quasis[i].value.raw;
      state.commands.push(raw2, "${");
      handle(expressions[i], state);
      state.commands.push("}");
      if (/\n/.test(raw2)) state.multiline = true;
    }
    const raw = quasis[quasis.length - 1].value.raw;
    state.commands.push(raw, "`");
    if (/\n/.test(raw)) state.multiline = true;
  },
  ThisExpression(node, state) {
    state.commands.push(c("this", node));
  },
  ThrowStatement(node, state) {
    state.commands.push("throw ");
    if (node.argument) handle(node.argument, state);
    state.commands.push(";");
  },
  TryStatement(node, state) {
    state.commands.push("try ");
    handle(node.block, state);
    if (node.handler) {
      if (node.handler.param) {
        state.commands.push(" catch(");
        handle(node.handler.param, state);
        state.commands.push(") ");
      } else {
        state.commands.push(" catch ");
      }
      handle(node.handler.body, state);
    }
    if (node.finalizer) {
      state.commands.push(" finally ");
      handle(node.finalizer, state);
    }
  },
  TSAsExpression(node, state) {
    if (node.expression) {
      const needs_parens2 = EXPRESSIONS_PRECEDENCE[node.expression.type] < EXPRESSIONS_PRECEDENCE.TSAsExpression;
      if (needs_parens2) {
        state.commands.push("(");
        handle(node.expression, state);
        state.commands.push(")");
      } else {
        handle(node.expression, state);
      }
    }
    state.commands.push(" as ");
    handle_type_annotation(node.typeAnnotation, state);
  },
  TSEnumDeclaration(node, state) {
    state.commands.push("enum ");
    handle(node.id, state);
    state.commands.push(" {", indent, newline);
    sequence2(node.members, state, false, handle_type_annotation);
    state.commands.push(dedent, newline, "}", newline);
  },
  TSModuleBlock(node, state) {
    state.commands.push(" {", indent, newline);
    handle_body(node.body, state);
    state.commands.push(dedent, newline, "}");
  },
  TSModuleDeclaration(node, state) {
    if (node.declare) state.commands.push("declare ");
    else state.commands.push("namespace ");
    handle(node.id, state);
    if (!node.body) return;
    handle(node.body, state);
  },
  TSNonNullExpression(node, state) {
    handle(node.expression, state);
    state.commands.push("!");
  },
  TSInterfaceBody(node, state) {
    sequence2(node.body, state, true, handle_type_annotation, ";");
  },
  TSInterfaceDeclaration(node, state) {
    state.commands.push("interface ");
    handle(node.id, state);
    if (node.typeParameters) handle_type_annotation(node.typeParameters, state);
    if (node.extends) {
      state.commands.push(" extends ");
      sequence2(node.extends, state, false, handle_type_annotation);
    }
    state.commands.push(" {");
    handle(node.body, state);
    state.commands.push("}");
  },
  TSSatisfiesExpression(node, state) {
    if (node.expression) {
      const needs_parens2 = EXPRESSIONS_PRECEDENCE[node.expression.type] < EXPRESSIONS_PRECEDENCE.TSSatisfiesExpression;
      if (needs_parens2) {
        state.commands.push("(");
        handle(node.expression, state);
        state.commands.push(")");
      } else {
        handle(node.expression, state);
      }
    }
    state.commands.push(" satisfies ");
    handle_type_annotation(node.typeAnnotation, state);
  },
  TSTypeAliasDeclaration(node, state) {
    state.commands.push("type ");
    handle(node.id, state);
    if (node.typeParameters) handle_type_annotation(node.typeParameters, state);
    state.commands.push(" = ");
    handle_type_annotation(node.typeAnnotation, state);
    state.commands.push(";");
  },
  TSQualifiedName(node, state) {
    handle(node.left, state);
    state.commands.push(".");
    handle(node.right, state);
  },
  UnaryExpression(node, state) {
    state.commands.push(node.operator);
    if (node.operator.length > 1) {
      state.commands.push(" ");
    }
    if (EXPRESSIONS_PRECEDENCE[node.argument.type] < EXPRESSIONS_PRECEDENCE.UnaryExpression) {
      state.commands.push("(");
      handle(node.argument, state);
      state.commands.push(")");
    } else {
      handle(node.argument, state);
    }
  },
  UpdateExpression(node, state) {
    if (node.prefix) {
      state.commands.push(node.operator);
      handle(node.argument, state);
    } else {
      handle(node.argument, state);
      state.commands.push(node.operator);
    }
  },
  VariableDeclaration(node, state) {
    handle_var_declaration(node, state);
    state.commands.push(";");
  },
  VariableDeclarator(node, state) {
    handle(node.id, state);
    if (node.init) {
      state.commands.push(" = ");
      handle(node.init, state);
    }
  },
  WhileStatement(node, state) {
    state.commands.push("while (");
    handle(node.test, state);
    state.commands.push(") ");
    handle(node.body, state);
  },
  WithStatement(node, state) {
    state.commands.push("with (");
    handle(node.object, state);
    state.commands.push(") ");
    handle(node.body, state);
  },
  YieldExpression(node, state) {
    if (node.argument) {
      state.commands.push(node.delegate ? `yield* ` : `yield `);
      handle(node.argument, state);
    } else {
      state.commands.push(node.delegate ? `yield*` : `yield`);
    }
  }
};

// node_modules/esrap/src/index.js
var import_sourcemap_codec = __toESM(require_sourcemap_codec_umd());
var btoa2 = () => {
  throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
};
if (typeof window !== "undefined" && typeof window.btoa === "function") {
  btoa2 = (str) => window.btoa(unescape(encodeURIComponent(str)));
} else if (typeof Buffer === "function") {
  btoa2 = (str) => Buffer.from(str, "utf-8").toString("base64");
}
function print(node, opts = {}) {
  if (Array.isArray(node)) {
    return print(
      {
        type: "Program",
        body: node,
        sourceType: "module"
      },
      opts
    );
  }
  const state = {
    commands: [],
    comments: [],
    multiline: false,
    quote: opts.quotes === "double" ? '"' : "'"
  };
  handle(
    /** @type {TSESTree.Node} */
    node,
    state
  );
  let code = "";
  let current_column = 0;
  let mappings = [];
  let current_line = [];
  function append(str) {
    code += str;
    for (let i = 0; i < str.length; i += 1) {
      if (str[i] === "\n") {
        mappings.push(current_line);
        current_line = [];
        current_column = 0;
      } else {
        current_column += 1;
      }
    }
  }
  let newline2 = "\n";
  const indent2 = opts.indent ?? "	";
  function run(command) {
    if (typeof command === "string") {
      append(command);
      return;
    }
    if (Array.isArray(command)) {
      for (let i = 0; i < command.length; i += 1) {
        run(command[i]);
      }
      return;
    }
    switch (command.type) {
      case "Location":
        current_line.push([
          current_column,
          0,
          // source index is always zero
          command.line - 1,
          command.column
        ]);
        break;
      case "Newline":
        append(newline2);
        break;
      case "Indent":
        newline2 += indent2;
        break;
      case "Dedent":
        newline2 = newline2.slice(0, -indent2.length);
        break;
      case "Comment":
        if (command.comment.type === "Line") {
          append(`//${command.comment.value}`);
        } else {
          append(`/*${command.comment.value.replace(/\n/g, newline2)}*/`);
        }
        break;
    }
  }
  for (let i = 0; i < state.commands.length; i += 1) {
    run(state.commands[i]);
  }
  mappings.push(current_line);
  const map = {
    version: 3,
    /** @type {string[]} */
    names: [],
    sources: [opts.sourceMapSource || null],
    sourcesContent: [opts.sourceMapContent || null],
    mappings: opts.sourceMapEncodeMappings == void 0 || opts.sourceMapEncodeMappings ? (0, import_sourcemap_codec.encode)(mappings) : mappings
  };
  Object.defineProperties(map, {
    toString: {
      enumerable: false,
      value: function toString3() {
        return JSON.stringify(this);
      }
    },
    toUrl: {
      enumerable: false,
      value: function toUrl() {
        return "data:application/json;charset=utf-8;base64," + btoa2(this.toString());
      }
    }
  });
  return {
    code,
    map
  };
}

// node_modules/magic-string/dist/magic-string.es.mjs
var import_sourcemap_codec2 = __toESM(require_sourcemap_codec_umd(), 1);
var BitSet = class _BitSet {
  constructor(arg) {
    this.bits = arg instanceof _BitSet ? arg.bits.slice() : [];
  }
  add(n2) {
    this.bits[n2 >> 5] |= 1 << (n2 & 31);
  }
  has(n2) {
    return !!(this.bits[n2 >> 5] & 1 << (n2 & 31));
  }
};
var Chunk = class _Chunk {
  constructor(start, end, content) {
    this.start = start;
    this.end = end;
    this.original = content;
    this.intro = "";
    this.outro = "";
    this.content = content;
    this.storeName = false;
    this.edited = false;
    {
      this.previous = null;
      this.next = null;
    }
  }
  appendLeft(content) {
    this.outro += content;
  }
  appendRight(content) {
    this.intro = this.intro + content;
  }
  clone() {
    const chunk = new _Chunk(this.start, this.end, this.original);
    chunk.intro = this.intro;
    chunk.outro = this.outro;
    chunk.content = this.content;
    chunk.storeName = this.storeName;
    chunk.edited = this.edited;
    return chunk;
  }
  contains(index) {
    return this.start < index && index < this.end;
  }
  eachNext(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.next;
    }
  }
  eachPrevious(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.previous;
    }
  }
  edit(content, storeName, contentOnly) {
    this.content = content;
    if (!contentOnly) {
      this.intro = "";
      this.outro = "";
    }
    this.storeName = storeName;
    this.edited = true;
    return this;
  }
  prependLeft(content) {
    this.outro = content + this.outro;
  }
  prependRight(content) {
    this.intro = content + this.intro;
  }
  reset() {
    this.intro = "";
    this.outro = "";
    if (this.edited) {
      this.content = this.original;
      this.storeName = false;
      this.edited = false;
    }
  }
  split(index) {
    const sliceIndex = index - this.start;
    const originalBefore = this.original.slice(0, sliceIndex);
    const originalAfter = this.original.slice(sliceIndex);
    this.original = originalBefore;
    const newChunk = new _Chunk(index, this.end, originalAfter);
    newChunk.outro = this.outro;
    this.outro = "";
    this.end = index;
    if (this.edited) {
      newChunk.edit("", false);
      this.content = "";
    } else {
      this.content = originalBefore;
    }
    newChunk.next = this.next;
    if (newChunk.next) newChunk.next.previous = newChunk;
    newChunk.previous = this;
    this.next = newChunk;
    return newChunk;
  }
  toString() {
    return this.intro + this.content + this.outro;
  }
  trimEnd(rx) {
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length) return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        this.split(this.start + trimmed.length).edit("", void 0, true);
        if (this.edited) {
          this.edit(trimmed, this.storeName, true);
        }
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.intro = this.intro.replace(rx, "");
      if (this.intro.length) return true;
    }
  }
  trimStart(rx) {
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length) return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        const newChunk = this.split(this.end - trimmed.length);
        if (this.edited) {
          newChunk.edit(trimmed, this.storeName, true);
        }
        this.edit("", void 0, true);
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.outro = this.outro.replace(rx, "");
      if (this.outro.length) return true;
    }
  }
};
function getBtoa() {
  if (typeof globalThis !== "undefined" && typeof globalThis.btoa === "function") {
    return (str) => globalThis.btoa(unescape(encodeURIComponent(str)));
  } else if (typeof Buffer === "function") {
    return (str) => Buffer.from(str, "utf-8").toString("base64");
  } else {
    return () => {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
  }
}
var btoa3 = getBtoa();
var SourceMap = class {
  constructor(properties) {
    this.version = 3;
    this.file = properties.file;
    this.sources = properties.sources;
    this.sourcesContent = properties.sourcesContent;
    this.names = properties.names;
    this.mappings = (0, import_sourcemap_codec2.encode)(properties.mappings);
    if (typeof properties.x_google_ignoreList !== "undefined") {
      this.x_google_ignoreList = properties.x_google_ignoreList;
    }
    if (typeof properties.debugId !== "undefined") {
      this.debugId = properties.debugId;
    }
  }
  toString() {
    return JSON.stringify(this);
  }
  toUrl() {
    return "data:application/json;charset=utf-8;base64," + btoa3(this.toString());
  }
};
function guessIndent(code) {
  const lines = code.split("\n");
  const tabbed = lines.filter((line) => /^\t+/.test(line));
  const spaced = lines.filter((line) => /^ {2,}/.test(line));
  if (tabbed.length === 0 && spaced.length === 0) {
    return null;
  }
  if (tabbed.length >= spaced.length) {
    return "	";
  }
  const min = spaced.reduce((previous, current2) => {
    const numSpaces = /^ +/.exec(current2)[0].length;
    return Math.min(numSpaces, previous);
  }, Infinity);
  return new Array(min + 1).join(" ");
}
function getRelativePath(from, to) {
  const fromParts = from.split(/[/\\]/);
  const toParts = to.split(/[/\\]/);
  fromParts.pop();
  while (fromParts[0] === toParts[0]) {
    fromParts.shift();
    toParts.shift();
  }
  if (fromParts.length) {
    let i = fromParts.length;
    while (i--) fromParts[i] = "..";
  }
  return fromParts.concat(toParts).join("/");
}
var toString2 = Object.prototype.toString;
function isObject(thing) {
  return toString2.call(thing) === "[object Object]";
}
function getLocator2(source2) {
  const originalLines = source2.split("\n");
  const lineOffsets = [];
  for (let i = 0, pos = 0; i < originalLines.length; i++) {
    lineOffsets.push(pos);
    pos += originalLines[i].length + 1;
  }
  return function locate(index) {
    let i = 0;
    let j = lineOffsets.length;
    while (i < j) {
      const m = i + j >> 1;
      if (index < lineOffsets[m]) {
        j = m;
      } else {
        i = m + 1;
      }
    }
    const line = i - 1;
    const column = index - lineOffsets[line];
    return { line, column };
  };
}
var wordRegex = /\w/;
var Mappings = class {
  constructor(hires) {
    this.hires = hires;
    this.generatedCodeLine = 0;
    this.generatedCodeColumn = 0;
    this.raw = [];
    this.rawSegments = this.raw[this.generatedCodeLine] = [];
    this.pending = null;
  }
  addEdit(sourceIndex, content, loc, nameIndex) {
    if (content.length) {
      const contentLengthMinusOne = content.length - 1;
      let contentLineEnd = content.indexOf("\n", 0);
      let previousContentLineEnd = -1;
      while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {
        const segment2 = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
        if (nameIndex >= 0) {
          segment2.push(nameIndex);
        }
        this.rawSegments.push(segment2);
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        previousContentLineEnd = contentLineEnd;
        contentLineEnd = content.indexOf("\n", contentLineEnd + 1);
      }
      const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
      if (nameIndex >= 0) {
        segment.push(nameIndex);
      }
      this.rawSegments.push(segment);
      this.advance(content.slice(previousContentLineEnd + 1));
    } else if (this.pending) {
      this.rawSegments.push(this.pending);
      this.advance(content);
    }
    this.pending = null;
  }
  addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
    let originalCharIndex = chunk.start;
    let first = true;
    let charInHiresBoundary = false;
    while (originalCharIndex < chunk.end) {
      if (original[originalCharIndex] === "\n") {
        loc.line += 1;
        loc.column = 0;
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        first = true;
        charInHiresBoundary = false;
      } else {
        if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
          const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
          if (this.hires === "boundary") {
            if (wordRegex.test(original[originalCharIndex])) {
              if (!charInHiresBoundary) {
                this.rawSegments.push(segment);
                charInHiresBoundary = true;
              }
            } else {
              this.rawSegments.push(segment);
              charInHiresBoundary = false;
            }
          } else {
            this.rawSegments.push(segment);
          }
        }
        loc.column += 1;
        this.generatedCodeColumn += 1;
        first = false;
      }
      originalCharIndex += 1;
    }
    this.pending = null;
  }
  advance(str) {
    if (!str) return;
    const lines = str.split("\n");
    if (lines.length > 1) {
      for (let i = 0; i < lines.length - 1; i++) {
        this.generatedCodeLine++;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
      }
      this.generatedCodeColumn = 0;
    }
    this.generatedCodeColumn += lines[lines.length - 1].length;
  }
};
var n = "\n";
var warned = {
  insertLeft: false,
  insertRight: false,
  storeName: false
};
var MagicString = class _MagicString {
  constructor(string2, options = {}) {
    const chunk = new Chunk(0, string2.length, string2);
    Object.defineProperties(this, {
      original: { writable: true, value: string2 },
      outro: { writable: true, value: "" },
      intro: { writable: true, value: "" },
      firstChunk: { writable: true, value: chunk },
      lastChunk: { writable: true, value: chunk },
      lastSearchedChunk: { writable: true, value: chunk },
      byStart: { writable: true, value: {} },
      byEnd: { writable: true, value: {} },
      filename: { writable: true, value: options.filename },
      indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
      sourcemapLocations: { writable: true, value: new BitSet() },
      storedNames: { writable: true, value: {} },
      indentStr: { writable: true, value: void 0 },
      ignoreList: { writable: true, value: options.ignoreList },
      offset: { writable: true, value: options.offset || 0 }
    });
    this.byStart[0] = chunk;
    this.byEnd[string2.length] = chunk;
  }
  addSourcemapLocation(char) {
    this.sourcemapLocations.add(char);
  }
  append(content) {
    if (typeof content !== "string") throw new TypeError("outro content must be a string");
    this.outro += content;
    return this;
  }
  appendLeft(index, content) {
    index = index + this.offset;
    if (typeof content !== "string") throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.appendLeft(content);
    } else {
      this.intro += content;
    }
    return this;
  }
  appendRight(index, content) {
    index = index + this.offset;
    if (typeof content !== "string") throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.appendRight(content);
    } else {
      this.outro += content;
    }
    return this;
  }
  clone() {
    const cloned = new _MagicString(this.original, { filename: this.filename, offset: this.offset });
    let originalChunk = this.firstChunk;
    let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
    while (originalChunk) {
      cloned.byStart[clonedChunk.start] = clonedChunk;
      cloned.byEnd[clonedChunk.end] = clonedChunk;
      const nextOriginalChunk = originalChunk.next;
      const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
      if (nextClonedChunk) {
        clonedChunk.next = nextClonedChunk;
        nextClonedChunk.previous = clonedChunk;
        clonedChunk = nextClonedChunk;
      }
      originalChunk = nextOriginalChunk;
    }
    cloned.lastChunk = clonedChunk;
    if (this.indentExclusionRanges) {
      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
    }
    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
    cloned.intro = this.intro;
    cloned.outro = this.outro;
    return cloned;
  }
  generateDecodedMap(options) {
    options = options || {};
    const sourceIndex = 0;
    const names = Object.keys(this.storedNames);
    const mappings = new Mappings(options.hires);
    const locate = getLocator2(this.original);
    if (this.intro) {
      mappings.advance(this.intro);
    }
    this.firstChunk.eachNext((chunk) => {
      const loc = locate(chunk.start);
      if (chunk.intro.length) mappings.advance(chunk.intro);
      if (chunk.edited) {
        mappings.addEdit(
          sourceIndex,
          chunk.content,
          loc,
          chunk.storeName ? names.indexOf(chunk.original) : -1
        );
      } else {
        mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
      }
      if (chunk.outro.length) mappings.advance(chunk.outro);
    });
    return {
      file: options.file ? options.file.split(/[/\\]/).pop() : void 0,
      sources: [
        options.source ? getRelativePath(options.file || "", options.source) : options.file || ""
      ],
      sourcesContent: options.includeContent ? [this.original] : void 0,
      names,
      mappings: mappings.raw,
      x_google_ignoreList: this.ignoreList ? [sourceIndex] : void 0
    };
  }
  generateMap(options) {
    return new SourceMap(this.generateDecodedMap(options));
  }
  _ensureindentStr() {
    if (this.indentStr === void 0) {
      this.indentStr = guessIndent(this.original);
    }
  }
  _getRawIndentString() {
    this._ensureindentStr();
    return this.indentStr;
  }
  getIndentString() {
    this._ensureindentStr();
    return this.indentStr === null ? "	" : this.indentStr;
  }
  indent(indentStr, options) {
    const pattern = /^[^\r\n]/gm;
    if (isObject(indentStr)) {
      options = indentStr;
      indentStr = void 0;
    }
    if (indentStr === void 0) {
      this._ensureindentStr();
      indentStr = this.indentStr || "	";
    }
    if (indentStr === "") return this;
    options = options || {};
    const isExcluded = {};
    if (options.exclude) {
      const exclusions = typeof options.exclude[0] === "number" ? [options.exclude] : options.exclude;
      exclusions.forEach((exclusion) => {
        for (let i = exclusion[0]; i < exclusion[1]; i += 1) {
          isExcluded[i] = true;
        }
      });
    }
    let shouldIndentNextCharacter = options.indentStart !== false;
    const replacer = (match) => {
      if (shouldIndentNextCharacter) return `${indentStr}${match}`;
      shouldIndentNextCharacter = true;
      return match;
    };
    this.intro = this.intro.replace(pattern, replacer);
    let charIndex = 0;
    let chunk = this.firstChunk;
    while (chunk) {
      const end = chunk.end;
      if (chunk.edited) {
        if (!isExcluded[charIndex]) {
          chunk.content = chunk.content.replace(pattern, replacer);
          if (chunk.content.length) {
            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
          }
        }
      } else {
        charIndex = chunk.start;
        while (charIndex < end) {
          if (!isExcluded[charIndex]) {
            const char = this.original[charIndex];
            if (char === "\n") {
              shouldIndentNextCharacter = true;
            } else if (char !== "\r" && shouldIndentNextCharacter) {
              shouldIndentNextCharacter = false;
              if (charIndex === chunk.start) {
                chunk.prependRight(indentStr);
              } else {
                this._splitChunk(chunk, charIndex);
                chunk = chunk.next;
                chunk.prependRight(indentStr);
              }
            }
          }
          charIndex += 1;
        }
      }
      charIndex = chunk.end;
      chunk = chunk.next;
    }
    this.outro = this.outro.replace(pattern, replacer);
    return this;
  }
  insert() {
    throw new Error(
      "magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)"
    );
  }
  insertLeft(index, content) {
    if (!warned.insertLeft) {
      console.warn(
        "magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"
      );
      warned.insertLeft = true;
    }
    return this.appendLeft(index, content);
  }
  insertRight(index, content) {
    if (!warned.insertRight) {
      console.warn(
        "magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"
      );
      warned.insertRight = true;
    }
    return this.prependRight(index, content);
  }
  move(start, end, index) {
    start = start + this.offset;
    end = end + this.offset;
    index = index + this.offset;
    if (index >= start && index <= end) throw new Error("Cannot move a selection inside itself");
    this._split(start);
    this._split(end);
    this._split(index);
    const first = this.byStart[start];
    const last = this.byEnd[end];
    const oldLeft = first.previous;
    const oldRight = last.next;
    const newRight = this.byStart[index];
    if (!newRight && last === this.lastChunk) return this;
    const newLeft = newRight ? newRight.previous : this.lastChunk;
    if (oldLeft) oldLeft.next = oldRight;
    if (oldRight) oldRight.previous = oldLeft;
    if (newLeft) newLeft.next = first;
    if (newRight) newRight.previous = last;
    if (!first.previous) this.firstChunk = last.next;
    if (!last.next) {
      this.lastChunk = first.previous;
      this.lastChunk.next = null;
    }
    first.previous = newLeft;
    last.next = newRight || null;
    if (!newLeft) this.firstChunk = first;
    if (!newRight) this.lastChunk = last;
    return this;
  }
  overwrite(start, end, content, options) {
    options = options || {};
    return this.update(start, end, content, { ...options, overwrite: !options.contentOnly });
  }
  update(start, end, content, options) {
    start = start + this.offset;
    end = end + this.offset;
    if (typeof content !== "string") throw new TypeError("replacement content must be a string");
    if (this.original.length !== 0) {
      while (start < 0) start += this.original.length;
      while (end < 0) end += this.original.length;
    }
    if (end > this.original.length) throw new Error("end is out of bounds");
    if (start === end)
      throw new Error(
        "Cannot overwrite a zero-length range – use appendLeft or prependRight instead"
      );
    this._split(start);
    this._split(end);
    if (options === true) {
      if (!warned.storeName) {
        console.warn(
          "The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"
        );
        warned.storeName = true;
      }
      options = { storeName: true };
    }
    const storeName = options !== void 0 ? options.storeName : false;
    const overwrite = options !== void 0 ? options.overwrite : false;
    if (storeName) {
      const original = this.original.slice(start, end);
      Object.defineProperty(this.storedNames, original, {
        writable: true,
        value: true,
        enumerable: true
      });
    }
    const first = this.byStart[start];
    const last = this.byEnd[end];
    if (first) {
      let chunk = first;
      while (chunk !== last) {
        if (chunk.next !== this.byStart[chunk.end]) {
          throw new Error("Cannot overwrite across a split point");
        }
        chunk = chunk.next;
        chunk.edit("", false);
      }
      first.edit(content, storeName, !overwrite);
    } else {
      const newChunk = new Chunk(start, end, "").edit(content, storeName);
      last.next = newChunk;
      newChunk.previous = last;
    }
    return this;
  }
  prepend(content) {
    if (typeof content !== "string") throw new TypeError("outro content must be a string");
    this.intro = content + this.intro;
    return this;
  }
  prependLeft(index, content) {
    index = index + this.offset;
    if (typeof content !== "string") throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.prependLeft(content);
    } else {
      this.intro = content + this.intro;
    }
    return this;
  }
  prependRight(index, content) {
    index = index + this.offset;
    if (typeof content !== "string") throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.prependRight(content);
    } else {
      this.outro = content + this.outro;
    }
    return this;
  }
  remove(start, end) {
    start = start + this.offset;
    end = end + this.offset;
    if (this.original.length !== 0) {
      while (start < 0) start += this.original.length;
      while (end < 0) end += this.original.length;
    }
    if (start === end) return this;
    if (start < 0 || end > this.original.length) throw new Error("Character is out of bounds");
    if (start > end) throw new Error("end must be greater than start");
    this._split(start);
    this._split(end);
    let chunk = this.byStart[start];
    while (chunk) {
      chunk.intro = "";
      chunk.outro = "";
      chunk.edit("");
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  }
  reset(start, end) {
    start = start + this.offset;
    end = end + this.offset;
    if (this.original.length !== 0) {
      while (start < 0) start += this.original.length;
      while (end < 0) end += this.original.length;
    }
    if (start === end) return this;
    if (start < 0 || end > this.original.length) throw new Error("Character is out of bounds");
    if (start > end) throw new Error("end must be greater than start");
    this._split(start);
    this._split(end);
    let chunk = this.byStart[start];
    while (chunk) {
      chunk.reset();
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  }
  lastChar() {
    if (this.outro.length) return this.outro[this.outro.length - 1];
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
      if (chunk.content.length) return chunk.content[chunk.content.length - 1];
      if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
    } while (chunk = chunk.previous);
    if (this.intro.length) return this.intro[this.intro.length - 1];
    return "";
  }
  lastLine() {
    let lineIndex = this.outro.lastIndexOf(n);
    if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
    let lineStr = this.outro;
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length > 0) {
        lineIndex = chunk.outro.lastIndexOf(n);
        if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.outro + lineStr;
      }
      if (chunk.content.length > 0) {
        lineIndex = chunk.content.lastIndexOf(n);
        if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.content + lineStr;
      }
      if (chunk.intro.length > 0) {
        lineIndex = chunk.intro.lastIndexOf(n);
        if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.intro + lineStr;
      }
    } while (chunk = chunk.previous);
    lineIndex = this.intro.lastIndexOf(n);
    if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
    return this.intro + lineStr;
  }
  slice(start = 0, end = this.original.length - this.offset) {
    start = start + this.offset;
    end = end + this.offset;
    if (this.original.length !== 0) {
      while (start < 0) start += this.original.length;
      while (end < 0) end += this.original.length;
    }
    let result = "";
    let chunk = this.firstChunk;
    while (chunk && (chunk.start > start || chunk.end <= start)) {
      if (chunk.start < end && chunk.end >= end) {
        return result;
      }
      chunk = chunk.next;
    }
    if (chunk && chunk.edited && chunk.start !== start)
      throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
    const startChunk = chunk;
    while (chunk) {
      if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
        result += chunk.intro;
      }
      const containsEnd = chunk.start < end && chunk.end >= end;
      if (containsEnd && chunk.edited && chunk.end !== end)
        throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
      const sliceStart = startChunk === chunk ? start - chunk.start : 0;
      const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
      result += chunk.content.slice(sliceStart, sliceEnd);
      if (chunk.outro && (!containsEnd || chunk.end === end)) {
        result += chunk.outro;
      }
      if (containsEnd) {
        break;
      }
      chunk = chunk.next;
    }
    return result;
  }
  // TODO deprecate this? not really very useful
  snip(start, end) {
    const clone = this.clone();
    clone.remove(0, start);
    clone.remove(end, clone.original.length);
    return clone;
  }
  _split(index) {
    if (this.byStart[index] || this.byEnd[index]) return;
    let chunk = this.lastSearchedChunk;
    const searchForward = index > chunk.end;
    while (chunk) {
      if (chunk.contains(index)) return this._splitChunk(chunk, index);
      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
    }
  }
  _splitChunk(chunk, index) {
    if (chunk.edited && chunk.content.length) {
      const loc = getLocator2(this.original)(index);
      throw new Error(
        `Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – "${chunk.original}")`
      );
    }
    const newChunk = chunk.split(index);
    this.byEnd[index] = chunk;
    this.byStart[index] = newChunk;
    this.byEnd[newChunk.end] = newChunk;
    if (chunk === this.lastChunk) this.lastChunk = newChunk;
    this.lastSearchedChunk = chunk;
    return true;
  }
  toString() {
    let str = this.intro;
    let chunk = this.firstChunk;
    while (chunk) {
      str += chunk.toString();
      chunk = chunk.next;
    }
    return str + this.outro;
  }
  isEmpty() {
    let chunk = this.firstChunk;
    do {
      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim())
        return false;
    } while (chunk = chunk.next);
    return true;
  }
  length() {
    let chunk = this.firstChunk;
    let length = 0;
    do {
      length += chunk.intro.length + chunk.content.length + chunk.outro.length;
    } while (chunk = chunk.next);
    return length;
  }
  trimLines() {
    return this.trim("[\\r\\n]");
  }
  trim(charType) {
    return this.trimStart(charType).trimEnd(charType);
  }
  trimEndAborted(charType) {
    const rx = new RegExp((charType || "\\s") + "+$");
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length) return true;
    let chunk = this.lastChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimEnd(rx);
      if (chunk.end !== end) {
        if (this.lastChunk === chunk) {
          this.lastChunk = chunk.next;
        }
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted) return true;
      chunk = chunk.previous;
    } while (chunk);
    return false;
  }
  trimEnd(charType) {
    this.trimEndAborted(charType);
    return this;
  }
  trimStartAborted(charType) {
    const rx = new RegExp("^" + (charType || "\\s") + "+");
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length) return true;
    let chunk = this.firstChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimStart(rx);
      if (chunk.end !== end) {
        if (chunk === this.lastChunk) this.lastChunk = chunk.next;
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted) return true;
      chunk = chunk.next;
    } while (chunk);
    return false;
  }
  trimStart(charType) {
    this.trimStartAborted(charType);
    return this;
  }
  hasChanged() {
    return this.original !== this.toString();
  }
  _replaceRegexp(searchValue, replacement) {
    function getReplacement(match, str) {
      if (typeof replacement === "string") {
        return replacement.replace(/\$(\$|&|\d+)/g, (_, i) => {
          if (i === "$") return "$";
          if (i === "&") return match[0];
          const num = +i;
          if (num < match.length) return match[+i];
          return `$${i}`;
        });
      } else {
        return replacement(...match, match.index, str, match.groups);
      }
    }
    function matchAll(re, str) {
      let match;
      const matches = [];
      while (match = re.exec(str)) {
        matches.push(match);
      }
      return matches;
    }
    if (searchValue.global) {
      const matches = matchAll(searchValue, this.original);
      matches.forEach((match) => {
        if (match.index != null) {
          const replacement2 = getReplacement(match, this.original);
          if (replacement2 !== match[0]) {
            this.overwrite(match.index, match.index + match[0].length, replacement2);
          }
        }
      });
    } else {
      const match = this.original.match(searchValue);
      if (match && match.index != null) {
        const replacement2 = getReplacement(match, this.original);
        if (replacement2 !== match[0]) {
          this.overwrite(match.index, match.index + match[0].length, replacement2);
        }
      }
    }
    return this;
  }
  _replaceString(string2, replacement) {
    const { original } = this;
    const index = original.indexOf(string2);
    if (index !== -1) {
      this.overwrite(index, index + string2.length, replacement);
    }
    return this;
  }
  replace(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceString(searchValue, replacement);
    }
    return this._replaceRegexp(searchValue, replacement);
  }
  _replaceAllString(string2, replacement) {
    const { original } = this;
    const stringLength = string2.length;
    for (let index = original.indexOf(string2); index !== -1; index = original.indexOf(string2, index + stringLength)) {
      const previous = original.slice(index, index + stringLength);
      if (previous !== replacement) this.overwrite(index, index + stringLength, replacement);
    }
    return this;
  }
  replaceAll(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceAllString(searchValue, replacement);
    }
    if (!searchValue.global) {
      throw new TypeError(
        "MagicString.prototype.replaceAll called with a non-global RegExp argument"
      );
    }
    return this._replaceRegexp(searchValue, replacement);
  }
};

// node_modules/svelte/src/compiler/utils/mapped_code.js
var import_remapping = __toESM(require_remapping_umd(), 1);

// node_modules/svelte/src/compiler/utils/push_array.js
function push_array(array2, items) {
  for (let i = 0; i < items.length; i++) {
    array2.push(items[i]);
  }
}

// node_modules/svelte/src/compiler/utils/mapped_code.js
function last_line_length(s) {
  return s.length - s.lastIndexOf("\n") - 1;
}
function sourcemap_add_offset(map, offset2, source_index) {
  if (map.mappings.length == 0) return;
  for (let line = 0; line < map.mappings.length; line++) {
    const segment_list = map.mappings[line];
    for (let segment = 0; segment < segment_list.length; segment++) {
      const seg = segment_list[segment];
      if (seg[1] === source_index) {
        if (seg[2] === 0) {
          seg[3] += offset2.column;
        }
        seg[2] += offset2.line;
      }
    }
  }
}
function merge_tables(this_table, other_table) {
  const new_table = this_table.slice();
  const idx_map = [];
  other_table = other_table || [];
  let val_changed = false;
  for (const [other_idx, other_val] of other_table.entries()) {
    const this_idx = this_table.indexOf(other_val);
    if (this_idx >= 0) {
      idx_map[other_idx] = this_idx;
    } else {
      const new_idx = new_table.length;
      new_table[new_idx] = other_val;
      idx_map[other_idx] = new_idx;
      val_changed = true;
    }
  }
  let idx_changed = val_changed;
  if (val_changed) {
    if (idx_map.find((val, idx) => val != idx) === void 0) {
      idx_changed = false;
    }
  }
  return [new_table, idx_map, val_changed, idx_changed];
}
var regex_line_token = /([^\w\s]|\s+)/g;
var MappedCode = class _MappedCode {
  /**
   * @param {string} string
   * @param {DecodedSourceMap | null} map
   */
  constructor(string2 = "", map = null) {
    /**
     * @type {string}
     */
    __publicField(this, "string");
    /**
     * @type {DecodedSourceMap}
     */
    __publicField(this, "map");
    this.string = string2;
    if (map) {
      this.map = map;
    } else {
      this.map = {
        version: 3,
        mappings: [],
        sources: [],
        names: []
      };
    }
  }
  /**
   * concat in-place (mutable), return this (chainable)
   * will also mutate the `other` object
   * @param {MappedCode} other
   * @returns {MappedCode}
   */
  concat(other) {
    if (other.string == "") return this;
    if (this.string == "") {
      this.string = other.string;
      this.map = other.map;
      return this;
    }
    const column_offset = last_line_length(this.string);
    this.string += other.string;
    const m1 = this.map;
    const m2 = other.map;
    if (m2.mappings.length == 0) return this;
    const [sources, new_source_idx, sources_changed, sources_idx_changed] = merge_tables(
      m1.sources,
      m2.sources
    );
    const [names, new_name_idx, names_changed, names_idx_changed] = merge_tables(
      m1.names,
      m2.names
    );
    if (sources_changed) m1.sources = sources;
    if (names_changed) m1.names = names;
    if (sources_idx_changed && names_idx_changed) {
      for (let line = 0; line < m2.mappings.length; line++) {
        const segment_list = m2.mappings[line];
        for (let segment = 0; segment < segment_list.length; segment++) {
          const seg = segment_list[segment];
          if (seg[1] >= 0) seg[1] = new_source_idx[seg[1]];
          if (seg[4] >= 0) seg[4] = new_name_idx[seg[4]];
        }
      }
    } else if (sources_idx_changed) {
      for (let line = 0; line < m2.mappings.length; line++) {
        const segment_list = m2.mappings[line];
        for (let segment = 0; segment < segment_list.length; segment++) {
          const seg = segment_list[segment];
          if (seg[1] >= 0) seg[1] = new_source_idx[seg[1]];
        }
      }
    } else if (names_idx_changed) {
      for (let line = 0; line < m2.mappings.length; line++) {
        const segment_list = m2.mappings[line];
        for (let segment = 0; segment < segment_list.length; segment++) {
          const seg = segment_list[segment];
          if (seg[4] >= 0) seg[4] = new_name_idx[seg[4]];
        }
      }
    }
    if (m2.mappings.length > 0 && column_offset > 0) {
      const first_line = m2.mappings[0];
      for (let i = 0; i < first_line.length; i++) {
        first_line[i][0] += column_offset;
      }
    }
    push_array(
      m1.mappings[m1.mappings.length - 1],
      /** @type {SourceMapSegment[]} */
      m2.mappings.shift()
    );
    push_array(m1.mappings, m2.mappings);
    return this;
  }
  /**
   * @static
   * @param {string} string
   * @param {DecodedSourceMap} [map]
   * @returns {MappedCode}
   */
  static from_processed(string2, map) {
    const line_count = string2.split("\n").length;
    if (map) {
      const missing_lines = line_count - map.mappings.length;
      for (let i = 0; i < missing_lines; i++) {
        map.mappings.push([]);
      }
      return new _MappedCode(string2, map);
    }
    if (string2 == "") return new _MappedCode();
    map = { version: 3, names: [], sources: [], mappings: [] };
    for (let i = 0; i < line_count; i++) map.mappings.push([]);
    return new _MappedCode(string2, map);
  }
  /**
   * @static
   * @param {Source} opts
   * @returns {MappedCode}
   */
  static from_source({ source: source2, file_basename, get_location }) {
    let offset2 = get_location(0);
    if (!offset2) offset2 = { line: 0, column: 0 };
    const map = { version: 3, names: [], sources: [file_basename], mappings: [] };
    if (source2 == "") return new _MappedCode(source2, map);
    const line_list = source2.split("\n");
    for (let line = 0; line < line_list.length; line++) {
      map.mappings.push([]);
      const token_list = line_list[line].split(regex_line_token);
      for (let token = 0, column = 0; token < token_list.length; token++) {
        if (token_list[token] == "") continue;
        map.mappings[line].push([column, 0, offset2.line + line, column]);
        column += token_list[token].length;
      }
    }
    const segment_list = map.mappings[0];
    for (let segment = 0; segment < segment_list.length; segment++) {
      segment_list[segment][3] += offset2.column;
    }
    return new _MappedCode(source2, map);
  }
};
var b64enc = typeof window !== "undefined" && typeof btoa === "function" ? (
  /** @param {string} str */
  (str) => btoa(unescape(encodeURIComponent(str)))
) : (
  /** @param {string} str */
  (str) => Buffer.from(str).toString("base64")
);
var b64dec = typeof window !== "undefined" && typeof atob === "function" ? atob : (
  /** @param {any} a */
  (a) => Buffer.from(a, "base64").toString()
);
function combine_sourcemaps(filename2, sourcemap_list) {
  if (sourcemap_list.length == 0) return null;
  let map_idx = 1;
  const map = sourcemap_list.slice(0, -1).find((m) => m.sources.length !== 1) === void 0 ? (0, import_remapping.default)(
    // use array interface
    // only the oldest sourcemap can have multiple sources
    sourcemap_list,
    () => null,
    true
    // skip optional field `sourcesContent`
  ) : (0, import_remapping.default)(
    // use loader interface
    sourcemap_list[0],
    // last map
    (sourcefile) => {
      if (sourcefile === filename2 && sourcemap_list[map_idx]) {
        return sourcemap_list[map_idx++];
      } else {
        return null;
      }
    },
    true
  );
  if (!map.file) delete map.file;
  if (!map.sources.length) map.sources = [filename2];
  return map;
}
function apply_preprocessor_sourcemap(filename2, svelte_map, preprocessor_map_input) {
  if (!svelte_map || !preprocessor_map_input) return svelte_map;
  const preprocessor_map = typeof preprocessor_map_input === "string" ? JSON.parse(preprocessor_map_input) : preprocessor_map_input;
  const result_map = combine_sourcemaps(filename2, [svelte_map, preprocessor_map]);
  Object.defineProperties(result_map, {
    toString: {
      enumerable: false,
      value: function toString3() {
        return JSON.stringify(this);
      }
    },
    toUrl: {
      enumerable: false,
      value: function toUrl() {
        return "data:application/json;charset=utf-8;base64," + b64enc(this.toString());
      }
    }
  });
  return (
    /** @type {any} */
    result_map
  );
}
var regex_data_uri = /data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(\S*)/;
function parse_attached_sourcemap(processed, tag_name) {
  const r_in = "[#@]\\s*sourceMappingURL\\s*=\\s*(\\S*)";
  const regex = tag_name == "script" ? new RegExp("(?://" + r_in + ")|(?:/\\*" + r_in + "\\s*\\*/)$") : new RegExp("/\\*" + r_in + "\\s*\\*/$");
  function log_warning(message) {
    const code_start = processed.code.length < 100 ? processed.code : processed.code.slice(0, 100) + " [...]";
    console.warn(`warning: ${message}. processed.code = ${JSON.stringify(code_start)}`);
  }
  processed.code = processed.code.replace(regex, (_, match1, match2) => {
    const map_url = tag_name == "script" ? match1 || match2 : match1;
    const map_data = (map_url.match(regex_data_uri) || [])[1];
    if (map_data) {
      if (processed.map) {
        log_warning(
          "Not implemented. Found sourcemap in both processed.code and processed.map. Please update your preprocessor to return only one sourcemap."
        );
        return "";
      }
      processed.map = b64dec(map_data);
      return "";
    }
    if (!processed.map) {
      log_warning(
        `Found sourcemap path ${JSON.stringify(
          map_url
        )} in processed.code, but no sourcemap data. Please update your preprocessor to return sourcemap data directly.`
      );
    }
    return "";
  });
}
function merge_with_preprocessor_map(result, options, source_name) {
  if (options.sourcemap) {
    const file_basename = get_basename(options.filename);
    result.map.sources = [file_basename];
    result.map = apply_preprocessor_sourcemap(
      file_basename,
      result.map,
      /** @type {any} */
      options.sourcemap
    );
    if (file_basename !== source_name) {
      result.map.sources = result.map.sources.map(
        /** @param {string} source */
        (source2) => get_relative_path(source_name, source2)
      );
    }
  }
}
function get_relative_path(from, to) {
  const from_parts = from.split(/[/\\]/);
  const to_parts = to.split(/[/\\]/);
  from_parts.pop();
  while (from_parts[0] === to_parts[0]) {
    from_parts.shift();
    to_parts.shift();
  }
  if (from_parts.length) {
    let i = from_parts.length;
    while (i--) from_parts[i] = "..";
  }
  return from_parts.concat(to_parts).join("/");
}
function get_basename(filename2) {
  return (
    /** @type {string} */
    filename2.split(/[/\\]/).pop()
  );
}
function get_source_name(filename2, output_filename, fallback) {
  return output_filename ? get_relative_path(output_filename, filename2) : get_basename(filename2);
}

// node_modules/svelte/src/compiler/phases/3-transform/css/index.js
function render_stylesheet(source2, analysis, options) {
  const code = new MagicString(source2);
  const state = {
    code,
    hash: analysis.css.hash,
    minify: analysis.inject_styles && !options.dev,
    selector: `.${analysis.css.hash}`,
    keyframes: analysis.css.keyframes,
    specificity: {
      bumped: false
    }
  };
  const ast = (
    /** @type {AST.CSS.StyleSheet} */
    analysis.css.ast
  );
  walk(
    /** @type {AST.CSS.Node} */
    ast,
    state,
    visitors4
  );
  code.remove(0, ast.content.start);
  code.remove(
    /** @type {number} */
    ast.content.end,
    source2.length
  );
  if (state.minify) {
    remove_preceding_whitespace(ast.content.end, state);
  }
  const css = {
    code: code.toString(),
    map: code.generateMap({
      // include source content; makes it easier/more robust looking up the source map code
      includeContent: true,
      // generateMap takes care of calculating source relative to file
      source: options.filename,
      file: options.cssOutputFilename || options.filename
    }),
    hasGlobal: analysis.css.has_global
  };
  merge_with_preprocessor_map(css, options, css.map.sources[0]);
  if (dev && options.css === "injected" && css.code) {
    css.code += `
/*# sourceMappingURL=${css.map.toUrl()} */`;
  }
  return css;
}
var visitors4 = {
  _: (node, context) => {
    context.state.code.addSourcemapLocation(node.start);
    context.state.code.addSourcemapLocation(node.end);
    context.next();
  },
  Atrule(node, { state, next: next2, path: path11 }) {
    if (is_keyframes_node(node)) {
      let start = node.start + node.name.length + 1;
      while (state.code.original[start] === " ") start += 1;
      let end = start;
      while (state.code.original[end] !== "{" && state.code.original[end] !== " ") end += 1;
      if (node.prelude.startsWith("-global-")) {
        state.code.remove(start, start + 8);
      } else if (!is_in_global_block2(path11)) {
        state.code.prependRight(start, `${state.hash}-`);
      }
      return;
    }
    next2();
  },
  Declaration(node, { state }) {
    const property = node.property && remove_css_prefix(node.property.toLowerCase());
    if (property === "animation" || property === "animation-name") {
      let index = node.start + node.property.length + 1;
      let name = "";
      while (index < state.code.original.length) {
        const character = state.code.original[index];
        if (regex_css_name_boundary.test(character)) {
          if (state.keyframes.includes(name)) {
            state.code.prependRight(index - name.length, `${state.hash}-`);
          }
          if (character === ";" || character === "}") {
            break;
          }
          name = "";
        } else {
          name += character;
        }
        index++;
      }
    } else if (state.minify) {
      remove_preceding_whitespace(node.start, state);
      if (!node.property.startsWith("--")) {
        let start = node.start + node.property.length + 1;
        let end = start;
        while (/\s/.test(state.code.original[end])) end++;
        if (end > start) state.code.remove(start, end);
      }
    }
  },
  Rule(node, { state, next: next2, visit, path: path11 }) {
    if (state.minify) {
      remove_preceding_whitespace(node.start, state);
      remove_preceding_whitespace(node.block.end - 1, state);
    }
    if (!dev && is_empty(node, is_in_global_block2(path11))) {
      if (state.minify) {
        state.code.remove(node.start, node.end);
      } else {
        state.code.prependRight(node.start, "/* (empty) ");
        state.code.appendLeft(node.end, "*/");
        escape_comment_close(node, state.code);
      }
      return;
    }
    if (!is_used(node) && !is_in_global_block2(path11)) {
      if (state.minify) {
        state.code.remove(node.start, node.end);
      } else {
        state.code.prependRight(node.start, "/* (unused) ");
        state.code.appendLeft(node.end, "*/");
        escape_comment_close(node, state.code);
      }
      return;
    }
    if (node.metadata.is_global_block) {
      const selector = node.prelude.children[0];
      if (node.prelude.children.length === 1 && selector.children.length === 1 && selector.children[0].selectors.length === 1) {
        if (state.minify) {
          state.code.remove(node.start, node.block.start + 1);
          state.code.remove(node.block.end - 1, node.end);
        } else {
          state.code.prependRight(node.start, "/* ");
          state.code.appendLeft(node.block.start + 1, "*/");
          state.code.prependRight(node.block.end - 1, "/*");
          state.code.appendLeft(node.block.end, "*/");
        }
        visit(node.block);
        return;
      }
    }
    next2();
  },
  SelectorList(node, { state, next: next2, path: path11 }) {
    const parent = path11.at(-1);
    if ((!is_in_global_block2(path11) || node.children.length > 1 && (parent == null ? void 0 : parent.type) === "Rule" && parent.metadata.is_global_block) && !path11.find((n2) => n2.type === "ComplexSelector" && !n2.metadata.used)) {
      const children = node.children;
      let pruning = false;
      let prune_start = children[0].start;
      let last = prune_start;
      let has_previous_used = false;
      for (let i = 0; i < children.length; i += 1) {
        const selector = children[i];
        if (selector.metadata.used === pruning) {
          if (pruning) {
            let i2 = selector.start;
            while (state.code.original[i2] !== ",") i2--;
            if (state.minify) {
              state.code.remove(prune_start, has_previous_used ? i2 : i2 + 1);
            } else {
              state.code.appendRight(has_previous_used ? i2 : i2 + 1, "*/");
            }
          } else {
            if (i === 0) {
              if (state.minify) {
                prune_start = selector.start;
              } else {
                state.code.prependRight(selector.start, "/* (unused) ");
              }
            } else {
              if (state.minify) {
                prune_start = last;
              } else {
                state.code.overwrite(last, selector.start, ` /* (unused) `);
              }
            }
          }
          pruning = !pruning;
        }
        if (!pruning && selector.metadata.used) {
          has_previous_used = true;
        }
        last = selector.end;
      }
      if (pruning) {
        if (state.minify) {
          state.code.remove(prune_start, last);
        } else {
          state.code.appendLeft(last, "*/");
        }
      }
    }
    let specificity = state.specificity;
    if ((parent == null ? void 0 : parent.type) === "Rule") {
      specificity = { bumped: false };
      let rule = parent.metadata.parent_rule;
      while (rule) {
        if (rule.metadata.has_local_selectors) {
          specificity = { bumped: true };
          break;
        }
        rule = rule.metadata.parent_rule;
      }
    }
    next2({ ...state, specificity });
  },
  ComplexSelector(node, context) {
    var _a2;
    const before_bumped = context.state.specificity.bumped;
    for (const relative_selector of node.children) {
      if (relative_selector.metadata.is_global) {
        const global = (
          /** @type {AST.CSS.PseudoClassSelector} */
          relative_selector.selectors[0]
        );
        remove_global_pseudo_class(global, relative_selector.combinator, context.state);
        const parent_rule = (_a2 = node.metadata.rule) == null ? void 0 : _a2.metadata.parent_rule;
        if (parent_rule && global.args === null) {
          if (relative_selector.combinator === null) {
            context.state.code.prependRight(global.start, "&");
          }
          if (parent_rule.prelude.children.length > 1 && node.children.length === node.children.findIndex((s) => s === relative_selector) - 1) {
            const next_selector = parent_rule.prelude.children.find((s) => s.start > global.end);
            if (next_selector && next_selector.metadata.used) {
              context.state.code.update(global.end, next_selector.start, "");
            }
          }
        }
        continue;
      } else {
        for (const selector of relative_selector.selectors) {
          if (selector.type === "PseudoClassSelector" && selector.name === "global") {
            remove_global_pseudo_class(selector, null, context.state);
          }
        }
      }
      if (relative_selector.metadata.scoped) {
        if (relative_selector.selectors.length === 1) {
          const selector = relative_selector.selectors[0];
          if (selector.type === "PseudoClassSelector" && (selector.name === "is" || selector.name === "where")) {
            continue;
          }
        }
        if (relative_selector.selectors.some((s) => s.type === "NestingSelector")) {
          continue;
        }
        let modifier = context.state.selector;
        if (context.state.specificity.bumped) modifier = `:where(${modifier})`;
        context.state.specificity.bumped = true;
        let i = relative_selector.selectors.length;
        while (i--) {
          const selector = relative_selector.selectors[i];
          if (selector.type === "PseudoElementSelector" || selector.type === "PseudoClassSelector") {
            if (selector.name !== "root" && selector.name !== "host") {
              if (i === 0) context.state.code.prependRight(selector.start, modifier);
            }
            continue;
          }
          if (selector.type === "TypeSelector" && selector.name === "*") {
            context.state.code.update(selector.start, selector.end, modifier);
          } else {
            context.state.code.appendLeft(selector.end, modifier);
          }
          break;
        }
      }
    }
    context.next();
    context.state.specificity.bumped = before_bumped;
  },
  PseudoClassSelector(node, context) {
    if (node.name === "is" || node.name === "where" || node.name === "has" || node.name === "not") {
      context.next();
    }
  }
};
function is_in_global_block2(path11) {
  return path11.some((node) => node.type === "Rule" && node.metadata.is_global_block);
}
function remove_global_pseudo_class(selector, combinator, state) {
  if (selector.args === null) {
    let start = selector.start;
    if ((combinator == null ? void 0 : combinator.name) === " ") {
      while (/\s/.test(state.code.original[start - 1])) start--;
    }
    state.code.update(start, selector.start + ":global".length, "");
  } else {
    state.code.remove(selector.start, selector.start + ":global(".length).remove(selector.end - 1, selector.end);
  }
}
function remove_preceding_whitespace(end, state) {
  let start = end;
  while (/\s/.test(state.code.original[start - 1])) start--;
  if (start < end) state.code.remove(start, end);
}
function is_empty(rule, is_in_global_block3) {
  if (rule.metadata.is_global_block) {
    return rule.block.children.length === 0;
  }
  for (const child of rule.block.children) {
    if (child.type === "Declaration") {
      return false;
    }
    if (child.type === "Rule") {
      if ((is_used(child) || is_in_global_block3) && !is_empty(child, is_in_global_block3)) {
        return false;
      }
    }
    if (child.type === "Atrule") {
      if (child.block === null || child.block.children.length > 0) return false;
    }
  }
  return true;
}
function is_used(rule) {
  return rule.prelude.children.some((selector) => selector.metadata.used);
}
function escape_comment_close(node, code) {
  let escaped = false;
  let in_comment = false;
  for (let i = node.start; i < node.end; i++) {
    if (escaped) {
      escaped = false;
    } else {
      const char = code.original[i];
      if (in_comment) {
        if (char === "*" && code.original[i + 1] === "/") {
          code.prependRight(++i, "\\");
          in_comment = false;
        }
      } else if (char === "\\") {
        escaped = true;
      } else if (char === "/" && code.original[++i] === "*") {
        in_comment = true;
      }
    }
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/declarations.js
function get_value(node) {
  return call("$.get", node);
}
function add_state_transformers(context) {
  for (const [name, binding] of context.state.scope.declarations) {
    if (is_state_source(binding, context.state.analysis) || binding.kind === "derived" || binding.kind === "legacy_reactive") {
      context.state.transform[name] = {
        read: binding.declaration_kind === "var" ? (node) => call("$.safe_get", node) : get_value,
        assign: (node, value, proxy = false) => {
          var _a2;
          let call2 = call("$.set", node, value, proxy && true_instance);
          if (((_a2 = context.state.scope.get(`$${node.name}`)) == null ? void 0 : _a2.kind) === "store_sub") {
            call2 = call("$.store_unsub", call2, literal2(`$${node.name}`), id("$$stores"));
          }
          return call2;
        },
        mutate: (node, mutation) => {
          if (context.state.analysis.runes) {
            return mutation;
          }
          return call("$.mutate", node, mutation);
        },
        update: (node) => {
          return call(
            node.prefix ? "$.update_pre" : "$.update",
            node.argument,
            node.operator === "--" && literal2(-1)
          );
        }
      };
    }
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/shared/assignments.js
function visit_assignment_expression(node, context, build_assignment3) {
  if (node.left.type === "ArrayPattern" || node.left.type === "ObjectPattern" || node.left.type === "RestElement") {
    const value = (
      /** @type {Expression} */
      context.visit(node.right)
    );
    const should_cache = value.type !== "Identifier";
    const rhs = should_cache ? id("$$value") : value;
    let changed = false;
    const { inserts, paths } = extract_paths(node.left, rhs);
    for (const { id: id2 } of inserts) {
      id2.name = context.state.scope.generate("$$array");
    }
    const assignments = paths.map((path11) => {
      const value2 = path11.expression;
      let assignment2 = build_assignment3("=", path11.node, value2, context);
      if (assignment2 !== null) changed = true;
      return assignment2 ?? assignment(
        "=",
        /** @type {Pattern} */
        context.visit(path11.node),
        /** @type {Expression} */
        context.visit(value2)
      );
    });
    if (!changed) {
      return null;
    }
    const is_standalone = (
      /** @type {Node} */
      context.path.at(-1).type.endsWith("Statement")
    );
    if (inserts.length > 0 || should_cache) {
      const statements = [
        ...inserts.map(({ id: id2, value: value2 }) => var_builder(id2, value2)),
        ...assignments.map(stmt)
      ];
      if (!is_standalone) {
        statements.push(return_builder(rhs));
      }
      const iife = arrow([rhs], block(statements));
      const iife_is_async = is_expression_async(value) || assignments.some((assignment2) => is_expression_async(assignment2));
      return iife_is_async ? await_builder(call(async(iife), value)) : call(iife, value);
    }
    const sequence3 = sequence(assignments);
    if (!is_standalone) {
      sequence3.expressions.push(rhs);
    }
    return sequence3;
  }
  if (node.left.type !== "Identifier" && node.left.type !== "MemberExpression") {
    throw new Error(`Unexpected assignment type ${node.left.type}`);
  }
  return build_assignment3(node.operator, node.left, node.right, context);
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/AssignmentExpression.js
function AssignmentExpression2(node, context) {
  return visit_assignment_expression(node, context, build_assignment) ?? context.next();
}
function build_assignment(operator, left, right, context) {
  if (context.state.analysis.runes && left.type === "MemberExpression") {
    const name2 = get_name(left.property);
    const field = name2 && context.state.state_fields.get(name2);
    if (field && field.node.type === "AssignmentExpression" && left === field.node.left) {
      const rune = get_rune(right, context.state.scope);
      if (rune) {
        const key2 = left.property.type === "PrivateIdentifier" || rune === "$state" || rune === "$state.raw" ? left.property : field.key;
        return assignment(
          operator,
          member(this_instance, key2, key2.type === "Literal"),
          /** @type {Expression} */
          context.visit(right)
        );
      }
    } else if (field && (field.type === "$derived" || field.type === "$derived.by")) {
      let value = (
        /** @type {Expression} */
        context.visit(build_assignment_value(operator, left, right))
      );
      return call(member(this_instance, name2), value);
    }
  }
  let object4 = left;
  while (object4.type === "MemberExpression") {
    object4 = object4.object;
  }
  if (object4.type !== "Identifier" || !is_store_name(object4.name)) {
    return null;
  }
  const name = object4.name.slice(1);
  if (!context.state.scope.get(name)) {
    return null;
  }
  if (object4 === left) {
    let value = (
      /** @type {Expression} */
      context.visit(build_assignment_value(operator, left, right))
    );
    return call("$.store_set", id(name), value);
  }
  return call(
    "$.store_mutate",
    assignment("??=", id("$$store_subs"), object([])),
    literal2(object4.name),
    id(name),
    assignment(
      operator,
      /** @type {Pattern} */
      context.visit(left),
      /** @type {Expression} */
      context.visit(right)
    )
  );
}
function is_store_name(name) {
  return name[0] === "$" && /[A-Za-z_]/.test(name[1]);
}

// node_modules/svelte/src/internal/server/hydration.js
var BLOCK_OPEN = `<!--${HYDRATION_START}-->`;
var BLOCK_OPEN_ELSE = `<!--${HYDRATION_START_ELSE}-->`;
var BLOCK_CLOSE = `<!--${HYDRATION_END}-->`;
var EMPTY_COMMENT = `<!---->`;

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/shared/utils.js
var block_open = literal2(BLOCK_OPEN);
var block_close = literal2(BLOCK_CLOSE);
var empty_comment = literal2(EMPTY_COMMENT);
function process_children(nodes, { visit, state }) {
  let sequence3 = [];
  function flush() {
    let quasi2 = quasi("", false);
    const quasis = [quasi2];
    const expressions = [];
    for (let i = 0; i < sequence3.length; i++) {
      const node = sequence3[i];
      if (node.type === "Text" || node.type === "Comment") {
        quasi2.value.cooked += node.type === "Comment" ? `<!--${node.data}-->` : escape_html(node.data);
      } else {
        const evaluated = state.scope.evaluate(node.expression);
        if (evaluated.is_known) {
          quasi2.value.cooked += escape_html((evaluated.value ?? "") + "");
        } else {
          expressions.push(call(
            "$.escape",
            /** @type {Expression} */
            visit(node.expression)
          ));
          quasi2 = quasi("", i + 1 === sequence3.length);
          quasis.push(quasi2);
        }
      }
    }
    for (const quasi3 of quasis) {
      quasi3.value.raw = sanitize_template_string(
        /** @type {string} */
        quasi3.value.cooked
      );
    }
    state.template.push(template(quasis, expressions));
  }
  for (let i = 0; i < nodes.length; i += 1) {
    const node = nodes[i];
    if (node.type === "Text" || node.type === "Comment" || node.type === "ExpressionTag") {
      sequence3.push(node);
    } else {
      if (sequence3.length > 0) {
        flush();
        sequence3 = [];
      }
      visit(node, { ...state });
    }
  }
  if (sequence3.length > 0) {
    flush();
  }
}
function is_statement(node) {
  return node.type.endsWith("Statement") || node.type.endsWith("Declaration");
}
function build_template(template2, out = id("$$payload.out"), operator = "+=") {
  let strings = [];
  let expressions = [];
  const statements = [];
  const flush = () => {
    statements.push(
      stmt(
        assignment(
          operator,
          out,
          template(
            strings.map((cooked, i) => quasi(cooked, i === strings.length - 1)),
            expressions
          )
        )
      )
    );
    strings = [];
    expressions = [];
  };
  for (let i = 0; i < template2.length; i++) {
    const node = template2[i];
    if (is_statement(node)) {
      if (strings.length !== 0) {
        flush();
      }
      statements.push(node);
    } else {
      if (strings.length === 0) {
        strings.push("");
      }
      if (node.type === "Literal") {
        strings[strings.length - 1] += node.value;
      } else if (node.type === "TemplateLiteral") {
        strings[strings.length - 1] += node.quasis[0].value.cooked;
        strings.push(...node.quasis.slice(1).map((q) => (
          /** @type {string} */
          q.value.cooked
        )));
        expressions.push(...node.expressions);
      } else {
        expressions.push(node);
        strings.push("");
      }
    }
  }
  if (strings.length !== 0) {
    flush();
  }
  return statements;
}
function build_attribute_value(value, context, trim_whitespace = false, is_component = false) {
  if (value === true) {
    return true_instance;
  }
  if (!Array.isArray(value) || value.length === 1) {
    const chunk = Array.isArray(value) ? value[0] : value;
    if (chunk.type === "Text") {
      const data2 = trim_whitespace ? chunk.data.replace(regex_whitespaces_strict, " ").trim() : chunk.data;
      return literal2(is_component ? data2 : escape_html(data2, true));
    }
    return (
      /** @type {Expression} */
      context.visit(chunk.expression)
    );
  }
  let quasi2 = quasi("", false);
  const quasis = [quasi2];
  const expressions = [];
  for (let i = 0; i < value.length; i++) {
    const node = value[i];
    if (node.type === "Text") {
      quasi2.value.raw += trim_whitespace ? node.data.replace(regex_whitespaces_strict, " ") : node.data;
    } else {
      expressions.push(
        call(
          "$.stringify",
          /** @type {Expression} */
          context.visit(node.expression)
        )
      );
      quasi2 = quasi("", i + 1 === value.length);
      quasis.push(quasi2);
    }
  }
  return template(quasis, expressions);
}
function build_getter2(node, state) {
  const binding = state.scope.get(node.name);
  if (binding === null || node === binding.node) {
    return node;
  }
  if (binding.kind === "store_sub") {
    const store_id = id(node.name.slice(1));
    return call(
      "$.store_get",
      assignment("??=", id("$$store_subs"), object([])),
      literal2(node.name),
      build_getter2(store_id, state)
    );
  }
  return node;
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/AwaitBlock.js
function AwaitBlock2(node, context) {
  context.state.template.push(
    stmt(
      call(
        "$.await",
        id("$$payload"),
        /** @type {Expression} */
        context.visit(node.expression),
        thunk(
          node.pending ? (
            /** @type {BlockStatement} */
            context.visit(node.pending)
          ) : block([])
        ),
        arrow(
          node.value ? [
            /** @type {Pattern} */
            context.visit(node.value)
          ] : [],
          node.then ? (
            /** @type {BlockStatement} */
            context.visit(node.then)
          ) : block([])
        )
      )
    ),
    block_close
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/utils.js
function is_hoisted_function(node) {
  var _a2;
  if (node.type === "ArrowFunctionExpression" || node.type === "FunctionExpression" || node.type === "FunctionDeclaration") {
    return ((_a2 = node.metadata) == null ? void 0 : _a2.hoisted) === true;
  }
  return false;
}
function sort_const_tags(nodes, state) {
  const other = [];
  const tags = /* @__PURE__ */ new Map();
  for (const node of nodes) {
    if (node.type === "ConstTag") {
      const declaration2 = node.declaration.declarations[0];
      const bindings = extract_identifiers(declaration2.id).map((id2) => {
        return (
          /** @type {Binding} */
          state.scope.get(id2.name)
        );
      });
      const deps = /* @__PURE__ */ new Set();
      walk(declaration2.init, state, {
        // @ts-expect-error don't know, don't care
        _: set_scope,
        Identifier(node2, context) {
          const parent = (
            /** @type {Expression} */
            context.path.at(-1)
          );
          if (is_reference(node2, parent)) {
            const binding = context.state.scope.get(node2.name);
            if (binding) deps.add(binding);
          }
        }
      });
      for (const binding of bindings) {
        tags.set(binding, { node, deps });
      }
    } else {
      other.push(node);
    }
  }
  if (tags.size === 0) {
    return nodes;
  }
  const edges = [];
  for (const [id2, tag2] of tags) {
    for (const dep of tag2.deps) {
      if (tags.has(dep)) {
        edges.push([id2, dep]);
      }
    }
  }
  const cycle = check_graph_for_cycles(edges);
  if (cycle == null ? void 0 : cycle.length) {
    const tag2 = (
      /** @type {Tag} */
      tags.get(cycle[0])
    );
    const_tag_cycle(tag2.node, cycle.map((binding) => binding.node.name).join(" → "));
  }
  const sorted = [];
  function add(tag2) {
    if (sorted.includes(tag2.node)) {
      return;
    }
    for (const dep of tag2.deps) {
      const dep_tag = tags.get(dep);
      if (dep_tag) add(dep_tag);
    }
    sorted.push(tag2.node);
  }
  for (const tag2 of tags.values()) {
    add(tag2);
  }
  return [...sorted, ...other];
}
function clean_nodes(parent, nodes, path11, namespace = "html", state, preserve_whitespace, preserve_comments) {
  if (!state.analysis.runes) {
    nodes = sort_const_tags(nodes, state);
  }
  const hoisted = [];
  const regular = [];
  for (const node of nodes) {
    if (node.type === "Comment" && !preserve_comments) {
      continue;
    }
    if (node.type === "ConstTag" || node.type === "DebugTag" || node.type === "SvelteBody" || node.type === "SvelteWindow" || node.type === "SvelteDocument" || node.type === "SvelteHead" || node.type === "TitleElement" || node.type === "SnippetBlock") {
      hoisted.push(node);
    } else {
      regular.push(node);
    }
  }
  let trimmed = regular;
  if (!preserve_whitespace) {
    trimmed = [];
    let first2, last;
    while ((first2 = regular[0]) && first2.type === "Text" && !regex_not_whitespace.test(first2.data)) {
      regular.shift();
    }
    if ((first2 == null ? void 0 : first2.type) === "Text") {
      first2.raw = first2.raw.replace(regex_starts_with_whitespaces, "");
      first2.data = first2.data.replace(regex_starts_with_whitespaces, "");
    }
    while ((last = regular.at(-1)) && last.type === "Text" && !regex_not_whitespace.test(last.data)) {
      regular.pop();
    }
    if ((last == null ? void 0 : last.type) === "Text") {
      last.raw = last.raw.replace(regex_ends_with_whitespaces, "");
      last.data = last.data.replace(regex_ends_with_whitespaces, "");
    }
    const can_remove_entirely = namespace === "svg" && (parent.type !== "RegularElement" || parent.name !== "text") && !path11.some((n2) => n2.type === "RegularElement" && n2.name === "text") || parent.type === "RegularElement" && // TODO others?
    (parent.name === "select" || parent.name === "tr" || parent.name === "table" || parent.name === "tbody" || parent.name === "thead" || parent.name === "tfoot" || parent.name === "colgroup" || parent.name === "datalist");
    for (let i = 0; i < regular.length; i++) {
      const prev = regular[i - 1];
      const node = regular[i];
      const next2 = regular[i + 1];
      if (node.type === "Text") {
        if ((prev == null ? void 0 : prev.type) !== "ExpressionTag") {
          const prev_is_text_ending_with_whitespace = (prev == null ? void 0 : prev.type) === "Text" && regex_ends_with_whitespaces.test(prev.data);
          node.data = node.data.replace(
            regex_starts_with_whitespaces,
            prev_is_text_ending_with_whitespace ? "" : " "
          );
          node.raw = node.raw.replace(
            regex_starts_with_whitespaces,
            prev_is_text_ending_with_whitespace ? "" : " "
          );
        }
        if ((next2 == null ? void 0 : next2.type) !== "ExpressionTag") {
          node.data = node.data.replace(regex_ends_with_whitespaces, " ");
          node.raw = node.raw.replace(regex_ends_with_whitespaces, " ");
        }
        if (node.data && (node.data !== " " || !can_remove_entirely)) {
          trimmed.push(node);
        }
      } else {
        trimmed.push(node);
      }
    }
  }
  var first = trimmed[0];
  if (parent.type === "RegularElement" && parent.name === "pre" && (first == null ? void 0 : first.type) === "Text") {
    if (first.data === "\n" || first.data === "\r\n") {
      trimmed.shift();
      first = trimmed[0];
    }
  }
  if (trimmed.length === 1 && first.type === "RegularElement" && first.name === "script") {
    trimmed.push({
      type: "Comment",
      data: "",
      start: -1,
      end: -1
    });
  }
  return {
    hoisted,
    trimmed,
    /**
     * In a case like `{#if x}<Foo />{/if}`, we don't need to wrap the child in
     * comments — we can just use the parent block's anchor for the component.
     * TODO extend this optimisation to other cases
     */
    is_standalone: trimmed.length === 1 && (first.type === "RenderTag" && !first.metadata.dynamic || first.type === "Component" && !state.options.hmr && !first.metadata.dynamic && !first.attributes.some(
      (attribute) => attribute.type === "Attribute" && attribute.name.startsWith("--")
    )),
    /** if a component/snippet/each block starts with text, we need to add an anchor comment so that its text node doesn't get fused with its surroundings */
    is_text_first: (parent.type === "Fragment" || parent.type === "SnippetBlock" || parent.type === "EachBlock" || parent.type === "SvelteComponent" || parent.type === "SvelteBoundary" || parent.type === "Component" || parent.type === "SvelteSelf") && first && ((first == null ? void 0 : first.type) === "Text" || (first == null ? void 0 : first.type) === "ExpressionTag")
  };
}
function infer_namespace(namespace, parent, nodes) {
  if (parent.type === "RegularElement" && parent.name === "foreignObject") {
    return "html";
  }
  if (parent.type === "RegularElement" || parent.type === "SvelteElement") {
    if (parent.metadata.svg) {
      return "svg";
    }
    return parent.metadata.mathml ? "mathml" : "html";
  }
  if (parent.type === "Fragment" || parent.type === "Root" || parent.type === "Component" || parent.type === "SvelteComponent" || parent.type === "SvelteFragment" || parent.type === "SnippetBlock" || parent.type === "SlotElement") {
    const new_namespace2 = check_nodes_for_namespace(nodes, "keep");
    if (new_namespace2 !== "keep" && new_namespace2 !== "maybe_html") {
      return new_namespace2;
    }
  }
  let new_namespace = null;
  for (const node of nodes) {
    if (node.type !== "RegularElement") continue;
    if (node.metadata.mathml) {
      new_namespace = new_namespace === null || new_namespace === "mathml" ? "mathml" : "html";
    } else if (node.metadata.svg) {
      new_namespace = new_namespace === null || new_namespace === "svg" ? "svg" : "html";
    } else {
      return "html";
    }
  }
  return new_namespace ?? namespace;
}
function check_nodes_for_namespace(nodes, namespace) {
  const RegularElement4 = (node, { stop }) => {
    if (!node.metadata.svg && !node.metadata.mathml) {
      namespace = "html";
      stop();
    } else if (namespace === "keep") {
      namespace = node.metadata.svg ? "svg" : "mathml";
    }
  };
  for (const node of nodes) {
    walk(
      node,
      {},
      {
        _(node2, { next: next2 }) {
          if (node2.type === "EachBlock" || node2.type === "IfBlock" || node2.type === "AwaitBlock" || node2.type === "Fragment" || node2.type === "KeyBlock" || node2.type === "RegularElement" || node2.type === "SvelteElement" || node2.type === "Text") {
            next2();
          }
        },
        SvelteElement: RegularElement4,
        RegularElement: RegularElement4,
        Text(node2) {
          if (node2.data.trim() !== "") {
            namespace = "maybe_html";
          }
        }
      }
    );
    if (namespace === "html") return namespace;
  }
  return namespace;
}
function determine_namespace_for_children(node, namespace) {
  if (node.name === "foreignObject") {
    return "html";
  }
  if (node.metadata.svg) {
    return "svg";
  }
  return node.metadata.mathml ? "mathml" : "html";
}
function transform_inspect_rune(node, context) {
  const { state, visit } = context;
  const as_fn = state.options.generate === "client";
  if (!dev) return empty2;
  if (node.callee.type === "MemberExpression") {
    const raw_inspect_args = (
      /** @type {CallExpression} */
      node.callee.object.arguments
    );
    const inspect_args = (
      /** @type {Array<Expression>} */
      raw_inspect_args.map((arg) => visit(arg))
    );
    const with_arg = (
      /** @type {Expression} */
      visit(node.arguments[0])
    );
    return call(
      "$.inspect",
      as_fn ? thunk(array(inspect_args)) : array(inspect_args),
      with_arg
    );
  } else {
    const arg = node.arguments.map((arg2) => (
      /** @type {Expression} */
      visit(arg2)
    ));
    return call("$.inspect", as_fn ? thunk(array(arg)) : array(arg));
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/CallExpression.js
function CallExpression2(node, context) {
  const rune = get_rune(node, context.state.scope);
  if (rune === "$host") {
    return void0;
  }
  if (rune === "$effect.tracking") {
    return false_instance;
  }
  if (rune === "$effect.root") {
    return arrow([], block([]));
  }
  if (rune === "$state" || rune === "$state.raw") {
    return node.arguments[0] ? context.visit(node.arguments[0]) : void0;
  }
  if (rune === "$derived" || rune === "$derived.by") {
    const fn = (
      /** @type {Expression} */
      context.visit(node.arguments[0])
    );
    return call("$.derived", rune === "$derived" ? thunk(fn) : fn);
  }
  if (rune === "$state.snapshot") {
    return call(
      "$.snapshot",
      /** @type {Expression} */
      context.visit(node.arguments[0]),
      is_ignored(node, "state_snapshot_uncloneable") && true_instance
    );
  }
  if (rune === "$inspect" || rune === "$inspect().with") {
    return transform_inspect_rune(node, context);
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/ClassBody.js
function ClassBody2(node, context) {
  const state_fields = context.state.analysis.classes.get(node);
  if (!state_fields) {
    context.next();
    return;
  }
  const body = [];
  const child_state = { ...context.state, state_fields };
  for (const [name, field] of state_fields) {
    if (name[0] === "#") {
      continue;
    }
    if (field && field.node.type === "AssignmentExpression" && (field.type === "$derived" || field.type === "$derived.by")) {
      const member2 = member(this_instance, field.key);
      body.push(
        prop_def(field.key, null),
        method("get", key(name), [], [return_builder(call(member2))]),
        method("set", key(name), [id("$$value")], [return_builder(call(member2, id("$$value")))])
      );
    }
  }
  for (const definition of node.body) {
    if (definition.type !== "PropertyDefinition") {
      body.push(
        /** @type {MethodDefinition | StaticBlock} */
        context.visit(definition, child_state)
      );
      continue;
    }
    const name = get_name(definition.key);
    const field = name && state_fields.get(name);
    if (!field) {
      body.push(
        /** @type {PropertyDefinition} */
        context.visit(definition, child_state)
      );
      continue;
    }
    if (name[0] === "#" || field.type === "$state" || field.type === "$state.raw") {
      body.push(
        /** @type {PropertyDefinition} */
        context.visit(definition, child_state)
      );
    } else if (field.node === definition) {
      const member2 = member(this_instance, field.key);
      body.push(
        prop_def(
          field.key,
          /** @type {CallExpression} */
          context.visit(field.value, child_state)
        ),
        method("get", definition.key, [], [return_builder(call(member2))]),
        method("set", key(name), [id("$$value")], [return_builder(call(member2, id("$$value")))])
      );
    }
  }
  return { ...node, body };
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/shared/component.js
function build_inline_component(node, expression, context) {
  const props_and_spreads = [];
  const delayed_props = [];
  const custom_css_props = [];
  const lets = { default: [] };
  const child_state = {
    ...context.state,
    scope: node.metadata.scopes.default
  };
  const children = {};
  const slot_scope_applies_to_itself = node.attributes.some(
    (node2) => node2.type === "Attribute" && node2.name === "slot"
  );
  let has_children_prop = false;
  function push_prop(prop2, delay = false) {
    const do_push = () => {
      const current2 = props_and_spreads.at(-1);
      const current_is_props = Array.isArray(current2);
      const props = current_is_props ? current2 : [];
      props.push(prop2);
      if (!current_is_props) {
        props_and_spreads.push(props);
      }
    };
    if (delay) {
      delayed_props.push(do_push);
    } else {
      do_push();
    }
  }
  for (const attribute of node.attributes) {
    if (attribute.type === "LetDirective") {
      if (!slot_scope_applies_to_itself) {
        lets.default.push(attribute);
      }
    } else if (attribute.type === "SpreadAttribute") {
      props_and_spreads.push(
        /** @type {Expression} */
        context.visit(attribute)
      );
    } else if (attribute.type === "Attribute") {
      if (attribute.name.startsWith("--")) {
        const value2 = build_attribute_value(attribute.value, context, false, true);
        custom_css_props.push(init2(attribute.name, value2));
        continue;
      }
      if (attribute.name === "children") {
        has_children_prop = true;
      }
      const value = build_attribute_value(attribute.value, context, false, true);
      push_prop(prop("init", key(attribute.name), value));
    } else if (attribute.type === "BindDirective" && attribute.name !== "this") {
      if (attribute.expression.type === "SequenceExpression") {
        const [get2, set2] = (
          /** @type {SequenceExpression} */
          context.visit(attribute.expression).expressions
        );
        const get_id = id(context.state.scope.generate("bind_get"));
        const set_id = id(context.state.scope.generate("bind_set"));
        context.state.init.push(var_builder(get_id, get2));
        context.state.init.push(var_builder(set_id, set2));
        push_prop(get(attribute.name, [return_builder(call(get_id))]));
        push_prop(set(attribute.name, [stmt(call(set_id, id("$$value")))]));
      } else {
        push_prop(
          get(attribute.name, [
            return_builder(
              /** @type {Expression} */
              context.visit(attribute.expression)
            )
          ]),
          true
        );
        push_prop(
          set(attribute.name, [
            stmt(
              /** @type {Expression} */
              context.visit(assignment("=", attribute.expression, id("$$value")))
            ),
            stmt(assignment("=", id("$$settled"), false_instance))
          ]),
          true
        );
      }
    }
  }
  delayed_props.forEach((fn) => fn());
  const snippet_declarations = [];
  const serialized_slots = [];
  for (const child of node.fragment.nodes) {
    if (child.type === "SnippetBlock") {
      context.visit(child, {
        ...context.state,
        init: snippet_declarations
      });
      push_prop(prop("init", child.expression, child.expression));
      serialized_slots.push(
        init2(child.expression.name === "children" ? "default" : child.expression.name, true_instance)
      );
      continue;
    }
    let slot_name = "default";
    if (is_element_node(child)) {
      const slot = (
        /** @type {AST.Attribute | undefined} */
        child.attributes.find(
          (attribute) => attribute.type === "Attribute" && attribute.name === "slot"
        )
      );
      if (slot !== void 0) {
        slot_name = /** @type {AST.Text[]} */
        slot.value[0].data;
        lets[slot_name] = child.attributes.filter((attribute) => attribute.type === "LetDirective");
      } else if (child.type === "SvelteFragment") {
        lets.default.push(
          ...child.attributes.filter((attribute) => attribute.type === "LetDirective")
        );
      }
    }
    children[slot_name] = children[slot_name] || [];
    children[slot_name].push(child);
  }
  for (const slot_name of Object.keys(children)) {
    const block2 = (
      /** @type {BlockStatement} */
      context.visit(
        {
          ...node.fragment,
          // @ts-expect-error
          nodes: children[slot_name]
        },
        slot_name === "default" ? child_state : {
          ...context.state,
          scope: node.metadata.scopes[slot_name]
        }
      )
    );
    if (block2.body.length === 0) continue;
    const params = [id("$$payload")];
    if (lets[slot_name].length > 0) {
      const pattern = object_pattern(
        lets[slot_name].map((node2) => {
          if (node2.expression === null) {
            return init2(node2.name, id(node2.name));
          }
          if (node2.expression.type === "ObjectExpression") {
            return init2(node2.name, object_pattern(node2.expression.properties));
          }
          if (node2.expression.type === "ArrayExpression") {
            return init2(node2.name, array_pattern(node2.expression.elements));
          }
          return init2(node2.name, node2.expression);
        })
      );
      params.push(pattern);
    }
    const slot_fn = arrow(params, block(block2.body));
    if (slot_name === "default" && !has_children_prop) {
      if (lets.default.length === 0 && children.default.every(
        (node2) => node2.type !== "SvelteFragment" || !node2.attributes.some((attr) => attr.type === "LetDirective")
      )) {
        push_prop(
          prop(
            "init",
            id("children"),
            dev ? call("$.prevent_snippet_stringification", slot_fn) : slot_fn
          )
        );
        serialized_slots.push(init2(slot_name, true_instance));
      } else {
        serialized_slots.push(init2(slot_name, slot_fn));
        push_prop(init2("children", id("$.invalid_default_snippet")));
      }
    } else {
      serialized_slots.push(init2(slot_name, slot_fn));
    }
  }
  if (serialized_slots.length > 0) {
    push_prop(prop("init", id("$$slots"), object(serialized_slots)));
  }
  const props_expression = props_and_spreads.length === 0 || props_and_spreads.length === 1 && Array.isArray(props_and_spreads[0]) ? object(
    /** @type {Property[]} */
    props_and_spreads[0] || []
  ) : call(
    "$.spread_props",
    array(props_and_spreads.map((p) => Array.isArray(p) ? object(p) : p))
  );
  let statement = stmt(
    (node.type === "SvelteComponent" ? maybe_call : call)(
      expression,
      id("$$payload"),
      props_expression
    )
  );
  if (snippet_declarations.length > 0) {
    statement = block([...snippet_declarations, statement]);
  }
  const dynamic = node.type === "SvelteComponent" || node.type === "Component" && node.metadata.dynamic;
  if (custom_css_props.length > 0) {
    context.state.template.push(
      stmt(
        call(
          "$.css_props",
          id("$$payload"),
          literal2(context.state.namespace === "svg" ? false : true),
          object(custom_css_props),
          thunk(block([statement])),
          dynamic && true_instance
        )
      )
    );
  } else {
    if (dynamic) {
      context.state.template.push(empty_comment);
    }
    context.state.template.push(statement);
    if (!context.state.skip_hydration_boundaries) {
      context.state.template.push(empty_comment);
    }
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/Component.js
function Component2(node, context) {
  build_inline_component(node, id(node.name), context);
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/ConstTag.js
function ConstTag2(node, context) {
  const declaration2 = node.declaration.declarations[0];
  const id2 = (
    /** @type {Pattern} */
    context.visit(declaration2.id)
  );
  const init3 = (
    /** @type {Expression} */
    context.visit(declaration2.init)
  );
  context.state.init.push(const_builder(id2, init3));
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/DebugTag.js
function DebugTag2(node, context) {
  context.state.template.push(
    stmt(
      call(
        "console.log",
        object(
          node.identifiers.map(
            (identifier) => prop(
              "init",
              identifier,
              /** @type {Expression} */
              context.visit(identifier)
            )
          )
        )
      )
    ),
    debugger_builder
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/EachBlock.js
function EachBlock2(node, context) {
  const state = context.state;
  const each_node_meta = node.metadata;
  const collection = (
    /** @type {Expression} */
    context.visit(node.expression)
  );
  const index = each_node_meta.contains_group_binding || !node.index ? each_node_meta.index : id(node.index);
  const array_id = state.scope.root.unique("each_array");
  state.init.push(const_builder(array_id, call("$.ensure_array_like", collection)));
  const each = [];
  if (node.context) {
    each.push(let_builder(node.context, member(array_id, index, true)));
  }
  if (index.name !== node.index && node.index != null) {
    each.push(let_builder(node.index, index));
  }
  each.push(.../** @type {BlockStatement} */
  context.visit(node.body).body);
  const for_loop = for_builder(
    declaration("let", [
      declarator(index, literal2(0)),
      declarator("$$length", member(array_id, "length"))
    ]),
    binary("<", index, id("$$length")),
    update("++", index, false),
    block(each)
  );
  if (node.fallback) {
    const open2 = stmt(assignment("+=", id("$$payload.out"), block_open));
    const fallback = (
      /** @type {BlockStatement} */
      context.visit(node.fallback)
    );
    fallback.body.unshift(
      stmt(assignment("+=", id("$$payload.out"), literal2(BLOCK_OPEN_ELSE)))
    );
    state.template.push(
      if_builder(
        binary("!==", member(array_id, "length"), literal2(0)),
        block([open2, for_loop]),
        fallback
      ),
      block_close
    );
  } else {
    state.template.push(block_open, for_loop, block_close);
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/ExpressionStatement.js
function ExpressionStatement2(node, context) {
  const rune = get_rune(node.expression, context.state.scope);
  if (rune === "$effect" || rune === "$effect.pre" || rune === "$effect.root" || rune === "$inspect.trace") {
    return empty2;
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/Fragment.js
function Fragment(node, context) {
  const parent = context.path.at(-1) ?? node;
  const namespace = infer_namespace(context.state.namespace, parent, node.nodes);
  const { hoisted, trimmed, is_standalone, is_text_first } = clean_nodes(
    parent,
    node.nodes,
    context.path,
    namespace,
    context.state,
    context.state.preserve_whitespace,
    context.state.options.preserveComments
  );
  const state = {
    ...context.state,
    init: [],
    template: [],
    namespace,
    skip_hydration_boundaries: is_standalone
  };
  for (const node2 of hoisted) {
    context.visit(node2, state);
  }
  if (is_text_first) {
    state.template.push(empty_comment);
  }
  process_children(trimmed, { ...context, state });
  return block([...state.init, ...build_template(state.template)]);
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/HtmlTag.js
function HtmlTag2(node, context) {
  const expression = (
    /** @type {Expression} */
    context.visit(node.expression)
  );
  context.state.template.push(call("$.html", expression));
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/Identifier.js
function Identifier2(node, context) {
  if (is_reference(
    node,
    /** @type {Node} */
    context.path.at(-1)
  )) {
    if (node.name === "$$props") {
      return id("$$sanitized_props");
    }
    return build_getter2(node, context.state);
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/IfBlock.js
function IfBlock2(node, context) {
  const consequent = (
    /** @type {BlockStatement} */
    context.visit(node.consequent)
  );
  consequent.body.unshift(stmt(assignment("+=", id("$$payload.out"), block_open)));
  let if_statement = if_builder(
    /** @type {Expression} */
    context.visit(node.test),
    consequent
  );
  context.state.template.push(if_statement, block_close);
  let index = 1;
  let alt = node.alternate;
  while (alt && alt.nodes.length === 1 && alt.nodes[0].type === "IfBlock" && alt.nodes[0].elseif) {
    const elseif = alt.nodes[0];
    const alternate = (
      /** @type {BlockStatement} */
      context.visit(elseif.consequent)
    );
    alternate.body.unshift(
      stmt(assignment("+=", id("$$payload.out"), literal2(`<!--[${index++}-->`)))
    );
    if_statement = if_statement.alternate = if_builder(
      /** @type {Expression} */
      context.visit(elseif.test),
      alternate
    );
    alt = elseif.alternate;
  }
  if_statement.alternate = alt ? (
    /** @type {BlockStatement} */
    context.visit(alt)
  ) : block([]);
  if_statement.alternate.body.unshift(
    stmt(assignment("+=", id("$$payload.out"), literal2(BLOCK_OPEN_ELSE)))
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/KeyBlock.js
function KeyBlock2(node, context) {
  context.state.template.push(
    empty_comment,
    /** @type {BlockStatement} */
    context.visit(node.fragment),
    empty_comment
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/LabeledStatement.js
function LabeledStatement2(node, context) {
  if (context.state.analysis.runes || context.path.length > 1 || node.label.name !== "$") {
    return;
  }
  context.state.legacy_reactive_statements.set(
    node,
    // people could do "break $" inside, so we need to keep the label
    labeled(
      "$",
      /** @type {ExpressionStatement} */
      context.visit(node.body)
    )
  );
  return empty2;
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/MemberExpression.js
function MemberExpression2(node, context) {
  var _a2;
  if (context.state.analysis.runes && node.object.type === "ThisExpression" && node.property.type === "PrivateIdentifier") {
    const field = (_a2 = context.state.state_fields) == null ? void 0 : _a2.get(`#${node.property.name}`);
    if ((field == null ? void 0 : field.type) === "$derived" || (field == null ? void 0 : field.type) === "$derived.by") {
      return call(node);
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/PropertyDefinition.js
function PropertyDefinition2(node, context) {
  if (context.state.analysis.runes && node.value != null && node.value.type === "CallExpression") {
    const rune = get_rune(node.value, context.state.scope);
    if (rune === "$state" || rune === "$state.raw") {
      return {
        ...node,
        value: node.value.arguments.length === 0 ? null : (
          /** @type {Expression} */
          context.visit(node.value.arguments[0])
        )
      };
    }
    if (rune === "$derived.by" || rune === "$derived") {
      const fn = (
        /** @type {Expression} */
        context.visit(node.value.arguments[0])
      );
      return {
        ...node,
        value: node.value.arguments.length === 0 ? null : call("$.derived", rune === "$derived" ? thunk(fn) : fn)
      };
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/shared/element.js
var WHITESPACE_INSENSITIVE_ATTRIBUTES = ["class", "style"];
function build_element_attributes(node, context) {
  const attributes = [];
  const class_directives = [];
  const style_directives = [];
  let content = null;
  let has_spread = false;
  let events_to_capture = /* @__PURE__ */ new Set();
  for (const attribute of node.attributes) {
    if (attribute.type === "Attribute") {
      if (attribute.name === "value") {
        if (node.name === "textarea") {
          if (attribute.value !== true && Array.isArray(attribute.value) && attribute.value[0].type === "Text" && regex_starts_with_newline.test(attribute.value[0].data)) {
            attribute.value[0].data = "\n" + attribute.value[0].data;
          }
          content = call("$.escape", build_attribute_value(attribute.value, context));
        } else if (node.name !== "select") {
          attributes.push(attribute);
        }
      } else if (is_event_attribute(attribute)) {
        if ((attribute.name === "onload" || attribute.name === "onerror") && is_load_error_element(node.name)) {
          events_to_capture.add(attribute.name);
        }
      } else if (attribute.name !== "defaultValue" && attribute.name !== "defaultChecked") {
        if (attribute.name === "class") {
          if (attribute.metadata.needs_clsx) {
            attributes.push({
              ...attribute,
              value: {
                .../** @type {AST.ExpressionTag} */
                attribute.value,
                expression: call(
                  "$.clsx",
                  /** @type {AST.ExpressionTag} */
                  attribute.value.expression
                )
              }
            });
          } else {
            attributes.push(attribute);
          }
        } else {
          attributes.push(attribute);
        }
      }
    } else if (attribute.type === "BindDirective") {
      if (attribute.name === "value" && node.name === "select") continue;
      if (attribute.name === "value" && attributes.some(
        (attr) => attr.type === "Attribute" && attr.name === "type" && is_text_attribute(attr) && attr.value[0].data === "file"
      )) {
        continue;
      }
      if (attribute.name === "this") continue;
      const binding = binding_properties[attribute.name];
      if (binding == null ? void 0 : binding.omit_in_ssr) continue;
      let expression = (
        /** @type {Expression} */
        context.visit(attribute.expression)
      );
      if (expression.type === "SequenceExpression") {
        expression = call(expression.expressions[0]);
      }
      if (is_content_editable_binding(attribute.name)) {
        content = expression;
      } else if (attribute.name === "value" && node.name === "textarea") {
        content = call("$.escape", expression);
      } else if (attribute.name === "group" && attribute.expression.type !== "SequenceExpression") {
        const value_attribute = (
          /** @type {AST.Attribute | undefined} */
          node.attributes.find((attr) => attr.type === "Attribute" && attr.name === "value")
        );
        if (!value_attribute) continue;
        const is_checkbox = node.attributes.some(
          (attr) => attr.type === "Attribute" && attr.name === "type" && is_text_attribute(attr) && attr.value[0].data === "checkbox"
        );
        attributes.push(
          create_attribute("checked", -1, -1, [
            {
              type: "ExpressionTag",
              start: -1,
              end: -1,
              expression: is_checkbox ? call(
                member(attribute.expression, "includes"),
                build_attribute_value(value_attribute.value, context)
              ) : binary(
                "===",
                attribute.expression,
                build_attribute_value(value_attribute.value, context)
              ),
              metadata: {
                expression: create_expression_metadata()
              }
            }
          ])
        );
      } else {
        attributes.push(
          create_attribute(attribute.name, -1, -1, [
            {
              type: "ExpressionTag",
              start: -1,
              end: -1,
              expression,
              metadata: {
                expression: create_expression_metadata()
              }
            }
          ])
        );
      }
    } else if (attribute.type === "SpreadAttribute") {
      attributes.push(attribute);
      has_spread = true;
      if (is_load_error_element(node.name)) {
        events_to_capture.add("onload");
        events_to_capture.add("onerror");
      }
    } else if (attribute.type === "UseDirective") {
      if (is_load_error_element(node.name)) {
        events_to_capture.add("onload");
        events_to_capture.add("onerror");
      }
    } else if (attribute.type === "ClassDirective") {
      class_directives.push(attribute);
    } else if (attribute.type === "StyleDirective") {
      style_directives.push(attribute);
    } else if (attribute.type === "LetDirective") {
    } else {
      context.visit(attribute);
    }
  }
  if (has_spread) {
    build_element_spread_attributes(node, attributes, style_directives, class_directives, context);
    if (node.name === "option") {
      context.state.template.push(
        call(
          "$.maybe_selected",
          id("$$payload"),
          member(
            build_spread_object(
              node,
              node.attributes.filter(
                (attribute) => attribute.type === "Attribute" || attribute.type === "BindDirective" || attribute.type === "SpreadAttribute"
              ),
              context
            ),
            "value",
            false,
            true
          )
        )
      );
    }
  } else {
    const css_hash = node.metadata.scoped ? context.state.analysis.css.hash : null;
    for (
      const attribute of
      /** @type {AST.Attribute[]} */
      attributes
    ) {
      const name = get_attribute_name(node, attribute);
      const can_use_literal = (name !== "class" || class_directives.length === 0) && (name !== "style" || style_directives.length === 0);
      if (can_use_literal && (attribute.value === true || is_text_attribute(attribute))) {
        let literal_value = (
          /** @type {Literal} */
          build_attribute_value(
            attribute.value,
            context,
            WHITESPACE_INSENSITIVE_ATTRIBUTES.includes(name)
          ).value
        );
        if (name === "class" && css_hash) {
          literal_value = (String(literal_value) + " " + css_hash).trim();
        }
        if (name !== "class" || literal_value) {
          context.state.template.push(
            literal2(
              ` ${attribute.name}${is_boolean_attribute(name) && literal_value === true ? "" : `="${literal_value === true ? "" : String(literal_value)}"`}`
            )
          );
        }
        if (node.name === "option" && name === "value") {
          context.state.template.push(
            call(
              "$.maybe_selected",
              id("$$payload"),
              literal_value != null ? literal2(
                /** @type {any} */
                literal_value
              ) : void0
            )
          );
        }
        continue;
      }
      const value = build_attribute_value(
        attribute.value,
        context,
        WHITESPACE_INSENSITIVE_ATTRIBUTES.includes(name)
      );
      if (can_use_literal && value.type === "Literal" && typeof value.value === "string") {
        if (name === "class" && css_hash) {
          value.value = (value.value + " " + css_hash).trim();
        }
        context.state.template.push(literal2(` ${name}="${escape_html(value.value, true)}"`));
      } else if (name === "class") {
        context.state.template.push(build_attr_class(class_directives, value, context, css_hash));
      } else if (name === "style") {
        context.state.template.push(build_attr_style(style_directives, value, context));
      } else {
        context.state.template.push(
          call("$.attr", literal2(name), value, is_boolean_attribute(name) && true_instance)
        );
      }
      if (name === "value" && node.name === "option") {
        context.state.template.push(call("$.maybe_selected", id("$$payload"), value));
      }
    }
  }
  if (events_to_capture.size !== 0) {
    for (const event of events_to_capture) {
      context.state.template.push(literal2(` ${event}="this.__e=event"`));
    }
  }
  return content;
}
function get_attribute_name(element2, attribute) {
  let name = attribute.name;
  if (!element2.metadata.svg && !element2.metadata.mathml) {
    name = name.toLowerCase();
  }
  return name;
}
function build_spread_object(element2, attributes, context) {
  return object(
    attributes.map((attribute) => {
      if (attribute.type === "Attribute") {
        const name = get_attribute_name(element2, attribute);
        const value = build_attribute_value(
          attribute.value,
          context,
          WHITESPACE_INSENSITIVE_ATTRIBUTES.includes(name)
        );
        return prop("init", key(name), value);
      } else if (attribute.type === "BindDirective") {
        const name = get_attribute_name(element2, attribute);
        const value = attribute.expression.type === "SequenceExpression" ? call(attribute.expression.expressions[0]) : (
          /** @type {Expression} */
          context.visit(attribute.expression)
        );
        return prop("init", key(name), value);
      }
      return spread(
        /** @type {Expression} */
        context.visit(attribute)
      );
    })
  );
}
function build_element_spread_attributes(element2, attributes, style_directives, class_directives, context) {
  let classes;
  let styles;
  let flags = 0;
  if (class_directives.length) {
    const properties = class_directives.map(
      (directive) => init2(
        directive.name,
        directive.expression.type === "Identifier" && directive.expression.name === directive.name ? id(directive.name) : (
          /** @type {Expression} */
          context.visit(directive.expression)
        )
      )
    );
    classes = object(properties);
  }
  if (style_directives.length > 0) {
    const properties = style_directives.map(
      (directive) => init2(
        directive.name,
        directive.value === true ? id(directive.name) : build_attribute_value(directive.value, context, true)
      )
    );
    styles = object(properties);
  }
  if (element2.metadata.svg || element2.metadata.mathml) {
    flags |= ELEMENT_IS_NAMESPACED | ELEMENT_PRESERVE_ATTRIBUTE_CASE;
  } else if (is_custom_element_node(element2)) {
    flags |= ELEMENT_PRESERVE_ATTRIBUTE_CASE;
  }
  const object4 = build_spread_object(element2, attributes, context);
  const css_hash = element2.metadata.scoped && context.state.analysis.css.hash ? literal2(context.state.analysis.css.hash) : null_instance;
  const args = [object4, css_hash, classes, styles, flags ? literal2(flags) : void 0];
  context.state.template.push(call("$.spread_attributes", ...args));
}
function build_attr_class(class_directives, expression, context, hash2) {
  let directives;
  if (class_directives.length) {
    directives = object(
      class_directives.map(
        (directive) => prop(
          "init",
          literal2(directive.name),
          /** @type {Expression} */
          context.visit(directive.expression, context.state)
        )
      )
    );
  }
  let css_hash;
  if (hash2) {
    if (expression.type === "Literal" && typeof expression.value === "string") {
      expression.value = (expression.value + " " + hash2).trim();
    } else {
      css_hash = literal2(hash2);
    }
  }
  return call("$.attr_class", expression, css_hash, directives);
}
function build_attr_style(style_directives, expression, context) {
  let directives;
  if (style_directives.length) {
    let normal_properties = [];
    let important_properties = [];
    for (const directive of style_directives) {
      const expression2 = directive.value === true ? id(directive.name) : build_attribute_value(directive.value, context, true);
      let name = directive.name;
      if (name[0] !== "-" || name[1] !== "-") {
        name = name.toLowerCase();
      }
      const property = init2(directive.name, expression2);
      if (directive.modifiers.includes("important")) {
        important_properties.push(property);
      } else {
        normal_properties.push(property);
      }
    }
    if (important_properties.length) {
      directives = array([object(normal_properties), object(important_properties)]);
    } else {
      directives = object(normal_properties);
    }
  }
  return call("$.attr_style", expression, directives);
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/RegularElement.js
function RegularElement2(node, context) {
  const namespace = determine_namespace_for_children(node, context.state.namespace);
  const state = {
    ...context.state,
    namespace,
    preserve_whitespace: context.state.preserve_whitespace || node.name === "pre" || node.name === "textarea"
  };
  const node_is_void = is_void(node.name);
  context.state.template.push(literal2(`<${node.name}`));
  const body = build_element_attributes(node, { ...context, state });
  context.state.template.push(literal2(node_is_void ? "/>" : ">"));
  if ((node.name === "script" || node.name === "style") && node.fragment.nodes.length === 1) {
    context.state.template.push(
      literal2(
        /** @type {AST.Text} */
        node.fragment.nodes[0].data
      ),
      literal2(`</${node.name}>`)
    );
    return;
  }
  const { hoisted, trimmed } = clean_nodes(
    node,
    node.fragment.nodes,
    context.path,
    namespace,
    {
      ...state,
      scope: (
        /** @type {Scope} */
        state.scopes.get(node.fragment)
      )
    },
    state.preserve_whitespace,
    state.options.preserveComments
  );
  for (const node2 of hoisted) {
    context.visit(node2, state);
  }
  if (dev) {
    const location = (
      /** @type {Location} */
      locator(node.start)
    );
    state.template.push(
      stmt(
        call(
          "$.push_element",
          id("$$payload"),
          literal2(node.name),
          literal2(location.line),
          literal2(location.column)
        )
      )
    );
  }
  let select_with_value = false;
  if (node.name === "select") {
    const value = node.attributes.find(
      (attribute) => (attribute.type === "Attribute" || attribute.type === "BindDirective") && attribute.name === "value"
    );
    if (node.attributes.some((attribute) => attribute.type === "SpreadAttribute")) {
      select_with_value = true;
      state.template.push(
        stmt(
          assignment(
            "=",
            id("$$payload.select_value"),
            member(
              build_spread_object(
                node,
                node.attributes.filter(
                  (attribute) => attribute.type === "Attribute" || attribute.type === "BindDirective" || attribute.type === "SpreadAttribute"
                ),
                context
              ),
              "value",
              false,
              true
            )
          )
        )
      );
    } else if (value) {
      select_with_value = true;
      const left = id("$$payload.select_value");
      if (value.type === "Attribute") {
        state.template.push(
          stmt(assignment("=", left, build_attribute_value(value.value, context)))
        );
      } else if (value.type === "BindDirective") {
        state.template.push(
          stmt(
            assignment(
              "=",
              left,
              value.expression.type === "SequenceExpression" ? (
                /** @type {Expression} */
                context.visit(call(value.expression.expressions[0]))
              ) : (
                /** @type {Expression} */
                context.visit(value.expression)
              )
            )
          )
        );
      }
    }
  }
  if (node.name === "option" && !node.attributes.some(
    (attribute) => attribute.type === "SpreadAttribute" || (attribute.type === "Attribute" || attribute.type === "BindDirective") && attribute.name === "value"
  )) {
    const inner_state = { ...state, template: [], init: [] };
    process_children(trimmed, { ...context, state: inner_state });
    state.template.push(
      stmt(
        call(
          "$.valueless_option",
          id("$$payload"),
          thunk(block([...inner_state.init, ...build_template(inner_state.template)]))
        )
      )
    );
  } else if (body !== null) {
    const inner_state = { ...state, template: [], init: [] };
    process_children(trimmed, { ...context, state: inner_state });
    let id2 = (
      /** @type {Expression} */
      body
    );
    if (body.type !== "Identifier") {
      id2 = id(state.scope.generate("$$body"));
      state.template.push(const_builder(id2, body));
    }
    state.template.push(
      if_builder(
        id2,
        block(build_template([id2])),
        block([...inner_state.init, ...build_template(inner_state.template)])
      )
    );
  } else {
    process_children(trimmed, { ...context, state });
  }
  if (select_with_value) {
    state.template.push(stmt(assignment("=", id("$$payload.select_value"), void0)));
  }
  if (!node_is_void) {
    state.template.push(literal2(`</${node.name}>`));
  }
  if (dev) {
    state.template.push(stmt(call("$.pop_element")));
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/RenderTag.js
function RenderTag2(node, context) {
  const callee = unwrap_optional(node.expression).callee;
  const raw_args = unwrap_optional(node.expression).arguments;
  const snippet_function = (
    /** @type {Expression} */
    context.visit(callee)
  );
  const snippet_args = raw_args.map((arg) => {
    return (
      /** @type {Expression} */
      context.visit(arg)
    );
  });
  context.state.template.push(
    stmt(
      (node.expression.type === "CallExpression" ? call : maybe_call)(
        snippet_function,
        id("$$payload"),
        ...snippet_args
      )
    )
  );
  if (!context.state.skip_hydration_boundaries) {
    context.state.template.push(empty_comment);
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SlotElement.js
function SlotElement2(node, context) {
  const props = [];
  const spreads = [];
  let name = literal2("default");
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute") {
      spreads.push(
        /** @type {Expression} */
        context.visit(attribute)
      );
    } else if (attribute.type === "Attribute") {
      const value = build_attribute_value(attribute.value, context, false, true);
      if (attribute.name === "name") {
        name = /** @type {Literal} */
        value;
      } else if (attribute.name !== "slot") {
        props.push(init2(attribute.name, value));
      }
    }
  }
  const props_expression = spreads.length === 0 ? object(props) : call("$.spread_props", array([object(props), ...spreads]));
  const fallback = node.fragment.nodes.length === 0 ? null_instance : thunk(
    /** @type {BlockStatement} */
    context.visit(node.fragment)
  );
  const slot = call(
    "$.slot",
    id("$$payload"),
    id("$$props"),
    name,
    props_expression,
    fallback
  );
  context.state.template.push(empty_comment, stmt(slot), empty_comment);
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SnippetBlock.js
function SnippetBlock2(node, context) {
  let fn = function_declaration(
    node.expression,
    [id("$$payload"), ...node.parameters],
    /** @type {BlockStatement} */
    context.visit(node.body)
  );
  fn.___snippet = true;
  const statements = node.metadata.can_hoist ? context.state.hoisted : context.state.init;
  if (dev) {
    fn.body.body.unshift(stmt(call("$.validate_snippet_args", id("$$payload"))));
    statements.push(stmt(call("$.prevent_snippet_stringification", fn.id)));
  }
  statements.push(fn);
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SpreadAttribute.js
function SpreadAttribute2(node, context) {
  return context.visit(node.expression);
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SvelteComponent.js
function SvelteComponent2(node, context) {
  build_inline_component(
    node,
    /** @type {Expression} */
    context.visit(node.expression),
    context
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SvelteElement.js
function SvelteElement2(node, context) {
  let tag2 = (
    /** @type {Expression} */
    context.visit(node.tag)
  );
  if (dev) {
    if (tag2.type !== "Identifier") {
      const tag_id = context.state.scope.generate("$$tag");
      context.state.init.push(const_builder(tag_id, tag2));
      tag2 = id(tag_id);
    }
    if (node.fragment.nodes.length > 0) {
      context.state.init.push(stmt(call("$.validate_void_dynamic_element", thunk(tag2))));
    }
    context.state.init.push(stmt(call("$.validate_dynamic_element_tag", thunk(tag2))));
  }
  const state = {
    ...context.state,
    namespace: determine_namespace_for_children(node, context.state.namespace),
    template: [],
    init: []
  };
  build_element_attributes(node, { ...context, state });
  if (dev) {
    const location = (
      /** @type {Location} */
      locator(node.start)
    );
    context.state.template.push(
      stmt(
        call(
          "$.push_element",
          id("$$payload"),
          tag2,
          literal2(location.line),
          literal2(location.column)
        )
      )
    );
  }
  const attributes = block([...state.init, ...build_template(state.template)]);
  const children = (
    /** @type {BlockStatement} */
    context.visit(node.fragment, state)
  );
  context.state.template.push(
    stmt(
      call(
        "$.element",
        id("$$payload"),
        tag2,
        attributes.body.length > 0 && thunk(attributes),
        children.body.length > 0 && thunk(children)
      )
    )
  );
  if (dev) {
    context.state.template.push(stmt(call("$.pop_element")));
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SvelteFragment.js
function SvelteFragment2(node, context) {
  context.state.template.push(
    /** @type {BlockStatement} */
    context.visit(node.fragment)
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SvelteHead.js
function SvelteHead2(node, context) {
  const block2 = (
    /** @type {BlockStatement} */
    context.visit(node.fragment)
  );
  context.state.template.push(
    stmt(call("$.head", id("$$payload"), arrow([id("$$payload")], block2)))
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SvelteSelf.js
function SvelteSelf2(node, context) {
  build_inline_component(node, id(context.state.analysis.name), context);
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/TitleElement.js
function TitleElement2(node, context) {
  const template2 = [literal2("<title>")];
  process_children(node.fragment.nodes, { ...context, state: { ...context.state, template: template2 } });
  template2.push(literal2("</title>"));
  context.state.init.push(...build_template(template2, id("$$payload.title"), "="));
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/UpdateExpression.js
function UpdateExpression2(node, context) {
  var _a2;
  const argument = node.argument;
  if (argument.type === "Identifier" && ((_a2 = context.state.scope.get(argument.name)) == null ? void 0 : _a2.kind) === "store_sub") {
    return call(
      node.prefix ? "$.update_store_pre" : "$.update_store",
      assignment("??=", id("$$store_subs"), object([])),
      literal2(argument.name),
      id(argument.name.slice(1)),
      node.operator === "--" && literal2(-1)
    );
  }
  return context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/VariableDeclaration.js
function VariableDeclaration(node, context) {
  const declarations = [];
  if (context.state.analysis.runes) {
    for (const declarator2 of node.declarations) {
      const init3 = declarator2.init;
      const rune = get_rune(init3, context.state.scope);
      if (!rune || rune === "$effect.tracking" || rune === "$inspect" || rune === "$effect.root") {
        declarations.push(
          /** @type {VariableDeclarator} */
          context.visit(declarator2)
        );
        continue;
      }
      if (rune === "$props.id") {
        continue;
      }
      if (rune === "$props") {
        let has_rest = false;
        let id2 = walk(declarator2.id, null, {
          RestElement(node2, context2) {
            if (context2.path.at(-1) === declarator2.id) {
              has_rest = true;
            }
          },
          AssignmentPattern(node2) {
            if (node2.right.type === "CallExpression" && get_rune(node2.right, context.state.scope) === "$bindable") {
              const right = node2.right.arguments.length ? (
                /** @type {Expression} */
                context.visit(node2.right.arguments[0])
              ) : void0;
              return assignment_pattern(node2.left, right);
            }
          }
        });
        const slots_name = (
          /** @type {ComponentAnalysis} */
          context.state.analysis.uses_slots ? id("$$slots_") : id("$$slots")
        );
        if (id2.type === "ObjectPattern" && has_rest) {
          id2.properties.splice(
            id2.properties.length - 1,
            0,
            // @ts-ignore
            prop("init", id("$$slots"), slots_name),
            prop("init", id("$$events"), id("$$events"))
          );
        } else if (id2.type === "Identifier") {
          id2 = object_pattern([
            prop("init", id("$$slots"), slots_name),
            prop("init", id("$$events"), id("$$events")),
            rest(id(id2.name))
          ]);
        }
        declarations.push(
          declarator(
            /** @type {Pattern} */
            context.visit(id2),
            id("$$props")
          )
        );
        continue;
      }
      const args = (
        /** @type {CallExpression} */
        init3.arguments
      );
      const value = args.length > 0 ? (
        /** @type {Expression} */
        context.visit(args[0])
      ) : void0;
      if (rune === "$derived.by") {
        declarations.push(
          declarator(
            /** @type {Pattern} */
            context.visit(declarator2.id),
            call(value)
          )
        );
        continue;
      }
      if (declarator2.id.type === "Identifier") {
        declarations.push(declarator(declarator2.id, value));
        continue;
      }
      if (rune === "$derived") {
        declarations.push(
          declarator(
            /** @type {Pattern} */
            context.visit(declarator2.id),
            value
          )
        );
        continue;
      }
      declarations.push(...create_state_declarators(declarator2, context.state.scope, value));
    }
  } else {
    for (const declarator2 of node.declarations) {
      const bindings = (
        /** @type {Binding[]} */
        context.state.scope.get_bindings(declarator2)
      );
      const has_state = bindings.some((binding) => binding.kind === "state");
      const has_props = bindings.some((binding) => binding.kind === "bindable_prop");
      if (!has_state && !has_props) {
        declarations.push(
          /** @type {VariableDeclarator} */
          context.visit(declarator2)
        );
        continue;
      }
      if (has_props) {
        if (declarator2.id.type !== "Identifier") {
          const tmp = id(context.state.scope.generate("tmp"));
          const { inserts, paths } = extract_paths(declarator2.id, tmp);
          declarations.push(
            declarator(
              tmp,
              /** @type {Expression} */
              context.visit(
                /** @type {Expression} */
                declarator2.init
              )
            )
          );
          for (const { id: id2, value } of inserts) {
            id2.name = context.state.scope.generate("$$array");
            declarations.push(declarator(id2, value));
          }
          for (const path11 of paths) {
            const value = path11.expression;
            const name = (
              /** @type {Identifier} */
              path11.node.name
            );
            const binding2 = (
              /** @type {Binding} */
              context.state.scope.get(name)
            );
            const prop3 = member(id("$$props"), literal2(binding2.prop_alias ?? name), true);
            declarations.push(declarator(path11.node, build_fallback(prop3, value)));
          }
          continue;
        }
        const binding = (
          /** @type {Binding} */
          context.state.scope.get(declarator2.id.name)
        );
        const prop2 = member(
          id("$$props"),
          literal2(binding.prop_alias ?? declarator2.id.name),
          true
        );
        let init3 = prop2;
        if (declarator2.init) {
          const default_value = (
            /** @type {Expression} */
            context.visit(declarator2.init)
          );
          init3 = build_fallback(prop2, default_value);
        }
        declarations.push(declarator(declarator2.id, init3));
        continue;
      }
      declarations.push(
        ...create_state_declarators(
          declarator2,
          context.state.scope,
          /** @type {Expression} */
          declarator2.init && context.visit(declarator2.init)
        )
      );
    }
  }
  if (declarations.length === 0) {
    return empty2;
  }
  return {
    ...node,
    declarations
  };
}
function create_state_declarators(declarator2, scope, value) {
  if (declarator2.id.type === "Identifier") {
    return [declarator(declarator2.id, value)];
  }
  const tmp = id(scope.generate("tmp"));
  const { paths } = extract_paths(declarator2.id, tmp);
  return [
    declarator(tmp, value),
    // TODO inject declarator for opts, so we can use it below
    ...paths.map((path11) => {
      const value2 = path11.expression;
      return declarator(path11.node, value2);
    })
  ];
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SvelteBoundary.js
function SvelteBoundary2(node, context) {
  context.state.template.push(
    literal2(BLOCK_OPEN),
    /** @type {BlockStatement} */
    context.visit(node.fragment),
    literal2(BLOCK_CLOSE)
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/server/transform-server.js
var global_visitors = {
  _: set_scope,
  AssignmentExpression: AssignmentExpression2,
  CallExpression: CallExpression2,
  ClassBody: ClassBody2,
  ExpressionStatement: ExpressionStatement2,
  Identifier: Identifier2,
  LabeledStatement: LabeledStatement2,
  MemberExpression: MemberExpression2,
  PropertyDefinition: PropertyDefinition2,
  UpdateExpression: UpdateExpression2,
  VariableDeclaration
};
var template_visitors = {
  AwaitBlock: AwaitBlock2,
  Component: Component2,
  ConstTag: ConstTag2,
  DebugTag: DebugTag2,
  EachBlock: EachBlock2,
  Fragment,
  HtmlTag: HtmlTag2,
  IfBlock: IfBlock2,
  KeyBlock: KeyBlock2,
  RegularElement: RegularElement2,
  RenderTag: RenderTag2,
  SlotElement: SlotElement2,
  SnippetBlock: SnippetBlock2,
  SpreadAttribute: SpreadAttribute2,
  SvelteComponent: SvelteComponent2,
  SvelteElement: SvelteElement2,
  SvelteFragment: SvelteFragment2,
  SvelteHead: SvelteHead2,
  SvelteSelf: SvelteSelf2,
  TitleElement: TitleElement2,
  SvelteBoundary: SvelteBoundary2
};
function server_component(analysis, options) {
  const state = {
    analysis,
    options,
    scope: analysis.module.scope,
    scopes: analysis.module.scopes,
    hoisted: [import_all("$", "svelte/internal/server")],
    legacy_reactive_statements: /* @__PURE__ */ new Map(),
    // these are set inside the `Fragment` visitor, and cannot be used until then
    init: (
      /** @type {any} */
      null
    ),
    template: (
      /** @type {any} */
      null
    ),
    namespace: options.namespace,
    preserve_whitespace: options.preserveWhitespace,
    state_fields: /* @__PURE__ */ new Map(),
    skip_hydration_boundaries: false
  };
  const module = (
    /** @type {Program} */
    walk(
      /** @type {AST.SvelteNode} */
      analysis.module.ast,
      state,
      global_visitors
    )
  );
  const instance = (
    /** @type {Program} */
    walk(
      /** @type {AST.SvelteNode} */
      analysis.instance.ast,
      { ...state, scopes: analysis.instance.scopes },
      {
        ...global_visitors,
        ImportDeclaration(node) {
          state.hoisted.push(node);
          return empty2;
        },
        ExportNamedDeclaration(node, context) {
          if (node.declaration) {
            return context.visit(node.declaration);
          }
          return empty2;
        }
      }
    )
  );
  const template2 = (
    /** @type {Program} */
    walk(
      /** @type {AST.SvelteNode} */
      analysis.template.ast,
      { ...state, scopes: analysis.template.scopes },
      // @ts-expect-error don't know, don't care
      { ...global_visitors, ...template_visitors }
    )
  );
  const legacy_reactive_declarations = [];
  for (const [node] of analysis.reactive_statements) {
    const statement = [...state.legacy_reactive_statements].find(([n2]) => n2 === node);
    if (statement === void 0) {
      throw new Error("Could not find reactive statement");
    }
    if (node.body.type === "ExpressionStatement" && node.body.expression.type === "AssignmentExpression") {
      for (const id2 of extract_identifiers(node.body.expression.left)) {
        const binding = analysis.instance.scope.get(id2.name);
        if ((binding == null ? void 0 : binding.kind) === "legacy_reactive") {
          legacy_reactive_declarations.push(declarator(id2));
        }
      }
    }
    instance.body.push(statement[1]);
  }
  if (legacy_reactive_declarations.length > 0) {
    instance.body.unshift({
      type: "VariableDeclaration",
      kind: "let",
      declarations: legacy_reactive_declarations
    });
  }
  if (analysis.uses_component_bindings) {
    const snippets = template2.body.filter(
      // @ts-expect-error
      (node) => node.type === "FunctionDeclaration" && node.___snippet
    );
    const rest2 = template2.body.filter(
      // @ts-expect-error
      (node) => node.type !== "FunctionDeclaration" || !node.___snippet
    );
    template2.body = [
      ...snippets,
      let_builder("$$settled", true_instance),
      let_builder("$$inner_payload"),
      function_declaration(
        id("$$render_inner"),
        [id("$$payload")],
        block(
          /** @type {Statement[]} */
          rest2
        )
      ),
      do_while(
        unary("!", id("$$settled")),
        block([
          stmt(assignment("=", id("$$settled"), true_instance)),
          stmt(
            assignment("=", id("$$inner_payload"), call("$.copy_payload", id("$$payload")))
          ),
          stmt(call("$$render_inner", id("$$inner_payload")))
        ])
      ),
      stmt(call("$.assign_payload", id("$$payload"), id("$$inner_payload")))
    ];
  }
  if ([...analysis.instance.scope.declarations.values()].some(
    (binding) => binding.kind === "store_sub"
  )) {
    instance.body.unshift(var_builder("$$store_subs"));
    template2.body.push(
      if_builder(id("$$store_subs"), stmt(call("$.unsubscribe_stores", id("$$store_subs"))))
    );
  }
  const props = [];
  for (const [name, binding] of analysis.instance.scope.declarations) {
    if (binding.kind === "bindable_prop" && !name.startsWith("$$")) {
      props.push(init2(binding.prop_alias ?? name, id(name)));
    }
  }
  for (const { name, alias } of analysis.exports) {
    props.push(init2(alias ?? name, id(name)));
  }
  if (props.length > 0) {
    template2.body.push(stmt(call("$.bind_props", id("$$props"), object(props))));
  }
  const component_block = block([
    .../** @type {Statement[]} */
    instance.body,
    .../** @type {Statement[]} */
    template2.body
  ]);
  if (analysis.props_id) {
    component_block.body.unshift(
      const_builder(analysis.props_id, call("$.props_id", id("$$payload")))
    );
  }
  let should_inject_context = dev || analysis.needs_context;
  if (should_inject_context) {
    component_block.body.unshift(stmt(call("$.push", dev && id(analysis.name))));
    component_block.body.push(stmt(call("$.pop")));
  }
  if (analysis.uses_rest_props) {
    const named_props = analysis.exports.map(({ name, alias }) => alias ?? name);
    for (const [name, binding] of analysis.instance.scope.declarations) {
      if (binding.kind === "bindable_prop") named_props.push(binding.prop_alias ?? name);
    }
    component_block.body.unshift(
      const_builder(
        "$$restProps",
        call(
          "$.rest_props",
          id("$$sanitized_props"),
          array(named_props.map((name) => literal2(name)))
        )
      )
    );
  }
  if (analysis.uses_props || analysis.uses_rest_props) {
    component_block.body.unshift(
      const_builder("$$sanitized_props", call("$.sanitize_props", id("$$props")))
    );
  }
  if (analysis.uses_slots) {
    component_block.body.unshift(const_builder("$$slots", call("$.sanitize_slots", id("$$props"))));
  }
  const body = [...state.hoisted, ...module.body];
  if (analysis.css.ast !== null && options.css === "injected" && !options.customElement) {
    const hash2 = literal2(analysis.css.hash);
    const code = literal2(render_stylesheet(analysis.source, analysis, options).code);
    body.push(const_builder("$$css", object([init2("hash", hash2), init2("code", code)])));
    component_block.body.unshift(stmt(call("$$payload.css.add", id("$$css"))));
  }
  let should_inject_props = should_inject_context || props.length > 0 || analysis.needs_props || analysis.uses_props || analysis.uses_rest_props || analysis.uses_slots || analysis.slot_names.size > 0;
  const component_function = function_declaration(
    id(analysis.name),
    should_inject_props ? [id("$$payload"), id("$$props")] : [id("$$payload")],
    component_block
  );
  if (options.compatibility.componentApi === 4) {
    body.unshift(imports([["render", "$$_render"]], "svelte/server"));
    body.push(
      component_function,
      stmt(
        assignment(
          "=",
          member_id(`${analysis.name}.render`),
          function_builder(
            null,
            [id("$$props"), id("$$opts")],
            block([
              return_builder(
                call(
                  "$$_render",
                  id(analysis.name),
                  object([
                    init2("props", id("$$props")),
                    init2("context", member(id("$$opts"), "context", false, true))
                  ])
                )
              )
            ])
          )
        )
      ),
      export_default(id(analysis.name))
    );
  } else if (dev) {
    body.push(
      component_function,
      stmt(
        assignment(
          "=",
          member_id(`${analysis.name}.render`),
          function_builder(
            null,
            [],
            block([
              throw_error(
                `Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information`
              )
            ])
          )
        )
      ),
      export_default(id(analysis.name))
    );
  } else {
    body.push(export_default(component_function));
  }
  if (dev) {
    body.unshift(
      stmt(
        assignment("=", member(id(analysis.name), "$.FILENAME", true), literal2(filename))
      )
    );
  }
  return {
    type: "Program",
    sourceType: "module",
    body
  };
}
function server_module(analysis, options) {
  const state = {
    analysis,
    options,
    scope: analysis.module.scope,
    scopes: analysis.module.scopes,
    // this is an anomaly — it can only be used in components, but it needs
    // to be present for `javascript_visitors_legacy` and so is included in module
    // transform state as well as component transform state
    legacy_reactive_statements: /* @__PURE__ */ new Map(),
    state_fields: /* @__PURE__ */ new Map()
  };
  const module = (
    /** @type {Program} */
    walk(
      /** @type {AST.SvelteNode} */
      analysis.module.ast,
      state,
      global_visitors
    )
  );
  return {
    type: "Program",
    sourceType: "module",
    body: [import_all("$", "svelte/internal/server"), ...module.body]
  };
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/AnimateDirective.js
function AnimateDirective(node, context) {
  const expression = node.expression === null ? null_instance : thunk(
    /** @type {Expression} */
    context.visit(node.expression)
  );
  context.state.after_update.push(
    stmt(
      call(
        "$.animation",
        context.state.node,
        thunk(
          /** @type {Expression} */
          context.visit(parse_directive_name(node.name))
        ),
        expression
      )
    )
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/function.js
var visit_function2 = (node, context) => {
  const metadata = node.metadata;
  let state = { ...context.state, in_constructor: false };
  if (node.type === "FunctionExpression") {
    const parent = (
      /** @type {Node} */
      context.path.at(-1)
    );
    state.in_constructor = parent.type === "MethodDefinition" && parent.kind === "constructor";
  }
  if ((metadata == null ? void 0 : metadata.hoisted) === true) {
    const params = build_hoisted_params(node, context);
    return (
      /** @type {FunctionExpression} */
      {
        ...node,
        params,
        body: context.visit(node.body, state)
      }
    );
  }
  context.next(state);
};

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/ArrowFunctionExpression.js
function ArrowFunctionExpression2(node, context) {
  return visit_function2(node, context);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/AssignmentExpression.js
function AssignmentExpression3(node, context) {
  const expression = (
    /** @type {Expression} */
    visit_assignment_expression(node, context, build_assignment2) ?? context.next()
  );
  return validate_mutation(node, context, expression);
}
function is_non_coercive_operator(operator) {
  return ["=", "||=", "&&=", "??="].includes(operator);
}
var callees = {
  "=": "$.assign",
  "&&=": "$.assign_and",
  "||=": "$.assign_or",
  "??=": "$.assign_nullish"
};
function build_assignment2(operator, left, right, context) {
  if (context.state.analysis.runes && left.type === "MemberExpression") {
    const name = get_name(left.property);
    const field = name && context.state.state_fields.get(name);
    if (field) {
      if (field.node.type === "AssignmentExpression" && left === field.node.left) {
        const rune = get_rune(right, context.state.scope);
        if (rune) {
          const child_state = {
            ...context.state,
            in_constructor: rune !== "$derived" && rune !== "$derived.by"
          };
          return assignment(
            operator,
            member(this_instance, field.key),
            /** @type {Expression} */
            context.visit(right, child_state)
          );
        }
      }
      if (left.property.type === "PrivateIdentifier") {
        let value = (
          /** @type {Expression} */
          context.visit(build_assignment_value(operator, left, right))
        );
        const needs_proxy = field.type === "$state" && is_non_coercive_operator(operator) && should_proxy(value, context.state.scope);
        return call("$.set", left, value, needs_proxy && true_instance);
      }
    }
  }
  let object4 = left;
  while (object4.type === "MemberExpression") {
    object4 = object4.object;
  }
  if (object4.type !== "Identifier") {
    return null;
  }
  const binding = context.state.scope.get(object4.name);
  if (!binding) return null;
  const transform = Object.hasOwn(context.state.transform, object4.name) ? context.state.transform[object4.name] : null;
  const path11 = context.path.map((node) => node.type);
  if (object4 === left && (transform == null ? void 0 : transform.assign)) {
    const is_primitive = path11.at(-1) === "BindDirective" && path11.at(-2) === "RegularElement";
    let value = (
      /** @type {Expression} */
      context.visit(build_assignment_value(operator, left, right))
    );
    return transform.assign(
      object4,
      value,
      !is_primitive && binding.kind !== "prop" && binding.kind !== "bindable_prop" && binding.kind !== "raw_state" && binding.kind !== "store_sub" && context.state.analysis.runes && should_proxy(right, context.state.scope) && is_non_coercive_operator(operator)
    );
  }
  if (transform == null ? void 0 : transform.mutate) {
    return transform.mutate(
      object4,
      assignment(
        operator,
        /** @type {Pattern} */
        context.visit(left),
        /** @type {Expression} */
        context.visit(right)
      )
    );
  }
  let should_transform = dev && path11.at(-1) !== "ExpressionStatement" && is_non_coercive_operator(operator);
  if (path11.at(-1) === "ArrowFunctionExpression" && (path11.at(-2) === "RegularElement" || path11.at(-2) === "SvelteElement")) {
    const element2 = (
      /** @type {AST.RegularElement} */
      context.path.at(-2)
    );
    const attribute = element2.attributes.find((attribute2) => {
      if (attribute2.type !== "Attribute" || !is_event_attribute(attribute2)) {
        return false;
      }
      const expression = get_attribute_expression(attribute2);
      return expression === context.path.at(-1);
    });
    if (attribute) {
      should_transform = false;
    }
  }
  if (path11.at(-1) === "BindDirective" || path11.at(-1) === "Component" || path11.at(-1) === "SvelteComponent" || path11.at(-1) === "ArrowFunctionExpression" && path11.at(-2) === "SequenceExpression" && (path11.at(-3) === "Component" || path11.at(-3) === "SvelteComponent" || path11.at(-3) === "BindDirective")) {
    should_transform = false;
  }
  if (left.type === "MemberExpression" && should_transform) {
    const callee = callees[operator];
    return (
      /** @type {Expression} */
      context.visit(
        call(
          callee,
          /** @type {Expression} */
          left.object,
          /** @type {Expression} */
          left.computed ? left.property : literal2(
            /** @type {Identifier} */
            left.property.name
          ),
          right,
          literal2(locate_node(left))
        )
      )
    );
  }
  return null;
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/events.js
function visit_event_attribute(node, context) {
  let capture = false;
  let event_name = node.name.slice(2);
  if (is_capture_event(event_name)) {
    event_name = event_name.slice(0, -7);
    capture = true;
  }
  const tag2 = Array.isArray(node.value) ? (
    /** @type {AST.ExpressionTag} */
    node.value[0]
  ) : (
    /** @type {AST.ExpressionTag} */
    node.value
  );
  let handler = build_event_handler(tag2.expression, tag2.metadata.expression, context);
  if (node.metadata.delegated) {
    let delegated_assignment;
    if (!context.state.events.has(event_name)) {
      context.state.events.add(event_name);
    }
    if (node.metadata.delegated.hoisted) {
      if (node.metadata.delegated.function === tag2.expression) {
        const func_name = context.state.scope.root.unique("on_" + event_name);
        context.state.hoisted.push(var_builder(func_name, handler));
        handler = func_name;
      }
      const hoisted_params = (
        /** @type {Expression[]} */
        node.metadata.delegated.function.metadata.hoisted_params
      );
      if (hoisted_params) {
        const args = [handler, ...hoisted_params];
        delegated_assignment = array(args);
      } else {
        delegated_assignment = handler;
      }
    } else {
      delegated_assignment = handler;
    }
    context.state.init.push(
      stmt(
        assignment("=", member(context.state.node, "__" + event_name), delegated_assignment)
      )
    );
  } else {
    const statement = stmt(
      build_event(
        event_name,
        context.state.node,
        handler,
        capture,
        is_passive_event(event_name) ? true : void 0
      )
    );
    const type = (
      /** @type {AST.SvelteNode} */
      context.path.at(-1).type
    );
    if (type === "SvelteDocument" || type === "SvelteWindow" || type === "SvelteBody") {
      context.state.init.push(statement);
    } else {
      context.state.after_update.push(statement);
    }
  }
}
function build_event(event_name, node, handler, capture, passive) {
  return call(
    "$.event",
    literal2(event_name),
    node,
    handler,
    capture && true_instance,
    passive === void 0 ? void 0 : literal2(passive)
  );
}
function build_event_handler(node, metadata, context) {
  if (node === null) {
    return function_builder(
      null,
      [id("$$arg")],
      block([stmt(call("$.bubble_event.call", this_instance, id("$$props"), id("$$arg")))])
    );
  }
  let handler = (
    /** @type {Expression} */
    context.visit(node)
  );
  if (handler.type === "ArrowFunctionExpression" || handler.type === "FunctionExpression") {
    return handler;
  }
  if (handler.type === "Identifier") {
    const binding = context.state.scope.get(handler.name);
    if (binding == null ? void 0 : binding.is_function()) {
      return handler;
    }
    if (!dev && (binding == null ? void 0 : binding.declaration_kind) !== "import") {
      return handler;
    }
  }
  if (metadata.has_call) {
    const id2 = id(context.state.scope.generate("event_handler"));
    context.state.init.push(var_builder(id2, call("$.derived", thunk(handler))));
    handler = call("$.get", id2);
  }
  let call2 = call(member(handler, "apply", false, true), this_instance, id("$$args"));
  if (dev) {
    const loc = locator(
      /** @type {number} */
      node.start
    );
    const remove_parens = node.type === "CallExpression" && node.arguments.length === 0 && node.callee.type === "Identifier";
    call2 = call(
      "$.apply",
      thunk(handler),
      this_instance,
      id("$$args"),
      id(context.state.analysis.name),
      loc && array([literal2(loc.line), literal2(loc.column)]),
      has_side_effects(node) && true_instance,
      remove_parens && true_instance
    );
  }
  return function_builder(null, [rest(id("$$args"))], block([stmt(call2)]));
}
function has_side_effects(node) {
  if (node.type === "CallExpression" || node.type === "NewExpression" || node.type === "AssignmentExpression" || node.type === "UpdateExpression") {
    return true;
  }
  if (node.type === "SequenceExpression") {
    return node.expressions.some(has_side_effects);
  }
  return false;
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/Attribute.js
function Attribute2(node, context) {
  if (is_event_attribute(node)) {
    visit_event_attribute(node, context);
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/AwaitBlock.js
function AwaitBlock3(node, context) {
  context.state.template.push_comment();
  const expression = thunk(
    /** @type {Expression} */
    context.visit(node.expression)
  );
  let then_block;
  let catch_block;
  if (node.then) {
    const then_context = {
      ...context,
      state: { ...context.state, transform: { ...context.state.transform } }
    };
    const argument = node.value && create_derived_block_argument(node.value, then_context);
    const args = [id("$$anchor")];
    if (argument) args.push(argument.id);
    const declarations = (argument == null ? void 0 : argument.declarations) ?? [];
    const block2 = (
      /** @type {BlockStatement} */
      then_context.visit(node.then, then_context.state)
    );
    then_block = arrow(args, block([...declarations, ...block2.body]));
  }
  if (node.catch) {
    const catch_context = { ...context, state: { ...context.state } };
    const argument = node.error && create_derived_block_argument(node.error, catch_context);
    const args = [id("$$anchor")];
    if (argument) args.push(argument.id);
    const declarations = (argument == null ? void 0 : argument.declarations) ?? [];
    const block2 = (
      /** @type {BlockStatement} */
      catch_context.visit(node.catch, catch_context.state)
    );
    catch_block = arrow(args, block([...declarations, ...block2.body]));
  }
  context.state.init.push(
    stmt(
      call(
        "$.await",
        context.state.node,
        expression,
        node.pending ? arrow(
          [id("$$anchor")],
          /** @type {BlockStatement} */
          context.visit(node.pending)
        ) : null_instance,
        then_block,
        catch_block
      )
    )
  );
}
function create_derived_block_argument(node, context) {
  if (node.type === "Identifier") {
    context.state.transform[node.name] = { read: get_value };
    return { id: node, declarations: null };
  }
  const pattern = (
    /** @type {Pattern} */
    context.visit(node)
  );
  const identifiers = extract_identifiers(node);
  const id2 = id("$$source");
  const value = id("$$value");
  const block2 = block([
    var_builder(pattern, call("$.get", id2)),
    return_builder(object(identifiers.map((identifier) => prop("init", identifier, identifier))))
  ]);
  const declarations = [var_builder(value, create_derived(context.state, thunk(block2)))];
  for (const id3 of identifiers) {
    context.state.transform[id3.name] = { read: get_value };
    declarations.push(
      var_builder(id3, create_derived(context.state, thunk(member(call("$.get", value), id3))))
    );
  }
  return { id: id2, declarations };
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/BinaryExpression.js
function BinaryExpression(node, context) {
  if (dev) {
    const operator = node.operator;
    if (operator === "===" || operator === "!==") {
      return call(
        "$.strict_equals",
        /** @type {Expression} */
        context.visit(node.left),
        /** @type {Expression} */
        context.visit(node.right),
        operator === "!==" && false_instance
      );
    }
    if (operator === "==" || operator === "!=") {
      return call(
        "$.equals",
        /** @type {Expression} */
        context.visit(node.left),
        /** @type {Expression} */
        context.visit(node.right),
        operator === "!=" && false_instance
      );
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/fragment.js
function process_children2(nodes, initial, is_element, { visit, state }) {
  const within_bound_contenteditable = state.metadata.bound_contenteditable;
  let prev = initial;
  let skipped = 0;
  let sequence3 = [];
  function get_node(is_text) {
    if (skipped === 0) {
      return prev(is_text);
    }
    return call(
      "$.sibling",
      prev(false),
      (is_text || skipped !== 1) && literal2(skipped),
      is_text && true_instance
    );
  }
  function flush_node(is_text, name) {
    const expression = get_node(is_text);
    let id2 = expression;
    if (id2.type !== "Identifier") {
      id2 = id(state.scope.generate(name));
      state.init.push(var_builder(id2, expression));
    }
    prev = () => id2;
    skipped = 1;
    return id2;
  }
  function flush_sequence(sequence4) {
    if (sequence4.every((node) => node.type === "Text")) {
      skipped += 1;
      state.template.push_text(sequence4);
      return;
    }
    state.template.push_text([{ type: "Text", data: " ", raw: " ", start: -1, end: -1 }]);
    const { has_state, value } = build_template_chunk(sequence4, visit, state);
    const is_text = sequence4.length === 1;
    const id2 = flush_node(is_text, "text");
    const update2 = stmt(call("$.set_text", id2, value));
    if (has_state && !within_bound_contenteditable) {
      state.update.push(update2);
    } else {
      state.init.push(stmt(assignment("=", member(id2, "nodeValue"), value)));
    }
  }
  for (const node of nodes) {
    if (node.type === "Text" || node.type === "ExpressionTag") {
      sequence3.push(node);
    } else {
      if (sequence3.length > 0) {
        flush_sequence(sequence3);
        sequence3 = [];
      }
      let child_state = state;
      if (is_static_element2(node, state)) {
        skipped += 1;
      } else if (node.type === "EachBlock" && nodes.length === 1 && is_element) {
        node.metadata.is_controlled = true;
      } else {
        const id2 = flush_node(false, node.type === "RegularElement" ? node.name : "node");
        child_state = { ...state, node: id2 };
      }
      visit(node, child_state);
    }
  }
  if (sequence3.length > 0) {
    flush_sequence(sequence3);
  }
  if (skipped > 1) {
    skipped -= 1;
    state.init.push(stmt(call("$.next", skipped !== 1 && literal2(skipped))));
  }
}
function is_static_element2(node, state) {
  if (node.type !== "RegularElement") return false;
  if (node.fragment.metadata.dynamic) return false;
  if (is_custom_element_node(node)) return false;
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute") {
      return false;
    }
    if (is_event_attribute(attribute)) {
      return false;
    }
    if (cannot_be_set_statically(attribute.name)) {
      return false;
    }
    if (attribute.name === "dir") {
      return false;
    }
    if (["input", "textarea"].includes(node.name) && ["value", "checked"].includes(attribute.name)) {
      return false;
    }
    if (node.name === "option" && attribute.name === "value") {
      return false;
    }
    if (node.name === "img" && attribute.name === "loading") {
      return false;
    }
    if (attribute.value !== true && !is_text_attribute(attribute)) {
      return false;
    }
  }
  return true;
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/RegularElement.js
function RegularElement3(node, context) {
  var _a2, _b;
  context.state.template.push_element(node.name, node.start);
  if (node.name === "noscript") {
    context.state.template.pop_element();
    return;
  }
  const is_custom_element = is_custom_element_node(node);
  (_a2 = context.state.template).needs_import_node || (_a2.needs_import_node = node.name === "video" || is_custom_element);
  (_b = context.state.template).contains_script_tag || (_b.contains_script_tag = node.name === "script");
  const attributes = [];
  const class_directives = [];
  const style_directives = [];
  const other_directives = [];
  const lets = [];
  const lookup = /* @__PURE__ */ new Map();
  const bindings = /* @__PURE__ */ new Map();
  let has_spread = node.metadata.has_spread;
  let has_use = false;
  for (const attribute of node.attributes) {
    switch (attribute.type) {
      case "AnimateDirective":
        other_directives.push(attribute);
        break;
      case "Attribute":
        if (attribute.name === "is" && context.state.metadata.namespace === "html") {
          const { value } = build_attribute_value2(attribute.value, context);
          if (value.type === "Literal" && typeof value.value === "string") {
            context.state.template.set_prop("is", value.value);
            continue;
          }
        }
        attributes.push(attribute);
        lookup.set(attribute.name, attribute);
        break;
      case "BindDirective":
        bindings.set(attribute.name, attribute);
        other_directives.push(attribute);
        break;
      case "ClassDirective":
        class_directives.push(attribute);
        break;
      case "LetDirective":
        lets.push(
          /** @type {ExpressionStatement} */
          context.visit(attribute)
        );
        break;
      case "OnDirective":
        other_directives.push(attribute);
        break;
      case "SpreadAttribute":
        attributes.push(attribute);
        break;
      case "StyleDirective":
        style_directives.push(attribute);
        break;
      case "TransitionDirective":
        other_directives.push(attribute);
        break;
      case "UseDirective":
        has_use = true;
        other_directives.push(attribute);
        break;
      case "AttachTag":
        other_directives.push(attribute);
        break;
    }
  }
  const element_state = { ...context.state, init: [], after_update: [] };
  for (const attribute of other_directives) {
    if (attribute.type === "OnDirective") {
      const handler = (
        /** @type {Expression} */
        context.visit(attribute)
      );
      if (has_use) {
        element_state.init.push(stmt(call("$.effect", thunk(handler))));
      } else {
        element_state.after_update.push(stmt(handler));
      }
    } else {
      context.visit(attribute, element_state);
    }
  }
  if (node.name === "input") {
    const has_value_attribute = attributes.some(
      (attribute) => attribute.type === "Attribute" && (attribute.name === "value" || attribute.name === "checked") && !is_text_attribute(attribute)
    );
    const has_default_value_attribute = attributes.some(
      (attribute) => attribute.type === "Attribute" && (attribute.name === "defaultValue" || attribute.name === "defaultChecked")
    );
    if (!has_default_value_attribute && (has_spread || bindings.has("value") || bindings.has("checked") || bindings.has("group") || !bindings.has("group") && has_value_attribute)) {
      context.state.init.push(stmt(call("$.remove_input_defaults", context.state.node)));
    }
  }
  if (node.name === "textarea") {
    const attribute = lookup.get("value") ?? lookup.get("checked");
    const needs_content_reset = attribute && !is_text_attribute(attribute);
    if (has_spread || bindings.has("value") || needs_content_reset) {
      context.state.init.push(stmt(call("$.remove_textarea_child", context.state.node)));
    }
  }
  if (node.name === "select" && bindings.has("value")) {
    setup_select_synchronization(
      /** @type {AST.BindDirective} */
      bindings.get("value"),
      context
    );
  }
  context.state.init.push(...lets);
  const node_id = context.state.node;
  if (has_spread) {
    build_attribute_effect(attributes, class_directives, style_directives, context, node, node_id);
  } else {
    const needs_special_value_handling = node.name === "option" || node.name === "select" || bindings.has("group") || bindings.has("checked");
    for (
      const attribute of
      /** @type {AST.Attribute[]} */
      attributes
    ) {
      if (is_event_attribute(attribute)) {
        visit_event_attribute(attribute, context);
        continue;
      }
      if (needs_special_value_handling && attribute.name === "value") {
        build_element_special_value_attribute(node.name, node_id, attribute, context);
        continue;
      }
      const name = get_attribute_name2(node, attribute);
      if (!is_custom_element && !cannot_be_set_statically(attribute.name) && (attribute.value === true || is_text_attribute(attribute)) && (name !== "class" || class_directives.length === 0) && (name !== "style" || style_directives.length === 0)) {
        let value = is_text_attribute(attribute) ? attribute.value[0].data : true;
        if (name === "class" && node.metadata.scoped && context.state.analysis.css.hash) {
          if (value === true || value === "") {
            value = context.state.analysis.css.hash;
          } else {
            value += " " + context.state.analysis.css.hash;
          }
        }
        if (name !== "class" || value) {
          context.state.template.set_prop(
            attribute.name,
            is_boolean_attribute(name) && value === true ? void 0 : value === true ? "" : value
          );
        }
      } else if (name === "autofocus") {
        let { value } = build_attribute_value2(attribute.value, context);
        context.state.init.push(stmt(call("$.autofocus", node_id, value)));
      } else if (name === "class") {
        const is_html = context.state.metadata.namespace === "html" && node.name !== "svg";
        build_set_class(node, node_id, attribute, class_directives, context, is_html);
      } else if (name === "style") {
        build_set_style(node_id, attribute, style_directives, context);
      } else if (is_custom_element) {
        build_custom_element_attribute_update_assignment(node_id, attribute, context);
      } else {
        const { value, has_state } = build_attribute_value2(
          attribute.value,
          context,
          (value2, metadata2) => metadata2.has_call ? get_expression_id(context.state.expressions, value2) : value2
        );
        const update2 = build_element_attribute_update(node, node_id, name, value, attributes);
        (has_state ? context.state.update : context.state.init).push(stmt(update2));
      }
    }
  }
  if (is_load_error_element(node.name) && (has_spread || has_use || lookup.has("onload") || lookup.has("onerror"))) {
    context.state.after_update.push(stmt(call("$.replay_events", node_id)));
  }
  const metadata = {
    ...context.state.metadata,
    namespace: determine_namespace_for_children(node, context.state.metadata.namespace)
  };
  if (bindings.has("innerHTML") || bindings.has("innerText") || bindings.has("textContent")) {
    const contenteditable = lookup.get("contenteditable");
    if (contenteditable && (contenteditable.value === true || is_text_attribute(contenteditable) && contenteditable.value[0].data === "true")) {
      metadata.bound_contenteditable = true;
    }
  }
  const state = {
    ...context.state,
    metadata,
    scope: (
      /** @type {Scope} */
      context.state.scopes.get(node.fragment)
    ),
    preserve_whitespace: context.state.preserve_whitespace || node.name === "pre" || node.name === "textarea"
  };
  const { hoisted, trimmed } = clean_nodes(
    node,
    node.fragment.nodes,
    context.path,
    state.metadata.namespace,
    state,
    node.name === "script" || state.preserve_whitespace,
    state.options.preserveComments
  );
  const child_state = { ...state, init: [], update: [], after_update: [] };
  for (const node2 of hoisted) {
    context.visit(node2, child_state);
  }
  const use_text_content = trimmed.every((node2) => node2.type === "Text" || node2.type === "ExpressionTag") && trimmed.every((node2) => node2.type === "Text" || !node2.metadata.expression.has_state) && trimmed.some((node2) => node2.type === "ExpressionTag");
  if (use_text_content) {
    const { value } = build_template_chunk(trimmed, context.visit, child_state);
    const empty_string = value.type === "Literal" && value.value === "";
    if (!empty_string) {
      child_state.init.push(
        stmt(assignment("=", member(context.state.node, "textContent"), value))
      );
    }
  } else {
    let arg = context.state.node;
    let needs_reset = trimmed.some((node2) => node2.type !== "Text");
    if (node.name === "template") {
      needs_reset = true;
      child_state.init.push(stmt(call("$.hydrate_template", arg)));
      arg = member(arg, "content");
    }
    process_children2(trimmed, (is_text) => call("$.child", arg, is_text && true_instance), true, {
      ...context,
      state: child_state
    });
    if (needs_reset) {
      child_state.init.push(stmt(call("$.reset", context.state.node)));
    }
  }
  if (node.fragment.nodes.some((node2) => node2.type === "SnippetBlock")) {
    context.state.init.push(
      block([
        ...child_state.init,
        ...element_state.init,
        child_state.update.length > 0 ? build_render_statement(child_state) : empty2,
        ...child_state.after_update,
        ...element_state.after_update
      ])
    );
  } else if (node.fragment.metadata.dynamic) {
    context.state.init.push(...child_state.init, ...element_state.init);
    context.state.update.push(...child_state.update);
    context.state.after_update.push(...child_state.after_update, ...element_state.after_update);
  } else {
    context.state.init.push(...element_state.init);
    context.state.after_update.push(...element_state.after_update);
  }
  if (lookup.has("dir")) {
    const dir = member(node_id, "dir");
    context.state.update.push(stmt(assignment("=", dir, dir)));
  }
  context.state.template.pop_element();
}
function setup_select_synchronization(value_binding, context) {
  if (context.state.analysis.runes) return;
  let bound = value_binding.expression;
  if (bound.type === "SequenceExpression") {
    return;
  }
  while (bound.type === "MemberExpression") {
    bound = /** @type {Identifier | MemberExpression} */
    bound.object;
  }
  const names = [];
  for (const [name, refs] of context.state.scope.references) {
    if (refs.length > 0 && // prevent infinite loop
    name !== bound.name) {
      names.push(name);
    }
  }
  const invalidator = call(
    "$.invalidate_inner_signals",
    thunk(
      block(
        names.map((name) => {
          const serialized = build_getter(id(name), context.state);
          return stmt(serialized);
        })
      )
    )
  );
  context.state.init.push(
    stmt(
      call(
        "$.template_effect",
        thunk(
          block([stmt(
            /** @type {Expression} */
            context.visit(bound)
          ), stmt(invalidator)])
        )
      )
    )
  );
}
function build_class_directives_object(class_directives, expressions, context) {
  let properties = [];
  let has_call_or_state = false;
  for (const d of class_directives) {
    const expression = (
      /** @type Expression */
      context.visit(d.expression)
    );
    properties.push(init2(d.name, expression));
    has_call_or_state || (has_call_or_state = d.metadata.expression.has_call || d.metadata.expression.has_state);
  }
  const directives = object(properties);
  return has_call_or_state ? get_expression_id(expressions, directives) : directives;
}
function build_style_directives_object(style_directives, expressions, context) {
  let normal_properties = [];
  let important_properties = [];
  for (const directive of style_directives) {
    const expression = directive.value === true ? build_getter({ name: directive.name, type: "Identifier" }, context.state) : build_attribute_value2(
      directive.value,
      context,
      (value, metadata) => metadata.has_call ? get_expression_id(expressions, value) : value
    ).value;
    const property = init2(directive.name, expression);
    if (directive.modifiers.includes("important")) {
      important_properties.push(property);
    } else {
      normal_properties.push(property);
    }
  }
  return important_properties.length ? array([object(normal_properties), object(important_properties)]) : object(normal_properties);
}
function build_element_attribute_update(element2, node_id, name, value, attributes) {
  if (name === "muted") {
    return assignment("=", member(node_id, id("muted")), value);
  }
  if (name === "value") {
    return call("$.set_value", node_id, value);
  }
  if (name === "checked") {
    return call("$.set_checked", node_id, value);
  }
  if (name === "selected") {
    return call("$.set_selected", node_id, value);
  }
  if (
    // If we would just set the defaultValue property, it would override the value property,
    // because it is set in the template which implicitly means it's also setting the default value,
    // and if one updates the default value while the input is pristine it will also update the
    // current value, which is not what we want, which is why we need to do some extra work.
    name === "defaultValue" && (attributes.some(
      (attr) => attr.type === "Attribute" && attr.name === "value" && is_text_attribute(attr)
    ) || element2.name === "textarea" && element2.fragment.nodes.length > 0)
  ) {
    return call("$.set_default_value", node_id, value);
  }
  if (
    // See defaultValue comment
    name === "defaultChecked" && attributes.some(
      (attr) => attr.type === "Attribute" && attr.name === "checked" && attr.value === true
    )
  ) {
    return call("$.set_default_checked", node_id, value);
  }
  if (is_dom_property(name)) {
    return assignment("=", member(node_id, name), value);
  }
  return call(
    name.startsWith("xlink") ? "$.set_xlink_attribute" : "$.set_attribute",
    node_id,
    literal2(name),
    value,
    is_ignored(element2, "hydration_attribute_changed") && true_instance
  );
}
function build_custom_element_attribute_update_assignment(node_id, attribute, context) {
  const { value, has_state } = build_attribute_value2(attribute.value, context);
  const call2 = call("$.set_custom_element_data", node_id, literal2(attribute.name), value);
  const update2 = has_state ? call("$.template_effect", thunk(call2)) : call2;
  context.state.init.push(stmt(update2));
}
function build_element_special_value_attribute(element2, node_id, attribute, context) {
  const state = context.state;
  const is_select_with_value = (
    // attribute.metadata.dynamic would give false negatives because even if the value does not change,
    // the inner options could still change, so we need to always treat it as reactive
    element2 === "select" && attribute.value !== true && !is_text_attribute(attribute)
  );
  const { value, has_state } = build_attribute_value2(
    attribute.value,
    context,
    (value2, metadata) => metadata.has_call ? (
      // if is a select with value we will also invoke `init_select` which need a reference before the template effect so we memoize separately
      is_select_with_value ? memoize_expression(state, value2) : get_expression_id(state.expressions, value2)
    ) : value2
  );
  const evaluated = context.state.scope.evaluate(value);
  const assignment2 = assignment("=", member(node_id, "__value"), value);
  const inner_assignment = assignment(
    "=",
    member(node_id, "value"),
    evaluated.is_defined ? assignment2 : logical("??", assignment2, literal2(""))
  );
  const update2 = stmt(
    is_select_with_value ? sequence([
      inner_assignment,
      // This ensures a one-way street to the DOM in case it's <select {value}>
      // and not <select bind:value>. We need it in addition to $.init_select
      // because the select value is not reflected as an attribute, so the
      // mutation observer wouldn't notice.
      call("$.select_option", node_id, value)
    ]) : inner_assignment
  );
  if (is_select_with_value) {
    state.init.push(stmt(call("$.init_select", node_id, thunk(value))));
  }
  if (has_state) {
    const id2 = state.scope.generate(`${node_id.name}_value`);
    build_update_assignment(
      state,
      id2,
      // `<option>` is a special case: The value property reflects to the DOM. If the value is set to undefined,
      // that means the value should be set to the empty string. To be able to do that when the value is
      // initially undefined, we need to set a value that is guaranteed to be different.
      element2 === "option" ? object([]) : void 0,
      value,
      update2
    );
  } else {
    state.init.push(update2);
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/element.js
function build_attribute_effect(attributes, class_directives, style_directives, context, element2, element_id) {
  const values = [];
  const expressions = [];
  function memoize(value) {
    return id(`$${expressions.push(value) - 1}`);
  }
  for (const attribute of attributes) {
    if (attribute.type === "Attribute") {
      const { value } = build_attribute_value2(
        attribute.value,
        context,
        (value2, metadata) => metadata.has_call ? memoize(value2) : value2
      );
      if (is_event_attribute(attribute) && (value.type === "ArrowFunctionExpression" || value.type === "FunctionExpression")) {
        const id2 = context.state.scope.generate("event_handler");
        context.state.init.push(var_builder(id2, value));
        values.push(init2(attribute.name, id(id2)));
      } else {
        values.push(init2(attribute.name, value));
      }
    } else {
      let value = (
        /** @type {Expression} */
        context.visit(attribute)
      );
      if (attribute.metadata.expression.has_call) {
        value = memoize(value);
      }
      values.push(spread(value));
    }
  }
  if (class_directives.length) {
    values.push(
      prop(
        "init",
        array([id("$.CLASS")]),
        build_class_directives_object(class_directives, expressions, context)
      )
    );
  }
  if (style_directives.length) {
    values.push(
      prop(
        "init",
        array([id("$.STYLE")]),
        build_style_directives_object(style_directives, expressions, context)
      )
    );
  }
  context.state.init.push(
    stmt(
      call(
        "$.attribute_effect",
        element_id,
        arrow(
          expressions.map((_, i) => id(`$${i}`)),
          object(values)
        ),
        expressions.length > 0 && array(expressions.map((expression) => thunk(expression))),
        element2.metadata.scoped && context.state.analysis.css.hash !== "" && literal2(context.state.analysis.css.hash),
        is_ignored(element2, "hydration_attribute_changed") && true_instance
      )
    )
  );
}
function build_attribute_value2(value, context, memoize = (value2) => value2) {
  if (value === true) {
    return { value: true_instance, has_state: false };
  }
  if (!Array.isArray(value) || value.length === 1) {
    const chunk = Array.isArray(value) ? value[0] : value;
    if (chunk.type === "Text") {
      return { value: literal2(chunk.data), has_state: false };
    }
    let expression = (
      /** @type {Expression} */
      context.visit(chunk.expression)
    );
    return {
      value: memoize(expression, chunk.metadata.expression),
      has_state: chunk.metadata.expression.has_state
    };
  }
  return build_template_chunk(value, context.visit, context.state, memoize);
}
function get_attribute_name2(element2, attribute) {
  if (!element2.metadata.svg && !element2.metadata.mathml) {
    return normalize_attribute(attribute.name);
  }
  return attribute.name;
}
function build_set_class(element2, node_id, attribute, class_directives, context, is_html) {
  let { value, has_state } = build_attribute_value2(attribute.value, context, (value2, metadata) => {
    if (attribute.metadata.needs_clsx) {
      value2 = call("$.clsx", value2);
    }
    return metadata.has_call ? get_expression_id(context.state.expressions, value2) : value2;
  });
  let previous_id;
  let prev;
  let next2;
  if (class_directives.length) {
    next2 = build_class_directives_object(class_directives, context.state.expressions, context);
    has_state || (has_state = class_directives.some((d) => d.metadata.expression.has_state));
    if (has_state) {
      previous_id = id(context.state.scope.generate("classes"));
      context.state.init.push(declaration("let", [declarator(previous_id)]));
      prev = previous_id;
    } else {
      prev = object([]);
    }
  }
  let css_hash;
  if (element2.metadata.scoped && context.state.analysis.css.hash) {
    if (value.type === "Literal" && (value.value === "" || value.value === null)) {
      value = literal2(context.state.analysis.css.hash);
    } else if (value.type === "Literal" && typeof value.value === "string") {
      value = literal2(escape_html(value.value, true) + " " + context.state.analysis.css.hash);
    } else {
      css_hash = literal2(context.state.analysis.css.hash);
    }
  }
  if (!css_hash && next2) {
    css_hash = null_instance;
  }
  let set_class = call(
    "$.set_class",
    node_id,
    is_html ? literal2(1) : literal2(0),
    value,
    css_hash,
    prev,
    next2
  );
  if (previous_id) {
    set_class = assignment("=", previous_id, set_class);
  }
  (has_state ? context.state.update : context.state.init).push(stmt(set_class));
}
function build_set_style(node_id, attribute, style_directives, context) {
  let { value, has_state } = build_attribute_value2(
    attribute.value,
    context,
    (value2, metadata) => metadata.has_call ? get_expression_id(context.state.expressions, value2) : value2
  );
  let previous_id;
  let prev;
  let next2;
  if (style_directives.length) {
    next2 = build_style_directives_object(style_directives, context.state.expressions, context);
    has_state || (has_state = style_directives.some((d) => d.metadata.expression.has_state));
    if (has_state) {
      previous_id = id(context.state.scope.generate("styles"));
      context.state.init.push(declaration("let", [declarator(previous_id)]));
      prev = previous_id;
    } else {
      prev = object([]);
    }
  }
  let set_style = call("$.set_style", node_id, value, prev, next2);
  if (previous_id) {
    set_style = assignment("=", previous_id, set_style);
  }
  (has_state ? context.state.update : context.state.init).push(stmt(set_style));
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/BindDirective.js
function BindDirective2(node, context) {
  var _a2;
  const expression = (
    /** @type {Expression} */
    context.visit(node.expression)
  );
  const property = binding_properties[node.name];
  const parent = (
    /** @type {AST.SvelteNode} */
    context.path.at(-1)
  );
  let get2, set2;
  if (expression.type === "SequenceExpression") {
    [get2, set2] = expression.expressions;
  } else {
    if (dev && context.state.analysis.runes && expression.type === "MemberExpression" && (node.name !== "this" || context.path.some(
      ({ type }) => type === "IfBlock" || type === "EachBlock" || type === "AwaitBlock" || type === "KeyBlock"
    )) && !is_ignored(node, "binding_property_non_reactive")) {
      validate_binding(context.state, node, expression);
    }
    get2 = thunk(expression);
    set2 = unthunk(
      arrow(
        [id("$$value")],
        /** @type {Expression} */
        context.visit(
          assignment(
            "=",
            /** @type {Pattern} */
            node.expression,
            id("$$value")
          )
        )
      )
    );
    if (get2 === set2) {
      set2 = void 0;
    }
  }
  let call2;
  if (property == null ? void 0 : property.event) {
    call2 = call(
      "$.bind_property",
      literal2(node.name),
      literal2(property.event),
      context.state.node,
      set2 ?? get2,
      property.bidirectional && get2
    );
  } else {
    switch (node.name) {
      case "online":
        call2 = call(`$.bind_online`, set2 ?? get2);
        break;
      case "scrollX":
      case "scrollY":
        call2 = call(
          "$.bind_window_scroll",
          literal2(node.name === "scrollX" ? "x" : "y"),
          get2,
          set2
        );
        break;
      case "innerWidth":
      case "innerHeight":
      case "outerWidth":
      case "outerHeight":
        call2 = call("$.bind_window_size", literal2(node.name), set2 ?? get2);
        break;
      case "activeElement":
        call2 = call("$.bind_active_element", set2 ?? get2);
        break;
      case "muted":
        call2 = call(`$.bind_muted`, context.state.node, get2, set2);
        break;
      case "paused":
        call2 = call(`$.bind_paused`, context.state.node, get2, set2);
        break;
      case "volume":
        call2 = call(`$.bind_volume`, context.state.node, get2, set2);
        break;
      case "playbackRate":
        call2 = call(`$.bind_playback_rate`, context.state.node, get2, set2);
        break;
      case "currentTime":
        call2 = call(`$.bind_current_time`, context.state.node, get2, set2);
        break;
      case "buffered":
        call2 = call(`$.bind_buffered`, context.state.node, set2 ?? get2);
        break;
      case "played":
        call2 = call(`$.bind_played`, context.state.node, set2 ?? get2);
        break;
      case "seekable":
        call2 = call(`$.bind_seekable`, context.state.node, set2 ?? get2);
        break;
      case "seeking":
        call2 = call(`$.bind_seeking`, context.state.node, set2 ?? get2);
        break;
      case "ended":
        call2 = call(`$.bind_ended`, context.state.node, set2 ?? get2);
        break;
      case "readyState":
        call2 = call(`$.bind_ready_state`, context.state.node, set2 ?? get2);
        break;
      case "contentRect":
      case "contentBoxSize":
      case "borderBoxSize":
      case "devicePixelContentBoxSize":
        call2 = call(
          "$.bind_resize_observer",
          context.state.node,
          literal2(node.name),
          set2 ?? get2
        );
        break;
      case "clientWidth":
      case "clientHeight":
      case "offsetWidth":
      case "offsetHeight":
        call2 = call("$.bind_element_size", context.state.node, literal2(node.name), set2 ?? get2);
        break;
      case "value": {
        if ((parent == null ? void 0 : parent.type) === "RegularElement" && parent.name === "select") {
          call2 = call(`$.bind_select_value`, context.state.node, get2, set2);
        } else {
          call2 = call(`$.bind_value`, context.state.node, get2, set2);
        }
        break;
      }
      case "files":
        call2 = call(`$.bind_files`, context.state.node, get2, set2);
        break;
      case "this":
        call2 = build_bind_this(node.expression, context.state.node, context);
        break;
      case "textContent":
      case "innerHTML":
      case "innerText":
        call2 = call(
          "$.bind_content_editable",
          literal2(node.name),
          context.state.node,
          get2,
          set2
        );
        break;
      case "checked":
        call2 = call(`$.bind_checked`, context.state.node, get2, set2);
        break;
      case "focused":
        call2 = call(`$.bind_focused`, context.state.node, set2 ?? get2);
        break;
      case "group": {
        const indexes = node.metadata.parent_each_blocks.map((each) => {
          return each.metadata.keyed && each.index ? call("$.get", each.metadata.index) : each.metadata.index;
        });
        let group_getter = get2;
        if ((parent == null ? void 0 : parent.type) === "RegularElement") {
          const value = (
            /** @type {any[]} */
            /** @type {AST.Attribute} */
            (_a2 = parent.attributes.find(
              (a) => a.type === "Attribute" && a.name === "value" && !is_text_attribute(a) && a.value !== true
            )) == null ? void 0 : _a2.value
          );
          if (value !== void 0) {
            group_getter = thunk(
              block([stmt(build_attribute_value2(value, context).value), return_builder(expression)])
            );
          }
        }
        call2 = call(
          "$.bind_group",
          node.metadata.binding_group_name,
          array(indexes),
          context.state.node,
          group_getter,
          set2 ?? get2
        );
        break;
      }
      default:
        throw new Error("unknown binding " + node.name);
    }
  }
  if (node.name === "this") {
    context.state.init.push(stmt(call2));
  } else {
    const has_use = parent.type === "RegularElement" && parent.attributes.find((a) => a.type === "UseDirective");
    if (has_use) {
      context.state.init.push(stmt(call("$.effect", thunk(call2))));
    } else {
      context.state.after_update.push(stmt(call2));
    }
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/BlockStatement.js
function BlockStatement(node, context) {
  add_state_transformers(context);
  const tracing = context.state.scope.tracing;
  if (tracing !== null) {
    const parent = (
      /** @type {ArrowFunctionExpression | FunctionDeclaration | FunctionExpression} */
      context.path.at(-1)
    );
    const is_async = parent.async;
    const call2 = call(
      "$.trace",
      /** @type {Expression} */
      tracing,
      thunk(block(node.body.map((n2) => (
        /** @type {Statement} */
        context.visit(n2)
      ))), is_async)
    );
    return block([return_builder(is_async ? await_builder(call2) : call2)]);
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/BreakStatement.js
function BreakStatement(node, context) {
  if (context.state.analysis.runes || !node.label || node.label.name !== "$") {
    return;
  }
  const in_reactive_statement = context.path[1].type === "LabeledStatement" && context.path[1].label.name === "$";
  if (in_reactive_statement) {
    return return_builder();
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/CallExpression.js
function CallExpression3(node, context) {
  const rune = get_rune(node, context.state.scope);
  switch (rune) {
    case "$host":
      return id("$$props.$$host");
    case "$effect.tracking":
      return call("$.effect_tracking");
    case "$state":
    case "$state.raw": {
      let arg = node.arguments[0];
      let value = void 0;
      if (arg) {
        value = /** @type {Expression} */
        context.visit(node.arguments[0]);
        if (rune === "$state" && should_proxy(
          /** @type {Expression} */
          arg,
          context.state.scope
        )) {
          value = call("$.proxy", value);
        }
      }
      return call("$.state", value);
    }
    case "$derived":
    case "$derived.by": {
      let fn = (
        /** @type {Expression} */
        context.visit(node.arguments[0])
      );
      if (rune === "$derived") fn = thunk(fn);
      return call("$.derived", fn);
    }
    case "$state.snapshot":
      return call(
        "$.snapshot",
        /** @type {Expression} */
        context.visit(node.arguments[0]),
        is_ignored(node, "state_snapshot_uncloneable") && true_instance
      );
    case "$effect.root":
      return call(
        "$.effect_root",
        .../** @type {Expression[]} */
        node.arguments.map((arg) => context.visit(arg))
      );
    case "$inspect":
    case "$inspect().with":
      return transform_inspect_rune(node, context);
  }
  if (dev && node.callee.type === "MemberExpression" && node.callee.object.type === "Identifier" && node.callee.object.name === "console" && context.state.scope.get("console") === null && node.callee.property.type === "Identifier" && ["debug", "dir", "error", "group", "groupCollapsed", "info", "log", "trace", "warn"].includes(
    node.callee.property.name
  ) && node.arguments.some((arg) => arg.type !== "Literal")) {
    return call(
      node.callee,
      spread(
        call(
          "$.log_if_contains_state",
          literal2(node.callee.property.name),
          .../** @type {Expression[]} */
          node.arguments.map((arg) => context.visit(arg))
        )
      )
    );
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/ClassBody.js
function ClassBody3(node, context) {
  const state_fields = context.state.analysis.classes.get(node);
  if (!state_fields) {
    context.next();
    return;
  }
  const body = [];
  const child_state = { ...context.state, state_fields };
  for (const [name, field] of state_fields) {
    if (name[0] === "#") {
      continue;
    }
    if (field.node.type === "AssignmentExpression") {
      const member2 = member(this_instance, field.key);
      const should_proxy2 = field.type === "$state" && true;
      const key2 = key(name);
      body.push(
        prop_def(field.key, null),
        method("get", key2, [], [return_builder(call("$.get", member2))]),
        method(
          "set",
          key2,
          [id("value")],
          [stmt(call("$.set", member2, id("value"), should_proxy2 && true_instance))]
        )
      );
    }
  }
  for (const definition of node.body) {
    if (definition.type !== "PropertyDefinition") {
      body.push(
        /** @type {MethodDefinition | StaticBlock} */
        context.visit(definition, child_state)
      );
      continue;
    }
    const name = get_name(definition.key);
    const field = name && /** @type {StateField} */
    state_fields.get(name);
    if (!field) {
      body.push(
        /** @type {PropertyDefinition} */
        context.visit(definition, child_state)
      );
      continue;
    }
    if (name[0] === "#") {
      body.push(
        /** @type {PropertyDefinition} */
        context.visit(definition, child_state)
      );
    } else if (field.node === definition) {
      const member2 = member(this_instance, field.key);
      const should_proxy2 = field.type === "$state" && true;
      body.push(
        prop_def(
          field.key,
          /** @type {CallExpression} */
          context.visit(field.value, child_state)
        ),
        method("get", definition.key, [], [return_builder(call("$.get", member2))]),
        method(
          "set",
          definition.key,
          [id("value")],
          [stmt(call("$.set", member2, id("value"), should_proxy2 && true_instance))]
        )
      );
    }
  }
  return { ...node, body };
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/Comment.js
function Comment(node, context) {
  context.state.template.push_comment(node.data);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/component.js
function build_component(node, component_name, context, anchor = context.state.node) {
  var _a2, _b;
  const props_and_spreads = [];
  const delayed_props = [];
  const lets = [];
  const states = {
    default: {
      ...context.state,
      scope: node.metadata.scopes.default,
      transform: { ...context.state.transform }
    }
  };
  const children = {};
  const events = {};
  const custom_css_props = [];
  let bind_this = null;
  const binding_initializers = [];
  let slot_scope_applies_to_itself = !!determine_slot(node);
  let has_children_prop = false;
  function push_prop(prop2, delay = false) {
    const do_push = () => {
      const current2 = props_and_spreads.at(-1);
      const current_is_props = Array.isArray(current2);
      const props = current_is_props ? current2 : [];
      props.push(prop2);
      if (!current_is_props) {
        props_and_spreads.push(props);
      }
    };
    if (delay) {
      delayed_props.push(do_push);
    } else {
      do_push();
    }
  }
  if (slot_scope_applies_to_itself) {
    for (const attribute of node.attributes) {
      if (attribute.type === "LetDirective") {
        lets.push(
          /** @type {ExpressionStatement} */
          context.visit(attribute)
        );
      }
    }
  }
  for (const attribute of node.attributes) {
    if (attribute.type === "LetDirective") {
      if (!slot_scope_applies_to_itself) {
        lets.push(
          /** @type {ExpressionStatement} */
          context.visit(attribute, states.default)
        );
      }
    } else if (attribute.type === "OnDirective") {
      if (!attribute.expression) {
        context.state.analysis.needs_props = true;
      }
      let handler = build_event_handler(
        attribute.expression,
        attribute.metadata.expression,
        context
      );
      if (attribute.modifiers.includes("once")) {
        handler = call("$.once", handler);
      }
      (events[_a2 = attribute.name] || (events[_a2] = [])).push(handler);
    } else if (attribute.type === "SpreadAttribute") {
      const expression = (
        /** @type {Expression} */
        context.visit(attribute)
      );
      if (attribute.metadata.expression.has_state) {
        let value = expression;
        if (attribute.metadata.expression.has_call) {
          const id2 = id(context.state.scope.generate("spread_element"));
          context.state.init.push(var_builder(id2, call("$.derived", thunk(value))));
          value = call("$.get", id2);
        }
        props_and_spreads.push(thunk(value));
      } else {
        props_and_spreads.push(expression);
      }
    } else if (attribute.type === "Attribute") {
      if (attribute.name.startsWith("--")) {
        custom_css_props.push(
          init2(
            attribute.name,
            build_attribute_value2(
              attribute.value,
              context,
              (value2, metadata) => (
                // TODO put the derived in the local block
                metadata.has_call ? memoize_expression(context.state, value2) : value2
              )
            ).value
          )
        );
        continue;
      }
      if (attribute.name === "slot") {
        slot_scope_applies_to_itself = true;
      }
      if (attribute.name === "children") {
        has_children_prop = true;
      }
      const { value, has_state } = build_attribute_value2(
        attribute.value,
        context,
        (value2, metadata) => {
          if (!metadata.has_state) return value2;
          const should_wrap_in_derived = get_attribute_chunks(attribute.value).some((n2) => {
            return n2.type === "ExpressionTag" && n2.expression.type !== "Identifier" && n2.expression.type !== "MemberExpression";
          });
          return should_wrap_in_derived ? memoize_expression(context.state, value2) : value2;
        }
      );
      if (has_state) {
        push_prop(get(attribute.name, [return_builder(value)]));
      } else {
        push_prop(init2(attribute.name, value));
      }
    } else if (attribute.type === "BindDirective") {
      const expression = (
        /** @type {Expression} */
        context.visit(attribute.expression)
      );
      if (dev && attribute.name !== "this" && !is_ignored(node, "ownership_invalid_binding") && // bind:x={() => x.y, y => x.y = y} will be handled by the assignment expression binding validation
      attribute.expression.type !== "SequenceExpression") {
        const left = object2(attribute.expression);
        const binding = left && context.state.scope.get(left.name);
        if ((binding == null ? void 0 : binding.kind) === "bindable_prop" || (binding == null ? void 0 : binding.kind) === "prop") {
          context.state.analysis.needs_mutation_validation = true;
          binding_initializers.push(
            stmt(
              call(
                "$$ownership_validator.binding",
                literal2(binding.node.name),
                id(component_name),
                thunk(expression)
              )
            )
          );
        }
      }
      if (expression.type === "SequenceExpression") {
        if (attribute.name === "this") {
          bind_this = attribute.expression;
        } else {
          const [get2, set2] = expression.expressions;
          const get_id = id(context.state.scope.generate("bind_get"));
          const set_id = id(context.state.scope.generate("bind_set"));
          context.state.init.push(var_builder(get_id, get2));
          context.state.init.push(var_builder(set_id, set2));
          push_prop(get(attribute.name, [return_builder(call(get_id))]));
          push_prop(set(attribute.name, [stmt(call(set_id, id("$$value")))]));
        }
      } else {
        if (dev && expression.type === "MemberExpression" && context.state.analysis.runes && !is_ignored(node, "binding_property_non_reactive")) {
          validate_binding(context.state, attribute, expression);
        }
        if (attribute.name === "this") {
          bind_this = attribute.expression;
        } else {
          const is_store_sub = attribute.expression.type === "Identifier" && ((_b = context.state.scope.get(attribute.expression.name)) == null ? void 0 : _b.kind) === "store_sub";
          if (is_store_sub) {
            push_prop(
              get(attribute.name, [stmt(call("$.mark_store_binding")), return_builder(expression)]),
              true
            );
          } else {
            push_prop(get(attribute.name, [return_builder(expression)]), true);
          }
          const assignment2 = assignment(
            "=",
            /** @type {Pattern} */
            attribute.expression,
            id("$$value")
          );
          push_prop(
            set(attribute.name, [stmt(
              /** @type {Expression} */
              context.visit(assignment2)
            )]),
            true
          );
        }
      }
    } else if (attribute.type === "AttachTag") {
      const evaluated = context.state.scope.evaluate(attribute.expression);
      let expression = (
        /** @type {Expression} */
        context.visit(attribute.expression)
      );
      if (attribute.metadata.expression.has_state) {
        expression = arrow(
          [id("$$node")],
          call(
            evaluated.is_function ? expression : logical("||", expression, id("$.noop")),
            id("$$node")
          )
        );
      }
      push_prop(prop("get", call("$.attachment"), expression, true));
    }
  }
  delayed_props.forEach((fn2) => fn2());
  if (slot_scope_applies_to_itself) {
    context.state.init.push(...lets);
  }
  if (Object.keys(events).length > 0) {
    const events_expression = object(
      Object.keys(events).map(
        (name) => init2(name, events[name].length > 1 ? array(events[name]) : events[name][0])
      )
    );
    push_prop(init2("$$events", events_expression));
  }
  const snippet_declarations = [];
  const serialized_slots = [];
  for (const child of node.fragment.nodes) {
    if (child.type === "SnippetBlock") {
      context.visit(child, {
        ...context.state,
        init: snippet_declarations
      });
      push_prop(prop("init", child.expression, child.expression));
      serialized_slots.push(
        init2(child.expression.name === "children" ? "default" : child.expression.name, true_instance)
      );
      continue;
    }
    let slot_name = determine_slot(child) ?? "default";
    (children[slot_name] || (children[slot_name] = [])).push(child);
  }
  for (const slot_name of Object.keys(children)) {
    const block2 = (
      /** @type {BlockStatement} */
      context.visit(
        {
          ...node.fragment,
          // @ts-expect-error
          nodes: children[slot_name]
        },
        slot_name === "default" ? slot_scope_applies_to_itself ? context.state : states.default : {
          ...context.state,
          scope: node.metadata.scopes[slot_name],
          transform: { ...context.state.transform }
        }
      )
    );
    if (block2.body.length === 0) continue;
    const slot_fn = arrow(
      [id("$$anchor"), id("$$slotProps")],
      block([
        ...slot_name === "default" && !slot_scope_applies_to_itself ? lets : [],
        ...block2.body
      ])
    );
    if (slot_name === "default" && !has_children_prop) {
      if (lets.length === 0 && children.default.every(
        (node2) => node2.type !== "SvelteFragment" || !node2.attributes.some((attr) => attr.type === "LetDirective")
      )) {
        push_prop(
          init2(
            "children",
            dev ? call("$.wrap_snippet", id(context.state.analysis.name), slot_fn) : slot_fn
          )
        );
        serialized_slots.push(init2(slot_name, true_instance));
      } else {
        serialized_slots.push(init2(slot_name, slot_fn));
        push_prop(init2("children", id("$.invalid_default_snippet")));
      }
    } else {
      serialized_slots.push(init2(slot_name, slot_fn));
    }
  }
  if (serialized_slots.length > 0) {
    push_prop(init2("$$slots", object(serialized_slots)));
  }
  if (!context.state.analysis.runes && node.attributes.some((attribute) => attribute.type === "BindDirective")) {
    push_prop(init2("$$legacy", true_instance));
  }
  const props_expression = props_and_spreads.length === 0 || props_and_spreads.length === 1 && Array.isArray(props_and_spreads[0]) ? object(
    /** @type {Property[]} */
    props_and_spreads[0] || []
  ) : call(
    "$.spread_props",
    ...props_and_spreads.map((p) => Array.isArray(p) ? object(p) : p)
  );
  let fn = (node_id) => {
    return call(
      // TODO We can remove this ternary once we remove legacy mode, since in runes mode dynamic components
      // will be handled separately through the `$.component` function, and then the component name will
      // always be referenced through just the identifier here.
      node.type === "SvelteComponent" ? component_name : (
        /** @type {Expression} */
        context.visit(member_id(component_name))
      ),
      node_id,
      props_expression
    );
  };
  if (bind_this !== null) {
    const prev = fn;
    fn = (node_id) => {
      return build_bind_this(bind_this, prev(node_id), context);
    };
  }
  const statements = [...snippet_declarations];
  if (node.type === "SvelteComponent") {
    const prev = fn;
    fn = (node_id) => {
      return call(
        "$.component",
        node_id,
        thunk(
          /** @type {Expression} */
          context.visit(node.expression)
        ),
        arrow(
          [id("$$anchor"), id(component_name)],
          block([...binding_initializers, stmt(prev(id("$$anchor")))])
        )
      );
    };
  } else {
    statements.push(...binding_initializers);
  }
  if (Object.keys(custom_css_props).length > 0) {
    if (context.state.metadata.namespace === "svg") {
      context.state.template.push_element("g", node.start);
    } else {
      context.state.template.push_element("svelte-css-wrapper", node.start);
      context.state.template.set_prop("style", "display: contents");
    }
    context.state.template.push_comment();
    context.state.template.pop_element();
    statements.push(
      stmt(call("$.css_props", anchor, thunk(object(custom_css_props)))),
      stmt(fn(member(anchor, "lastChild"))),
      stmt(call("$.reset", anchor))
    );
  } else {
    context.state.template.push_comment();
    statements.push(stmt(fn(anchor)));
  }
  return statements.length > 1 ? block(statements) : statements[0];
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/Component.js
function Component3(node, context) {
  if (node.metadata.dynamic) {
    const component2 = build_component(node, "$$component", context, id("$$anchor"));
    context.state.init.push(
      stmt(
        call(
          "$.component",
          context.state.node,
          // TODO use untrack here to not update when binding changes?
          // Would align with Svelte 4 behavior, but it's arguably nicer/expected to update this
          thunk(
            /** @type {Expression} */
            context.visit(member_id(node.name))
          ),
          arrow([id("$$anchor"), id("$$component")], block([component2]))
        )
      )
    );
    return;
  }
  const component = build_component(node, node.name, context);
  context.state.init.push(component);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/ConstTag.js
function ConstTag3(node, context) {
  const declaration2 = node.declaration.declarations[0];
  if (declaration2.id.type === "Identifier") {
    context.state.init.push(
      const_builder(
        declaration2.id,
        create_derived(
          context.state,
          thunk(
            /** @type {Expression} */
            context.visit(declaration2.init)
          )
        )
      )
    );
    context.state.transform[declaration2.id.name] = { read: get_value };
    if (dev) {
      context.state.init.push(stmt(call("$.get", declaration2.id)));
    }
  } else {
    const identifiers = extract_identifiers(declaration2.id);
    const tmp = id(context.state.scope.generate("computed_const"));
    const transform = { ...context.state.transform };
    for (const node2 of identifiers) {
      delete transform[node2.name];
    }
    const child_state = { ...context.state, transform };
    const fn = arrow(
      [],
      block([
        const_builder(
          /** @type {Pattern} */
          context.visit(declaration2.id, child_state),
          /** @type {Expression} */
          context.visit(declaration2.init, child_state)
        ),
        return_builder(object(identifiers.map((node2) => prop("init", node2, node2))))
      ])
    );
    context.state.init.push(const_builder(tmp, create_derived(context.state, fn)));
    if (dev) {
      context.state.init.push(stmt(call("$.get", tmp)));
    }
    for (const node2 of identifiers) {
      context.state.transform[node2.name] = {
        read: (node3) => member(call("$.get", tmp), node3)
      };
    }
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/DebugTag.js
function DebugTag3(node, context) {
  const object4 = object(
    node.identifiers.map((identifier) => {
      const visited = call(
        "$.snapshot",
        /** @type {Expression} */
        context.visit(identifier)
      );
      return prop(
        "init",
        identifier,
        context.state.analysis.runes ? visited : call("$.untrack", thunk(visited))
      );
    })
  );
  const call2 = call("console.log", object4);
  context.state.init.push(
    stmt(call("$.template_effect", thunk(block([stmt(call2), debugger_builder]))))
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/EachBlock.js
function EachBlock3(node, context) {
  var _a2, _b, _c, _d, _e, _f;
  const each_node_meta = node.metadata;
  const collection = (
    /** @type {Expression} */
    context.visit(node.expression, {
      ...context.state,
      scope: (
        /** @type {Scope} */
        context.state.scope.parent
      )
    })
  );
  if (!each_node_meta.is_controlled) {
    context.state.template.push_comment();
  }
  let flags = 0;
  if (node.metadata.keyed && node.index) {
    flags |= EACH_INDEX_REACTIVE;
  }
  const key_is_item = ((_a2 = node.key) == null ? void 0 : _a2.type) === "Identifier" && ((_b = node.context) == null ? void 0 : _b.type) === "Identifier" && ((_c = node.context) == null ? void 0 : _c.name) === node.key.name;
  let uses_store;
  for (const binding of node.metadata.expression.dependencies) {
    if (binding.kind === "store_sub") {
      uses_store = true;
      break;
    }
  }
  for (const binding of node.metadata.expression.dependencies) {
    if (binding.scope.function_depth >= context.state.scope.function_depth) {
      continue;
    }
    if (!context.state.analysis.runes || !key_is_item || uses_store) {
      flags |= EACH_ITEM_REACTIVE;
      break;
    }
  }
  if (context.state.analysis.runes && !uses_store) {
    flags |= EACH_ITEM_IMMUTABLE;
  }
  if (node.key && node.body.nodes.some((child) => {
    if (child.type !== "RegularElement" && child.type !== "SvelteElement") return false;
    return child.attributes.some((attr) => attr.type === "AnimateDirective");
  })) {
    flags |= EACH_IS_ANIMATED;
  }
  if (each_node_meta.is_controlled) {
    flags |= EACH_IS_CONTROLLED;
  }
  let store_to_invalidate = "";
  if (node.expression.type === "Identifier" || node.expression.type === "MemberExpression") {
    const id2 = object2(node.expression);
    if (id2) {
      const binding = context.state.scope.get(id2.name);
      if ((binding == null ? void 0 : binding.kind) === "store_sub") {
        store_to_invalidate = id2.name;
      }
    }
  }
  let collection_id = null;
  for (const [name] of context.state.scope.declarations) {
    if (((_d = context.state.scope.parent) == null ? void 0 : _d.get(name)) != null) {
      collection_id = context.state.scope.root.unique("$$array");
      break;
    }
  }
  const child_state = {
    ...context.state,
    transform: { ...context.state.transform },
    store_to_invalidate
  };
  const key_state = {
    ...context.state,
    transform: { ...context.state.transform }
  };
  const index = each_node_meta.contains_group_binding || !node.index ? each_node_meta.index : id(node.index);
  const item = ((_e = node.context) == null ? void 0 : _e.type) === "Identifier" ? node.context : id("$$item");
  let uses_index = each_node_meta.contains_group_binding;
  let key_uses_index = false;
  if (node.index) {
    child_state.transform[node.index] = {
      read: (node2) => {
        uses_index = true;
        return (flags & EACH_INDEX_REACTIVE) !== 0 ? get_value(node2) : node2;
      }
    };
    key_state.transform[node.index] = {
      read: (node2) => {
        key_uses_index = true;
        return node2;
      }
    };
  }
  const declarations = [];
  const invalidate_store = store_to_invalidate ? call("$.invalidate_store", id("$$stores"), literal2(store_to_invalidate)) : void 0;
  const sequence3 = [];
  if (!context.state.analysis.runes) {
    const transitive_deps = /* @__PURE__ */ new Set();
    if (collection_id) {
      transitive_deps.add(collection_id);
      child_state.transform[collection_id.name] = { read: call };
    } else {
      for (const binding of each_node_meta.transitive_deps) {
        transitive_deps.add(binding.node);
      }
    }
    for (const block3 of collect_parent_each_blocks(context)) {
      for (const binding of block3.metadata.transitive_deps) {
        transitive_deps.add(binding.node);
      }
    }
    if (transitive_deps.size > 0) {
      const invalidate = call(
        "$.invalidate_inner_signals",
        thunk(
          sequence(
            [...transitive_deps].map(
              (node2) => (
                /** @type {Expression} */
                context.visit({ ...node2 }, child_state)
              )
            )
          )
        )
      );
      sequence3.push(invalidate);
    }
  }
  if (invalidate_store) {
    sequence3.push(invalidate_store);
  }
  if (((_f = node.context) == null ? void 0 : _f.type) === "Identifier") {
    const binding = (
      /** @type {Binding} */
      context.state.scope.get(node.context.name)
    );
    child_state.transform[node.context.name] = {
      read: (node2) => {
        if (binding.reassigned) {
          return member(
            collection_id ? call(collection_id) : collection,
            (flags & EACH_INDEX_REACTIVE) !== 0 ? get_value(index) : index,
            true
          );
        }
        return (flags & EACH_ITEM_REACTIVE) !== 0 ? get_value(node2) : node2;
      },
      assign: (_, value) => {
        uses_index = true;
        const left = member(
          collection_id ? call(collection_id) : collection,
          (flags & EACH_INDEX_REACTIVE) !== 0 ? get_value(index) : index,
          true
        );
        return sequence([assignment("=", left, value), ...sequence3]);
      },
      mutate: (_, mutation) => {
        uses_index = true;
        return sequence([mutation, ...sequence3]);
      }
    };
    delete key_state.transform[node.context.name];
  } else if (node.context) {
    const unwrapped = (flags & EACH_ITEM_REACTIVE) !== 0 ? call("$.get", item) : item;
    const { inserts, paths } = extract_paths(node.context, unwrapped);
    for (const { id: id2, value } of inserts) {
      id2.name = context.state.scope.generate("$$array");
      child_state.transform[id2.name] = { read: get_value };
      const expression = (
        /** @type {Expression} */
        context.visit(thunk(value), child_state)
      );
      declarations.push(var_builder(id2, call("$.derived", expression)));
    }
    for (const path11 of paths) {
      const name = (
        /** @type {Identifier} */
        path11.node.name
      );
      const needs_derived = path11.has_default_value;
      const fn = thunk(
        /** @type {Expression} */
        context.visit(path11.expression, child_state)
      );
      declarations.push(let_builder(path11.node, needs_derived ? call("$.derived_safe_equal", fn) : fn));
      const read = needs_derived ? get_value : call;
      child_state.transform[name] = {
        read,
        assign: (_, value) => {
          const left = (
            /** @type {Pattern} */
            path11.update_expression
          );
          return sequence([assignment("=", left, value), ...sequence3]);
        },
        mutate: (_, mutation) => {
          return sequence([mutation, ...sequence3]);
        }
      };
      if (dev) {
        declarations.push(stmt(read(id(name))));
      }
      delete key_state.transform[name];
    }
  }
  const block2 = (
    /** @type {BlockStatement} */
    context.visit(node.body, child_state)
  );
  let key_function = id("$.index");
  if (node.metadata.keyed) {
    const pattern = (
      /** @type {Pattern} */
      node.context
    );
    const expression = (
      /** @type {Expression} */
      context.visit(
        /** @type {Expression} */
        node.key,
        key_state
      )
    );
    key_function = arrow(key_uses_index ? [pattern, index] : [pattern], expression);
  }
  if (node.index && each_node_meta.contains_group_binding) {
    declarations.push(let_builder(node.index, index));
  }
  if (dev && node.metadata.keyed) {
    context.state.init.push(
      stmt(call("$.validate_each_keys", thunk(collection), key_function))
    );
  }
  const render_args = [id("$$anchor"), item];
  if (uses_index || collection_id) render_args.push(index);
  if (collection_id) render_args.push(collection_id);
  const args = [
    context.state.node,
    literal2(flags),
    thunk(collection),
    key_function,
    arrow(render_args, block(declarations.concat(block2.body)))
  ];
  if (node.fallback) {
    args.push(
      arrow(
        [id("$$anchor")],
        /** @type {BlockStatement} */
        context.visit(node.fallback)
      )
    );
  }
  context.state.init.push(stmt(call("$.each", ...args)));
}
function collect_parent_each_blocks(context) {
  return (
    /** @type {AST.EachBlock[]} */
    context.path.filter((node) => node.type === "EachBlock")
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/ExportNamedDeclaration.js
function ExportNamedDeclaration2(node, context) {
  if (context.state.is_instance) {
    if (node.declaration) {
      return context.visit(node.declaration);
    }
    return empty2;
  }
  return context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/ExpressionStatement.js
function ExpressionStatement3(node, context) {
  if (node.expression.type === "CallExpression") {
    const rune = get_rune(node.expression, context.state.scope);
    if (rune === "$effect" || rune === "$effect.pre") {
      const callee = rune === "$effect" ? "$.user_effect" : "$.user_pre_effect";
      const func = (
        /** @type {Expression} */
        context.visit(node.expression.arguments[0])
      );
      const expr = call(
        callee,
        /** @type {Expression} */
        func
      );
      expr.callee.loc = node.expression.callee.loc;
      return stmt(expr);
    }
    if (rune === "$inspect.trace") {
      return empty2;
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/transform-template/index.js
function build_locations(nodes) {
  const array2 = array([]);
  for (const node of nodes) {
    if (node.type !== "element") continue;
    const { line, column } = (
      /** @type {Location} */
      locator(node.start)
    );
    const expression = array([literal2(line), literal2(column)]);
    const children = build_locations(node.children);
    if (children.elements.length > 0) {
      expression.elements.push(children);
    }
    array2.elements.push(expression);
  }
  return array2;
}
function transform_template(state, namespace, flags = 0) {
  const tree = state.options.fragments === "tree";
  const expression = tree ? state.template.as_tree() : state.template.as_html();
  if (tree) {
    if (namespace === "svg") flags |= TEMPLATE_USE_SVG;
    if (namespace === "mathml") flags |= TEMPLATE_USE_MATHML;
  }
  let call2 = call(
    tree ? `$.from_tree` : `$.from_${namespace}`,
    expression,
    flags ? literal2(flags) : void 0
  );
  if (state.template.contains_script_tag) {
    call2 = call(`$.with_script`, call2);
  }
  if (dev) {
    call2 = call(
      "$.add_locations",
      call2,
      member(id(state.analysis.name), "$.FILENAME", true),
      build_locations(state.template.nodes)
    );
  }
  return call2;
}

// node_modules/svelte/src/compiler/phases/3-transform/client/transform-template/fix-attribute-casing.js
var svg_attributes = "accent-height accumulate additive alignment-baseline allowReorder alphabetic amplitude arabic-form ascent attributeName attributeType autoReverse azimuth baseFrequency baseline-shift baseProfile bbox begin bias by calcMode cap-height class clip clipPathUnits clip-path clip-rule color color-interpolation color-interpolation-filters color-profile color-rendering contentScriptType contentStyleType cursor cx cy d decelerate descent diffuseConstant direction display divisor dominant-baseline dur dx dy edgeMode elevation enable-background end exponent externalResourcesRequired fill fill-opacity fill-rule filter filterRes filterUnits flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight format from fr fx fy g1 g2 glyph-name glyph-orientation-horizontal glyph-orientation-vertical glyphRef gradientTransform gradientUnits hanging height href horiz-adv-x horiz-origin-x id ideographic image-rendering in in2 intercept k k1 k2 k3 k4 kernelMatrix kernelUnitLength kerning keyPoints keySplines keyTimes lang lengthAdjust letter-spacing lighting-color limitingConeAngle local marker-end marker-mid marker-start markerHeight markerUnits markerWidth mask maskContentUnits maskUnits mathematical max media method min mode name numOctaves offset onabort onactivate onbegin onclick onend onerror onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup onrepeat onresize onscroll onunload opacity operator order orient orientation origin overflow overline-position overline-thickness panose-1 paint-order pathLength patternContentUnits patternTransform patternUnits pointer-events points pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits r radius refX refY rendering-intent repeatCount repeatDur requiredExtensions requiredFeatures restart result rotate rx ry scale seed shape-rendering slope spacing specularConstant specularExponent speed spreadMethod startOffset stdDeviation stemh stemv stitchTiles stop-color stop-opacity strikethrough-position strikethrough-thickness string stroke stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width style surfaceScale systemLanguage tabindex tableValues target targetX targetY text-anchor text-decoration text-rendering textLength to transform type u1 u2 underline-position underline-thickness unicode unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical values version vert-adv-y vert-origin-x vert-origin-y viewBox viewTarget visibility width widths word-spacing writing-mode x x-height x1 x2 xChannelSelector xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y y1 y2 yChannelSelector z zoomAndPan".split(
  " "
);
var svg_attribute_lookup = /* @__PURE__ */ new Map();
svg_attributes.forEach((name) => {
  svg_attribute_lookup.set(name.toLowerCase(), name);
});
function fix_attribute_casing(name) {
  name = name.toLowerCase();
  return svg_attribute_lookup.get(name) || name;
}

// node_modules/svelte/src/compiler/phases/3-transform/client/transform-template/template.js
var _stack, _element, _fragment;
var Template = class {
  constructor() {
    /**
     * `true` if HTML template contains a `<script>` tag. In this case we need to invoke a special
     * template instantiation function (see `create_fragment_with_script_from_html` for more info)
     */
    __publicField(this, "contains_script_tag", false);
    /** `true` if the HTML template needs to be instantiated with `importNode` */
    __publicField(this, "needs_import_node", false);
    /** @type {Node[]} */
    __publicField(this, "nodes", []);
    /** @type {Node[][]} */
    __privateAdd(this, _stack, [this.nodes]);
    /** @type {Element | undefined} */
    __privateAdd(this, _element);
    __privateAdd(this, _fragment, this.nodes);
  }
  /**
   * @param {string} name
   * @param {number} start
   */
  push_element(name, start) {
    __privateSet(this, _element, {
      type: "element",
      name,
      attributes: {},
      children: [],
      start
    });
    __privateGet(this, _fragment).push(__privateGet(this, _element));
    __privateSet(
      this,
      _fragment,
      /** @type {Element} */
      __privateGet(this, _element).children
    );
    __privateGet(this, _stack).push(__privateGet(this, _fragment));
  }
  /** @param {string} [data] */
  push_comment(data2) {
    __privateGet(this, _fragment).push({ type: "comment", data: data2 });
  }
  /** @param {AST.Text[]} nodes */
  push_text(nodes) {
    __privateGet(this, _fragment).push({ type: "text", nodes });
  }
  pop_element() {
    __privateGet(this, _stack).pop();
    __privateSet(
      this,
      _fragment,
      /** @type {Node[]} */
      __privateGet(this, _stack).at(-1)
    );
  }
  /**
   * @param {string} key
   * @param {string | undefined} value
   */
  set_prop(key2, value) {
    __privateGet(this, _element).attributes[key2] = value;
  }
  as_html() {
    return template([quasi(this.nodes.map(stringify).join(""), true)], []);
  }
  as_tree() {
    if (this.nodes[0].type === "comment") {
      this.nodes.unshift({ type: "comment", data: void 0 });
    }
    return array(this.nodes.map(objectify));
  }
};
_stack = new WeakMap();
_element = new WeakMap();
_fragment = new WeakMap();
function stringify(item) {
  if (item.type === "text") {
    return item.nodes.map((node) => node.raw).join("");
  }
  if (item.type === "comment") {
    return item.data ? `<!--${item.data}-->` : "<!>";
  }
  let str = `<${item.name}`;
  for (const key2 in item.attributes) {
    const value = item.attributes[key2];
    str += ` ${key2}`;
    if (value !== void 0) str += `="${escape_html(value, true)}"`;
  }
  if (is_void(item.name)) {
    str += "/>";
  } else {
    str += `>`;
    str += item.children.map(stringify).join("");
    str += `</${item.name}>`;
  }
  return str;
}
function objectify(item) {
  if (item.type === "text") {
    return literal2(item.nodes.map((node) => node.data).join(""));
  }
  if (item.type === "comment") {
    return item.data ? array([literal2(`// ${item.data}`)]) : null;
  }
  const element2 = array([literal2(item.name)]);
  const attributes = object([]);
  for (const key2 in item.attributes) {
    const value = item.attributes[key2];
    attributes.properties.push(
      prop(
        "init",
        key(fix_attribute_casing(key2)),
        value === void 0 ? void0 : literal2(value)
      )
    );
  }
  if (attributes.properties.length > 0 || item.children.length > 0) {
    element2.elements.push(attributes.properties.length > 0 ? attributes : null_instance);
  }
  if (item.children.length > 0) {
    const children = item.children.map(objectify);
    element2.elements.push(...children);
    if (item.name === "pre" || item.name === "textarea") {
      const first = children[0];
      if ((first == null ? void 0 : first.type) === "Literal") {
        first.value = /** @type {string} */
        first.value.replace(regex_starts_with_newline, "");
      }
    }
  }
  return element2;
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/Fragment.js
function Fragment2(node, context) {
  const parent = context.path.at(-1) ?? node;
  const namespace = infer_namespace(context.state.metadata.namespace, parent, node.nodes);
  const { hoisted, trimmed, is_standalone, is_text_first } = clean_nodes(
    parent,
    node.nodes,
    context.path,
    namespace,
    context.state,
    context.state.preserve_whitespace,
    context.state.options.preserveComments
  );
  if (hoisted.length === 0 && trimmed.length === 0) {
    return block([]);
  }
  const is_single_element = trimmed.length === 1 && trimmed[0].type === "RegularElement";
  const is_single_child_not_needing_template = trimmed.length === 1 && (trimmed[0].type === "SvelteFragment" || trimmed[0].type === "TitleElement" || trimmed[0].type === "IfBlock" && trimmed[0].elseif);
  const template_name = context.state.scope.root.unique("root");
  const body = [];
  let close2 = void 0;
  const state = {
    ...context.state,
    init: [],
    update: [],
    expressions: [],
    after_update: [],
    template: new Template(),
    transform: { ...context.state.transform },
    metadata: {
      namespace,
      bound_contenteditable: context.state.metadata.bound_contenteditable
    }
  };
  for (const node2 of hoisted) {
    context.visit(node2, state);
  }
  if (is_text_first) {
    body.push(stmt(call("$.next")));
  }
  if (is_single_element) {
    const element2 = (
      /** @type {AST.RegularElement} */
      trimmed[0]
    );
    const id2 = id(context.state.scope.generate(element2.name));
    context.visit(element2, {
      ...state,
      node: id2
    });
    let flags = state.template.needs_import_node ? TEMPLATE_USE_IMPORT_NODE : void 0;
    const template2 = transform_template(state, namespace, flags);
    state.hoisted.push(var_builder(template_name, template2));
    body.push(var_builder(id2, call(template_name)));
    close2 = stmt(call("$.append", id("$$anchor"), id2));
  } else if (is_single_child_not_needing_template) {
    context.visit(trimmed[0], state);
  } else if (trimmed.length === 1 && trimmed[0].type === "Text") {
    const id2 = id(context.state.scope.generate("text"));
    body.push(var_builder(id2, call("$.text", literal2(trimmed[0].data))));
    close2 = stmt(call("$.append", id("$$anchor"), id2));
  } else if (trimmed.length > 0) {
    const id2 = id(context.state.scope.generate("fragment"));
    const use_space_template = trimmed.some((node2) => node2.type === "ExpressionTag") && trimmed.every((node2) => node2.type === "Text" || node2.type === "ExpressionTag");
    if (use_space_template) {
      const id3 = id(context.state.scope.generate("text"));
      process_children2(trimmed, () => id3, false, {
        ...context,
        state
      });
      body.push(var_builder(id3, call("$.text")));
      close2 = stmt(call("$.append", id("$$anchor"), id3));
    } else {
      if (is_standalone) {
        process_children2(trimmed, () => id("$$anchor"), false, { ...context, state });
      } else {
        const expression = (is_text) => call("$.first_child", id2, is_text && true_instance);
        process_children2(trimmed, expression, false, { ...context, state });
        let flags = TEMPLATE_FRAGMENT;
        if (state.template.needs_import_node) {
          flags |= TEMPLATE_USE_IMPORT_NODE;
        }
        if (state.template.nodes.length === 1 && state.template.nodes[0].type === "comment") {
          body.push(var_builder(id2, call("$.comment")));
        } else {
          const template2 = transform_template(state, namespace, flags);
          state.hoisted.push(var_builder(template_name, template2));
          body.push(var_builder(id2, call(template_name)));
        }
        close2 = stmt(call("$.append", id("$$anchor"), id2));
      }
    }
  }
  body.push(...state.init);
  if (state.update.length > 0) {
    body.push(build_render_statement(state));
  }
  body.push(...state.after_update);
  if (close2 !== void 0) {
    body.push(close2);
  }
  return block(body);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/FunctionDeclaration.js
function FunctionDeclaration2(node, context) {
  var _a2;
  const state = { ...context.state, in_constructor: false };
  if (((_a2 = node.metadata) == null ? void 0 : _a2.hoisted) === true) {
    const params = build_hoisted_params(node, context);
    const body = context.visit(node.body, state);
    context.state.hoisted.push(
      /** @type {FunctionDeclaration} */
      { ...node, params, body }
    );
    return empty2;
  }
  context.next(state);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/FunctionExpression.js
function FunctionExpression2(node, context) {
  return visit_function2(node, context);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/HtmlTag.js
function HtmlTag3(node, context) {
  context.state.template.push_comment();
  const expression = (
    /** @type {Expression} */
    context.visit(node.expression)
  );
  const is_svg2 = context.state.metadata.namespace === "svg";
  const is_mathml2 = context.state.metadata.namespace === "mathml";
  const statement = stmt(
    call(
      "$.html",
      context.state.node,
      thunk(expression),
      is_svg2 && true_instance,
      is_mathml2 && true_instance,
      is_ignored(node, "hydration_html_changed") && true_instance
    )
  );
  context.state.init.push(statement);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/Identifier.js
function Identifier3(node, context) {
  const parent = (
    /** @type {Node} */
    context.path.at(-1)
  );
  if (is_reference(node, parent)) {
    if (node.name === "$$props") {
      return id("$$sanitized_props");
    }
    const binding = context.state.scope.get(node.name);
    if (context.state.analysis.runes && // can't do this in legacy mode because the proxy does more than just read/write
    binding !== null && node !== binding.node && binding.kind === "rest_prop") {
      const grand_parent = context.path.at(-2);
      if ((parent == null ? void 0 : parent.type) === "MemberExpression" && !parent.computed && (grand_parent == null ? void 0 : grand_parent.type) !== "AssignmentExpression" && (grand_parent == null ? void 0 : grand_parent.type) !== "UpdateExpression") {
        return id("$$props");
      }
    }
    return build_getter(node, context.state);
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/IfBlock.js
function IfBlock3(node, context) {
  context.state.template.push_comment();
  const statements = [];
  const consequent = (
    /** @type {BlockStatement} */
    context.visit(node.consequent)
  );
  const consequent_id = context.state.scope.generate("consequent");
  statements.push(var_builder(id(consequent_id), arrow([id("$$anchor")], consequent)));
  let alternate_id;
  if (node.alternate) {
    alternate_id = context.state.scope.generate("alternate");
    const alternate = (
      /** @type {BlockStatement} */
      context.visit(node.alternate)
    );
    const nodes = node.alternate.nodes;
    let alternate_args = [id("$$anchor")];
    if (nodes.length === 1 && nodes[0].type === "IfBlock" && nodes[0].elseif) {
      alternate_args.push(id("$$elseif"));
    }
    statements.push(var_builder(id(alternate_id), arrow(alternate_args, alternate)));
  }
  const args = [
    node.elseif ? id("$$anchor") : context.state.node,
    arrow(
      [id("$$render")],
      block([
        if_builder(
          /** @type {Expression} */
          context.visit(node.test),
          stmt(call(id("$$render"), id(consequent_id))),
          alternate_id ? stmt(call(id("$$render"), id(alternate_id), false_instance)) : void 0
        )
      ])
    )
  ];
  if (node.elseif) {
    args.push(id("$$elseif"));
  }
  statements.push(stmt(call("$.if", ...args)));
  context.state.init.push(block(statements));
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/ImportDeclaration.js
function ImportDeclaration2(node, context) {
  if ("hoisted" in context.state) {
    context.state.hoisted.push(node);
    return empty2;
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/KeyBlock.js
function KeyBlock3(node, context) {
  context.state.template.push_comment();
  const key2 = (
    /** @type {Expression} */
    context.visit(node.expression)
  );
  const body = (
    /** @type {Expression} */
    context.visit(node.fragment)
  );
  context.state.init.push(
    stmt(call("$.key", context.state.node, thunk(key2), arrow([id("$$anchor")], body)))
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/LabeledStatement.js
function LabeledStatement3(node, context) {
  if (context.state.analysis.runes || context.path.length > 1 || node.label.name !== "$") {
    context.next();
    return;
  }
  const reactive_statement = (
    /** @type {ReactiveStatement} */
    context.state.analysis.reactive_statements.get(node)
  );
  if (!reactive_statement) return;
  let serialized_body = (
    /** @type {Statement} */
    context.visit(node.body)
  );
  if (serialized_body.type !== "BlockStatement") {
    serialized_body = block([serialized_body]);
  }
  const body = serialized_body.body;
  const sequence3 = [];
  for (const binding of reactive_statement.dependencies) {
    if (binding.kind === "normal" && binding.declaration_kind !== "import") continue;
    const name = binding.node.name;
    let serialized = build_getter(id(name), context.state);
    if (name === "$$props" || name === "$$restProps" || binding.kind === "bindable_prop") {
      serialized = call("$.deep_read_state", serialized);
    }
    sequence3.push(serialized);
  }
  context.state.legacy_reactive_statements.set(
    node,
    stmt(
      call(
        "$.legacy_pre_effect",
        sequence3.length > 0 ? thunk(sequence(sequence3)) : thunk(block([])),
        thunk(block(body))
      )
    )
  );
  return empty2;
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/LetDirective.js
function LetDirective2(node, context) {
  if (node.expression && node.expression.type !== "Identifier") {
    const name = context.state.scope.generate(node.name);
    const bindings = context.state.scope.get_bindings(node);
    for (const binding of bindings) {
      context.state.transform[binding.node.name] = {
        read: (node2) => member(call("$.get", id(name)), node2)
      };
    }
    return const_builder(
      name,
      call(
        "$.derived",
        thunk(
          block([
            let_builder(
              /** @type {Expression} */
              node.expression.type === "ObjectExpression" ? (
                // @ts-expect-error types don't match, but it can't contain spread elements and the structure is otherwise fine
                object_pattern(node.expression.properties)
              ) : (
                // @ts-expect-error types don't match, but it can't contain spread elements and the structure is otherwise fine
                array_pattern(node.expression.elements)
              ),
              member(id("$$slotProps"), node.name)
            ),
            return_builder(object(bindings.map((binding) => init2(binding.node.name, binding.node))))
          ])
        )
      )
    );
  } else {
    const name = node.expression === null ? node.name : node.expression.name;
    context.state.transform[name] = {
      read: (node2) => call("$.get", node2)
    };
    return const_builder(
      name,
      create_derived(context.state, thunk(member(id("$$slotProps"), node.name)))
    );
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/MemberExpression.js
function MemberExpression3(node, context) {
  if (node.property.type === "PrivateIdentifier") {
    const field = context.state.state_fields.get("#" + node.property.name);
    if (field) {
      return context.state.in_constructor && (field.type === "$state.raw" || field.type === "$state") ? member(node, "v") : call("$.get", node);
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/OnDirective.js
var modifiers = [
  "stopPropagation",
  "stopImmediatePropagation",
  "preventDefault",
  "self",
  "trusted",
  "once"
];
function OnDirective2(node, context) {
  if (!node.expression) {
    context.state.analysis.needs_props = true;
  }
  let handler = build_event_handler(node.expression, node.metadata.expression, context);
  for (const modifier of modifiers) {
    if (node.modifiers.includes(modifier)) {
      handler = call("$." + modifier, handler);
    }
  }
  const capture = node.modifiers.includes("capture");
  const passive = node.modifiers.includes("passive") || (node.modifiers.includes("nonpassive") ? false : void 0);
  return build_event(node.name, context.state.node, handler, capture, passive);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/Program.js
function Program(_, context) {
  if (!context.state.analysis.runes) {
    context.state.transform["$$props"] = {
      read: (node) => ({ ...node, name: "$$sanitized_props" })
    };
    for (const [name, binding] of context.state.scope.declarations) {
      if (binding.declaration_kind === "import" && binding.mutated) {
        const { start, end } = context.state.analysis.instance.ast;
        const node = (
          /** @type {ImportDeclaration} */
          binding.initial
        );
        const is_instance_import = (
          /** @type {number} */
          node.start > /** @type {number} */
          start && /** @type {number} */
          node.end < /** @type {number} */
          end
        );
        if (is_instance_import) {
          const id2 = id("$$_import_" + name);
          context.state.transform[name] = {
            read: (_2) => call(id2),
            mutate: (_2, mutation) => call(id2, mutation)
          };
          context.state.legacy_reactive_imports.push(
            var_builder(id2, call("$.reactive_import", thunk(id(name))))
          );
        }
      }
    }
  }
  for (const [name, binding] of context.state.scope.declarations) {
    if (binding.kind === "store_sub") {
      let cached;
      const get_store = () => {
        return cached ?? (cached = /** @type {Expression} */
        context.visit(id(name.slice(1))));
      };
      context.state.transform[name] = {
        read: call,
        assign: (_2, value) => call("$.store_set", get_store(), value),
        mutate: (node, mutation) => {
          const untracked = call("$.untrack", node);
          function replace(n2) {
            if (n2.type === "MemberExpression") {
              return {
                ...n2,
                object: replace(
                  /** @type {Expression} */
                  n2.object
                ),
                property: n2.property
              };
            }
            return untracked;
          }
          return call(
            "$.store_mutate",
            get_store(),
            mutation.type === "AssignmentExpression" ? assignment(
              mutation.operator,
              /** @type {MemberExpression} */
              replace(
                /** @type {MemberExpression} */
                mutation.left
              ),
              mutation.right
            ) : update(mutation.operator, replace(mutation.argument), mutation.prefix),
            untracked
          );
        },
        update: (node) => {
          return call(
            node.prefix ? "$.update_pre_store" : "$.update_store",
            build_getter(id(name.slice(1)), context.state),
            call(node.argument),
            node.operator === "--" && literal2(-1)
          );
        }
      };
    }
    if (binding.kind === "prop" || binding.kind === "bindable_prop") {
      if (is_prop_source(binding, context.state)) {
        context.state.transform[name] = {
          read: call,
          assign: (node, value) => call(node, value),
          mutate: (node, value) => {
            if (binding.kind === "bindable_prop") {
              return call(node, value, true_instance);
            }
            return value;
          },
          update: (node) => {
            return call(
              node.prefix ? "$.update_pre_prop" : "$.update_prop",
              node.argument,
              node.operator === "--" && literal2(-1)
            );
          }
        };
      } else if (binding.prop_alias) {
        const key2 = key(binding.prop_alias);
        context.state.transform[name] = {
          read: (_2) => member(id("$$props"), key2, key2.type === "Literal")
        };
      } else {
        context.state.transform[name] = {
          read: (node) => member(id("$$props"), node)
        };
      }
    }
  }
  add_state_transformers(context);
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/RenderTag.js
function RenderTag3(node, context) {
  context.state.template.push_comment();
  const expression = unwrap_optional(node.expression);
  const callee = expression.callee;
  const raw_args = expression.arguments;
  let args = [];
  for (let i = 0; i < raw_args.length; i++) {
    let thunk2 = thunk(
      /** @type {Expression} */
      context.visit(raw_args[i])
    );
    const { has_call } = node.metadata.arguments[i];
    if (has_call) {
      const id2 = id(context.state.scope.generate("render_arg"));
      context.state.init.push(var_builder(id2, call("$.derived_safe_equal", thunk2)));
      args.push(thunk(call("$.get", id2)));
    } else {
      args.push(thunk2);
    }
  }
  let snippet_function = (
    /** @type {Expression} */
    context.visit(callee)
  );
  if (node.metadata.dynamic) {
    if (node.expression.type === "ChainExpression") {
      snippet_function = logical("??", snippet_function, id("$.noop"));
    }
    context.state.init.push(
      stmt(call("$.snippet", context.state.node, thunk(snippet_function), ...args))
    );
  } else {
    context.state.init.push(
      stmt(
        (node.expression.type === "CallExpression" ? call : maybe_call)(
          snippet_function,
          context.state.node,
          ...args
        )
      )
    );
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SlotElement.js
function SlotElement3(node, context) {
  context.state.template.push_comment();
  const props = [];
  const spreads = [];
  const lets = [];
  let is_default = true;
  let name = literal2("default");
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute") {
      spreads.push(thunk(
        /** @type {Expression} */
        context.visit(attribute)
      ));
    } else if (attribute.type === "Attribute") {
      const { value, has_state } = build_attribute_value2(
        attribute.value,
        context,
        (value2, metadata) => metadata.has_call ? memoize_expression(context.state, value2) : value2
      );
      if (attribute.name === "name") {
        name = /** @type {Literal} */
        value;
        is_default = false;
      } else if (attribute.name !== "slot") {
        if (has_state) {
          props.push(get(attribute.name, [return_builder(value)]));
        } else {
          props.push(init2(attribute.name, value));
        }
      }
    } else if (attribute.type === "LetDirective") {
      lets.push(
        /** @type {ExpressionStatement} */
        context.visit(attribute)
      );
    }
  }
  context.state.init.push(...lets);
  const props_expression = spreads.length === 0 ? object(props) : call("$.spread_props", object(props), ...spreads);
  const fallback = node.fragment.nodes.length === 0 ? null_instance : arrow(
    [id("$$anchor")],
    /** @type {BlockStatement} */
    context.visit(node.fragment)
  );
  const slot = call(
    "$.slot",
    context.state.node,
    id("$$props"),
    name,
    props_expression,
    fallback
  );
  context.state.init.push(stmt(slot));
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SnippetBlock.js
function SnippetBlock3(node, context) {
  const args = [id("$$anchor")];
  let body;
  const declarations = [];
  if (dev) {
    declarations.push(stmt(call("$.validate_snippet_args", spread(id("arguments")))));
  }
  const transform = { ...context.state.transform };
  const child_state = { ...context.state, transform };
  for (let i = 0; i < node.parameters.length; i++) {
    const argument = node.parameters[i];
    if (!argument) continue;
    if (argument.type === "Identifier") {
      args.push(assignment_pattern(argument, id("$.noop")));
      transform[argument.name] = { read: call };
      continue;
    }
    let arg_alias = `$$arg${i}`;
    args.push(id(arg_alias));
    const { inserts, paths } = extract_paths(argument, maybe_call(id(arg_alias)));
    for (const { id: id2, value } of inserts) {
      id2.name = context.state.scope.generate("$$array");
      transform[id2.name] = { read: get_value };
      declarations.push(
        var_builder(id2, call(
          "$.derived",
          /** @type {Expression} */
          context.visit(thunk(value))
        ))
      );
    }
    for (const path11 of paths) {
      const name = (
        /** @type {Identifier} */
        path11.node.name
      );
      const needs_derived = path11.has_default_value;
      const fn = thunk(
        /** @type {Expression} */
        context.visit(path11.expression)
      );
      declarations.push(let_builder(path11.node, needs_derived ? call("$.derived_safe_equal", fn) : fn));
      transform[name] = {
        read: needs_derived ? get_value : call
      };
      if (dev) {
        declarations.push(stmt(transform[name].read(id(name))));
      }
    }
  }
  body = block([
    ...declarations,
    .../** @type {BlockStatement} */
    context.visit(node.body, child_state).body
  ]);
  let snippet = dev ? call("$.wrap_snippet", id(context.state.analysis.name), function_builder(null, args, body)) : arrow(args, body);
  const declaration2 = const_builder(node.expression, snippet);
  if (context.path.length === 1 && context.path[0].type === "Fragment") {
    if (node.metadata.can_hoist) {
      context.state.module_level_snippets.push(declaration2);
    } else {
      context.state.instance_level_snippets.push(declaration2);
    }
  } else {
    context.state.init.push(declaration2);
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SpreadAttribute.js
function SpreadAttribute3(node, context) {
  return context.visit(node.expression);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/special_element.js
function visit_special_element(node, id2, context) {
  const state = { ...context.state, node: id(id2) };
  for (const attribute of node.attributes) {
    if (attribute.type === "OnDirective") {
      context.state.init.push(stmt(
        /** @type {Expression} */
        context.visit(attribute, state)
      ));
    } else {
      context.visit(attribute, state);
    }
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteBody.js
function SvelteBody2(node, context) {
  visit_special_element(node, "$.document.body", context);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteComponent.js
function SvelteComponent3(node, context) {
  const component = build_component(node, "$$component", context);
  context.state.init.push(component);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteDocument.js
function SvelteDocument2(node, context) {
  visit_special_element(node, "$.document", context);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteElement.js
function SvelteElement3(node, context) {
  context.state.template.push_comment();
  const attributes = [];
  let dynamic_namespace = void 0;
  const class_directives = [];
  const style_directives = [];
  const lets = [];
  const element_id = id(context.state.scope.generate("$$element"));
  const inner_context = {
    ...context,
    state: {
      ...context.state,
      node: element_id,
      init: [],
      update: [],
      expressions: [],
      after_update: []
    }
  };
  for (const attribute of node.attributes) {
    if (attribute.type === "Attribute") {
      if (attribute.name === "xmlns" && !is_text_attribute(attribute)) {
        dynamic_namespace = attribute.value;
      }
      attributes.push(attribute);
    } else if (attribute.type === "SpreadAttribute") {
      attributes.push(attribute);
    } else if (attribute.type === "ClassDirective") {
      class_directives.push(attribute);
    } else if (attribute.type === "StyleDirective") {
      style_directives.push(attribute);
    } else if (attribute.type === "LetDirective") {
      lets.push(
        /** @type {ExpressionStatement} */
        context.visit(attribute)
      );
    } else if (attribute.type === "OnDirective") {
      const handler = (
        /** @type {Expression} */
        context.visit(attribute, inner_context.state)
      );
      inner_context.state.after_update.push(stmt(handler));
    } else {
      context.visit(attribute, inner_context.state);
    }
  }
  context.state.init.push(...lets);
  if (attributes.length === 1 && attributes[0].type === "Attribute" && attributes[0].name.toLowerCase() === "class" && is_text_attribute(attributes[0])) {
    build_set_class(node, element_id, attributes[0], class_directives, inner_context, false);
  } else if (attributes.length) {
    build_attribute_effect(
      attributes,
      class_directives,
      style_directives,
      inner_context,
      node,
      element_id
    );
  }
  const get_tag = thunk(
    /** @type {Expression} */
    context.visit(node.tag)
  );
  if (dev) {
    if (node.fragment.nodes.length > 0) {
      context.state.init.push(stmt(call("$.validate_void_dynamic_element", get_tag)));
    }
    context.state.init.push(stmt(call("$.validate_dynamic_element_tag", get_tag)));
  }
  const inner = inner_context.state.init;
  if (inner_context.state.update.length > 0) {
    inner.push(build_render_statement(inner_context.state));
  }
  inner.push(...inner_context.state.after_update);
  inner.push(
    .../** @type {BlockStatement} */
    context.visit(node.fragment, {
      ...context.state,
      metadata: {
        ...context.state.metadata,
        namespace: determine_namespace_for_children(node, context.state.metadata.namespace)
      }
    }).body
  );
  const location = dev && locator(node.start);
  context.state.init.push(
    stmt(
      call(
        "$.element",
        context.state.node,
        get_tag,
        node.metadata.svg || node.metadata.mathml ? true_instance : false_instance,
        inner.length > 0 && arrow([element_id, id("$$anchor")], block(inner)),
        dynamic_namespace && thunk(build_attribute_value2(dynamic_namespace, context).value),
        location && array([literal2(location.line), literal2(location.column)])
      )
    )
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteFragment.js
function SvelteFragment3(node, context) {
  for (const attribute of node.attributes) {
    if (attribute.type === "LetDirective") {
      context.state.init.push(
        /** @type {ExpressionStatement} */
        context.visit(attribute)
      );
    }
  }
  context.state.init.push(.../** @type {BlockStatement} */
  context.visit(node.fragment).body);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteBoundary.js
function SvelteBoundary3(node, context) {
  const props = object([]);
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute" || attribute.value === true) {
      continue;
    }
    const chunk = Array.isArray(attribute.value) ? (
      /** @type {AST.ExpressionTag} */
      attribute.value[0]
    ) : attribute.value;
    const expression = (
      /** @type {Expression} */
      context.visit(chunk.expression, context.state)
    );
    if (chunk.metadata.expression.has_state) {
      props.properties.push(get(attribute.name, [return_builder(expression)]));
    } else {
      props.properties.push(init2(attribute.name, expression));
    }
  }
  const nodes = [];
  const external_statements = [];
  const internal_statements = [];
  const snippets_visits = [];
  for (const child of node.fragment.nodes) {
    if (child.type === "SnippetBlock" && child.expression.name === "failed") {
      snippets_visits.push(() => {
        const init3 = [];
        context.visit(child, { ...context.state, init: init3 });
        props.properties.push(prop("init", child.expression, child.expression));
        external_statements.push(...init3);
      });
    } else if (child.type === "ConstTag") {
      const init3 = [];
      context.visit(child, { ...context.state, init: init3 });
      if (dev) {
        for (const statement of init3) {
          if (statement.type === "VariableDeclaration") {
            external_statements.push(statement);
          } else {
            internal_statements.push(statement);
          }
        }
      } else {
        external_statements.push(...init3);
      }
    } else {
      nodes.push(child);
    }
  }
  snippets_visits.forEach((visit) => visit());
  const block2 = (
    /** @type {BlockStatement} */
    context.visit({ ...node.fragment, nodes })
  );
  if (dev && internal_statements.length) {
    block2.body.unshift(...internal_statements);
  }
  const boundary = stmt(
    call("$.boundary", context.state.node, props, arrow([id("$$anchor")], block2))
  );
  context.state.template.push_comment();
  context.state.init.push(
    external_statements.length > 0 ? block([...external_statements, boundary]) : boundary
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteHead.js
function SvelteHead3(node, context) {
  context.state.init.push(
    stmt(
      call(
        "$.head",
        arrow(
          [id("$$anchor")],
          /** @type {BlockStatement} */
          context.visit(node.fragment)
        )
      )
    )
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteSelf.js
function SvelteSelf3(node, context) {
  const component = build_component(node, context.state.analysis.name, context);
  context.state.init.push(component);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteWindow.js
function SvelteWindow2(node, context) {
  visit_special_element(node, "$.window", context);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/TitleElement.js
function TitleElement3(node, context) {
  const { has_state, value } = build_template_chunk(
    /** @type {any} */
    node.fragment.nodes,
    context.visit,
    context.state
  );
  const statement = stmt(assignment("=", id("$.document.title"), value));
  if (has_state) {
    context.state.update.push(statement);
  } else {
    context.state.init.push(statement);
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/TransitionDirective.js
function TransitionDirective2(node, context) {
  let flags = node.modifiers.includes("global") ? TRANSITION_GLOBAL : 0;
  if (node.intro) flags |= TRANSITION_IN;
  if (node.outro) flags |= TRANSITION_OUT;
  const args = [
    literal2(flags),
    context.state.node,
    thunk(
      /** @type {Expression} */
      context.visit(parse_directive_name(node.name))
    )
  ];
  if (node.expression) {
    args.push(thunk(
      /** @type {Expression} */
      context.visit(node.expression)
    ));
  }
  context.state.after_update.push(stmt(call("$.transition", ...args)));
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/UpdateExpression.js
function UpdateExpression3(node, context) {
  const argument = node.argument;
  if (argument.type === "MemberExpression" && argument.object.type === "ThisExpression" && argument.property.type === "PrivateIdentifier" && context.state.state_fields.has("#" + argument.property.name)) {
    let fn = "$.update";
    if (node.prefix) fn += "_pre";
    const args = [argument];
    if (node.operator === "--") {
      args.push(literal2(-1));
    }
    return call(fn, ...args);
  }
  if (argument.type !== "Identifier" && argument.type !== "MemberExpression") {
    throw new Error("An impossible state was reached");
  }
  const left = object2(argument);
  const transformers = left && context.state.transform[left.name];
  if (left === argument && (transformers == null ? void 0 : transformers.update)) {
    return transformers.update(node);
  }
  let update2 = (
    /** @type {Expression} */
    context.next()
  );
  if (left && (transformers == null ? void 0 : transformers.mutate)) {
    update2 = transformers.mutate(
      left,
      /** @type {AssignmentExpression | UpdateExpression} */
      update2
    );
  }
  return validate_mutation(node, context, update2);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/UseDirective.js
function UseDirective2(node, context) {
  const params = [id("$$node")];
  if (node.expression) {
    params.push(id("$$action_arg"));
  }
  const args = [
    context.state.node,
    arrow(
      params,
      maybe_call(
        /** @type {Expression} */
        context.visit(parse_directive_name(node.name)),
        ...params
      )
    )
  ];
  if (node.expression) {
    args.push(thunk(
      /** @type {Expression} */
      context.visit(node.expression)
    ));
  }
  context.state.init.push(stmt(call("$.action", ...args)));
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/AttachTag.js
function AttachTag2(node, context) {
  context.state.init.push(
    stmt(
      call(
        "$.attach",
        context.state.node,
        thunk(
          /** @type {Expression} */
          context.visit(node.expression)
        )
      )
    )
  );
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/VariableDeclaration.js
function VariableDeclaration2(node, context) {
  const declarations = [];
  if (context.state.analysis.runes) {
    for (const declarator2 of node.declarations) {
      const init3 = declarator2.init;
      const rune = get_rune(init3, context.state.scope);
      if (!rune || rune === "$effect.tracking" || rune === "$effect.root" || rune === "$inspect" || rune === "$inspect.trace" || rune === "$state.snapshot" || rune === "$host") {
        if (init3 != null && is_hoisted_function(init3)) {
          context.state.hoisted.push(
            const_builder(
              declarator2.id,
              /** @type {Expression} */
              context.visit(init3)
            )
          );
          continue;
        }
        declarations.push(
          /** @type {VariableDeclarator} */
          context.visit(declarator2)
        );
        continue;
      }
      if (rune === "$props.id") {
        continue;
      }
      if (rune === "$props") {
        const seen2 = ["$$slots", "$$events", "$$legacy"];
        if (context.state.analysis.custom_element) {
          seen2.push("$$host");
        }
        if (declarator2.id.type === "Identifier") {
          const args2 = [id("$$props"), array(seen2.map((name) => literal2(name)))];
          if (dev) {
            args2.push(literal2(declarator2.id.name));
          }
          declarations.push(declarator(declarator2.id, call("$.rest_props", ...args2)));
        } else {
          equal(declarator2.id.type, "ObjectPattern");
          for (const property of declarator2.id.properties) {
            if (property.type === "Property") {
              const key2 = (
                /** @type {Identifier | Literal} */
                property.key
              );
              const name = key2.type === "Identifier" ? key2.name : (
                /** @type {string} */
                key2.value
              );
              seen2.push(name);
              let id2 = property.value.type === "AssignmentPattern" ? property.value.left : property.value;
              equal(id2.type, "Identifier");
              const binding = (
                /** @type {Binding} */
                context.state.scope.get(id2.name)
              );
              let initial = binding.initial && /** @type {Expression} */
              context.visit(binding.initial);
              if (initial && binding.kind === "bindable_prop" && should_proxy(initial, context.state.scope)) {
                initial = call("$.proxy", initial);
              }
              if (is_prop_source(binding, context.state)) {
                declarations.push(
                  declarator(id2, get_prop_source(binding, context.state, name, initial))
                );
              }
            } else {
              const args2 = [id("$$props"), array(seen2.map((name) => literal2(name)))];
              if (dev) {
                args2.push(literal2(
                  /** @type {Identifier} */
                  property.argument.name
                ));
              }
              declarations.push(declarator(property.argument, call("$.rest_props", ...args2)));
            }
          }
        }
        continue;
      }
      const args = (
        /** @type {CallExpression} */
        init3.arguments
      );
      const value = (
        /** @type {Expression} */
        args[0] ?? void0
      );
      if (rune === "$state" || rune === "$state.raw") {
        const create_state_declarator = (id2, value2) => {
          const binding = (
            /** @type {import('#compiler').Binding} */
            context.state.scope.get(id2.name)
          );
          if (rune === "$state" && should_proxy(value2, context.state.scope)) {
            value2 = call("$.proxy", value2);
          }
          if (is_state_source(binding, context.state.analysis)) {
            value2 = call("$.state", value2);
          }
          return value2;
        };
        if (declarator2.id.type === "Identifier") {
          const expression = (
            /** @type {Expression} */
            context.visit(value)
          );
          declarations.push(
            declarator(declarator2.id, create_state_declarator(declarator2.id, expression))
          );
        } else {
          const tmp = id(context.state.scope.generate("tmp"));
          const { inserts, paths } = extract_paths(declarator2.id, tmp);
          declarations.push(
            declarator(tmp, value),
            ...inserts.map(({ id: id2, value: value2 }) => {
              id2.name = context.state.scope.generate("$$array");
              context.state.transform[id2.name] = { read: get_value };
              const expression = (
                /** @type {Expression} */
                context.visit(thunk(value2))
              );
              return declarator(id2, call("$.derived", expression));
            }),
            ...paths.map((path11) => {
              const value2 = (
                /** @type {Expression} */
                context.visit(path11.expression)
              );
              const binding = context.state.scope.get(
                /** @type {Identifier} */
                path11.node.name
              );
              return declarator(
                path11.node,
                (binding == null ? void 0 : binding.kind) === "state" || (binding == null ? void 0 : binding.kind) === "raw_state" ? create_state_declarator(binding.node, value2) : value2
              );
            })
          );
        }
        continue;
      }
      if (rune === "$derived" || rune === "$derived.by") {
        if (declarator2.id.type === "Identifier") {
          let expression = (
            /** @type {Expression} */
            context.visit(value)
          );
          if (rune === "$derived") expression = thunk(expression);
          declarations.push(declarator(declarator2.id, call("$.derived", expression)));
        } else {
          const init4 = (
            /** @type {CallExpression} */
            declarator2.init
          );
          let rhs = value;
          if (rune !== "$derived" || init4.arguments[0].type !== "Identifier") {
            const id2 = id(context.state.scope.generate("$$d"));
            rhs = call("$.get", id2);
            let expression = (
              /** @type {Expression} */
              context.visit(value)
            );
            if (rune === "$derived") expression = thunk(expression);
            declarations.push(declarator(id2, call("$.derived", expression)));
          }
          const { inserts, paths } = extract_paths(declarator2.id, rhs);
          for (const { id: id2, value: value2 } of inserts) {
            id2.name = context.state.scope.generate("$$array");
            context.state.transform[id2.name] = { read: get_value };
            const expression = (
              /** @type {Expression} */
              context.visit(thunk(value2))
            );
            declarations.push(declarator(id2, call("$.derived", expression)));
          }
          for (const path11 of paths) {
            const expression = (
              /** @type {Expression} */
              context.visit(path11.expression)
            );
            declarations.push(declarator(path11.node, call("$.derived", thunk(expression))));
          }
        }
        continue;
      }
    }
  } else {
    for (const declarator2 of node.declarations) {
      const bindings = (
        /** @type {Binding[]} */
        context.state.scope.get_bindings(declarator2)
      );
      const has_state = bindings.some((binding) => binding.kind === "state");
      const has_props = bindings.some((binding) => binding.kind === "bindable_prop");
      if (!has_state && !has_props) {
        const init3 = declarator2.init;
        if (init3 != null && is_hoisted_function(init3)) {
          context.state.hoisted.push(
            const_builder(
              declarator2.id,
              /** @type {Expression} */
              context.visit(init3)
            )
          );
          continue;
        }
        declarations.push(
          /** @type {VariableDeclarator} */
          context.visit(declarator2)
        );
        continue;
      }
      if (has_props) {
        if (declarator2.id.type !== "Identifier") {
          const tmp = id(context.state.scope.generate("tmp"));
          const { inserts, paths } = extract_paths(declarator2.id, tmp);
          declarations.push(
            declarator(
              tmp,
              /** @type {Expression} */
              context.visit(
                /** @type {Expression} */
                declarator2.init
              )
            )
          );
          for (const { id: id2, value } of inserts) {
            id2.name = context.state.scope.generate("$$array");
            context.state.transform[id2.name] = { read: get_value };
            const expression = (
              /** @type {Expression} */
              context.visit(thunk(value))
            );
            declarations.push(declarator(id2, call("$.derived", expression)));
          }
          for (const path11 of paths) {
            const name = (
              /** @type {Identifier} */
              path11.node.name
            );
            const binding2 = (
              /** @type {Binding} */
              context.state.scope.get(name)
            );
            const value = (
              /** @type {Expression} */
              context.visit(path11.expression)
            );
            declarations.push(
              declarator(
                path11.node,
                binding2.kind === "bindable_prop" ? get_prop_source(binding2, context.state, binding2.prop_alias ?? name, value) : value
              )
            );
          }
          continue;
        }
        const binding = (
          /** @type {Binding} */
          context.state.scope.get(declarator2.id.name)
        );
        declarations.push(
          declarator(
            declarator2.id,
            get_prop_source(
              binding,
              context.state,
              binding.prop_alias ?? declarator2.id.name,
              declarator2.init && /** @type {Expression} */
              context.visit(declarator2.init)
            )
          )
        );
        continue;
      }
      declarations.push(
        ...create_state_declarators2(
          declarator2,
          context,
          /** @type {Expression} */
          declarator2.init && context.visit(declarator2.init)
        )
      );
    }
  }
  if (declarations.length === 0) {
    return empty2;
  }
  return {
    ...node,
    declarations
  };
}
function create_state_declarators2(declarator2, context, value) {
  if (declarator2.id.type === "Identifier") {
    return [
      declarator(
        declarator2.id,
        call("$.mutable_source", value, context.state.analysis.immutable ? true_instance : void 0)
      )
    ];
  }
  const tmp = id(context.state.scope.generate("tmp"));
  const { inserts, paths } = extract_paths(declarator2.id, tmp);
  return [
    declarator(tmp, value),
    ...inserts.map(({ id: id2, value: value2 }) => {
      id2.name = context.state.scope.generate("$$array");
      context.state.transform[id2.name] = { read: get_value };
      const expression = (
        /** @type {Expression} */
        context.visit(thunk(value2))
      );
      return declarator(id2, call("$.derived", expression));
    }),
    ...paths.map((path11) => {
      const value2 = (
        /** @type {Expression} */
        context.visit(path11.expression)
      );
      const binding = context.state.scope.get(
        /** @type {Identifier} */
        path11.node.name
      );
      return declarator(
        path11.node,
        (binding == null ? void 0 : binding.kind) === "state" ? call("$.mutable_source", value2, context.state.analysis.immutable ? true_instance : void 0) : value2
      );
    })
  ];
}

// node_modules/svelte/src/compiler/phases/3-transform/client/transform-client.js
var visitors5 = {
  _: function set_scope2(node, { next: next2, state }) {
    const scope = state.scopes.get(node);
    if (scope && scope !== state.scope) {
      const transform = { ...state.transform };
      for (const [name, binding] of scope.declarations) {
        if (binding.kind === "normal" || // Reads of `$state(...)` declarations are not
        // transformed if they are never reassigned
        binding.kind === "state" && !is_state_source(binding, state.analysis)) {
          delete transform[name];
        }
      }
      next2({ ...state, transform, scope });
    } else {
      next2();
    }
  },
  AnimateDirective,
  ArrowFunctionExpression: ArrowFunctionExpression2,
  AssignmentExpression: AssignmentExpression3,
  Attribute: Attribute2,
  AwaitBlock: AwaitBlock3,
  BinaryExpression,
  BindDirective: BindDirective2,
  BlockStatement,
  BreakStatement,
  CallExpression: CallExpression3,
  ClassBody: ClassBody3,
  Comment,
  Component: Component3,
  ConstTag: ConstTag3,
  DebugTag: DebugTag3,
  EachBlock: EachBlock3,
  ExportNamedDeclaration: ExportNamedDeclaration2,
  ExpressionStatement: ExpressionStatement3,
  Fragment: Fragment2,
  FunctionDeclaration: FunctionDeclaration2,
  FunctionExpression: FunctionExpression2,
  HtmlTag: HtmlTag3,
  Identifier: Identifier3,
  IfBlock: IfBlock3,
  ImportDeclaration: ImportDeclaration2,
  KeyBlock: KeyBlock3,
  LabeledStatement: LabeledStatement3,
  LetDirective: LetDirective2,
  MemberExpression: MemberExpression3,
  OnDirective: OnDirective2,
  Program,
  RegularElement: RegularElement3,
  RenderTag: RenderTag3,
  SlotElement: SlotElement3,
  SnippetBlock: SnippetBlock3,
  SpreadAttribute: SpreadAttribute3,
  SvelteBody: SvelteBody2,
  SvelteComponent: SvelteComponent3,
  SvelteDocument: SvelteDocument2,
  SvelteElement: SvelteElement3,
  SvelteFragment: SvelteFragment3,
  SvelteBoundary: SvelteBoundary3,
  SvelteHead: SvelteHead3,
  SvelteSelf: SvelteSelf3,
  SvelteWindow: SvelteWindow2,
  TitleElement: TitleElement3,
  TransitionDirective: TransitionDirective2,
  UpdateExpression: UpdateExpression3,
  UseDirective: UseDirective2,
  AttachTag: AttachTag2,
  VariableDeclaration: VariableDeclaration2
};
function client_component(analysis, options) {
  var _a2;
  const state = {
    analysis,
    options,
    scope: analysis.module.scope,
    scopes: analysis.module.scopes,
    is_instance: false,
    hoisted: [import_all("$", "svelte/internal/client")],
    node: (
      /** @type {any} */
      null
    ),
    // populated by the root node
    legacy_reactive_imports: [],
    legacy_reactive_statements: /* @__PURE__ */ new Map(),
    metadata: {
      namespace: options.namespace,
      bound_contenteditable: false
    },
    events: /* @__PURE__ */ new Set(),
    preserve_whitespace: options.preserveWhitespace,
    state_fields: /* @__PURE__ */ new Map(),
    transform: {},
    in_constructor: false,
    instance_level_snippets: [],
    module_level_snippets: [],
    // these are set inside the `Fragment` visitor, and cannot be used until then
    init: (
      /** @type {any} */
      null
    ),
    update: (
      /** @type {any} */
      null
    ),
    expressions: (
      /** @type {any} */
      null
    ),
    after_update: (
      /** @type {any} */
      null
    ),
    template: (
      /** @type {any} */
      null
    )
  };
  const module = (
    /** @type {ESTree.Program} */
    walk(
      /** @type {AST.SvelteNode} */
      analysis.module.ast,
      state,
      visitors5
    )
  );
  const instance_state = {
    ...state,
    transform: { ...state.transform },
    scope: analysis.instance.scope,
    scopes: analysis.instance.scopes,
    is_instance: true
  };
  const instance = (
    /** @type {ESTree.Program} */
    walk(
      /** @type {AST.SvelteNode} */
      analysis.instance.ast,
      instance_state,
      visitors5
    )
  );
  const template2 = (
    /** @type {ESTree.Program} */
    walk(
      /** @type {AST.SvelteNode} */
      analysis.template.ast,
      {
        ...state,
        transform: instance_state.transform,
        scope: analysis.instance.scope,
        scopes: analysis.template.scopes
      },
      visitors5
    )
  );
  module.body.unshift(...state.legacy_reactive_imports);
  const store_setup = [];
  const legacy_reactive_declarations = [];
  let needs_store_cleanup = false;
  for (const [name, binding] of analysis.instance.scope.declarations) {
    if (binding.kind === "legacy_reactive") {
      legacy_reactive_declarations.push(
        const_builder(
          name,
          call("$.mutable_source", void 0, analysis.immutable ? true_instance : void 0)
        )
      );
    }
    if (binding.kind === "store_sub") {
      if (store_setup.length === 0) {
        needs_store_cleanup = true;
        store_setup.push(
          const_builder(array_pattern([id("$$stores"), id("$$cleanup")]), call("$.setup_stores"))
        );
      }
      const store_reference = build_getter(id(name.slice(1)), instance_state);
      const store_get = call("$.store_get", store_reference, literal2(name), id("$$stores"));
      store_setup.push(
        const_builder(
          binding.node,
          dev ? thunk(
            sequence([
              call("$.validate_store", store_reference, literal2(name.slice(1))),
              store_get
            ])
          ) : thunk(store_get)
        )
      );
    }
  }
  for (const [node] of analysis.reactive_statements) {
    const statement = [...state.legacy_reactive_statements].find(([n2]) => n2 === node);
    if (statement === void 0) {
      throw new Error("Could not find reactive statement");
    }
    instance.body.push(statement[1]);
  }
  if (analysis.reactive_statements.size > 0) {
    instance.body.push(stmt(call("$.legacy_pre_effect_reset")));
  }
  const group_binding_declarations = [];
  for (const group of analysis.binding_groups.values()) {
    group_binding_declarations.push(const_builder(group.name, array([])));
  }
  const component_returned_object = analysis.exports.flatMap(({ name, alias }) => {
    const binding = instance_state.scope.get(name);
    const expression = build_getter(id(name), instance_state);
    const getter = get(alias ?? name, [return_builder(expression)]);
    if (expression.type === "Identifier") {
      if ((binding == null ? void 0 : binding.declaration_kind) === "let" || (binding == null ? void 0 : binding.declaration_kind) === "var") {
        return [
          getter,
          set(alias ?? name, [stmt(assignment("=", expression, id("$$value")))])
        ];
      } else if (!dev) {
        return init2(alias ?? name, expression);
      }
    }
    if ((binding == null ? void 0 : binding.kind) === "prop" || (binding == null ? void 0 : binding.kind) === "bindable_prop") {
      return [getter, set(alias ?? name, [stmt(call(name, id("$$value")))])];
    }
    if ((binding == null ? void 0 : binding.kind) === "state" || (binding == null ? void 0 : binding.kind) === "raw_state") {
      const value = binding.kind === "state" ? call("$.proxy", id("$$value")) : id("$$value");
      return [getter, set(alias ?? name, [stmt(call("$.set", id(name), value))])];
    }
    return getter;
  });
  const properties = [...analysis.instance.scope.declarations].filter(
    ([name, binding]) => (binding.kind === "prop" || binding.kind === "bindable_prop") && !name.startsWith("$$")
  );
  if (analysis.accessors) {
    for (const [name, binding] of properties) {
      const key2 = binding.prop_alias ?? name;
      const getter = get(key2, [return_builder(call(id(name)))]);
      const setter = set(key2, [
        stmt(call(id(name), id("$$value"))),
        stmt(call("$.flush"))
      ]);
      if (analysis.runes && binding.initial) {
        setter.value.params[0] = {
          type: "AssignmentPattern",
          left: id("$$value"),
          right: (
            /** @type {ESTree.Expression} */
            binding.initial
          )
        };
      }
      component_returned_object.push(getter, setter);
    }
  }
  if (options.compatibility.componentApi === 4) {
    component_returned_object.push(
      init2("$set", id("$.update_legacy_props")),
      init2(
        "$on",
        arrow(
          [id("$$event_name"), id("$$event_cb")],
          call(
            "$.add_legacy_event_listener",
            id("$$props"),
            id("$$event_name"),
            id("$$event_cb")
          )
        )
      )
    );
  } else if (dev) {
    component_returned_object.push(spread(call(id("$.legacy_api"))));
  }
  const push_args = [id("$$props"), literal2(analysis.runes)];
  if (dev) push_args.push(id(analysis.name));
  const component_block = block([
    ...store_setup,
    ...legacy_reactive_declarations,
    ...group_binding_declarations,
    ...state.instance_level_snippets,
    .../** @type {ESTree.Statement[]} */
    instance.body,
    analysis.runes || !analysis.needs_context ? empty2 : stmt(call("$.init", analysis.immutable ? true_instance : void 0)),
    .../** @type {ESTree.Statement[]} */
    template2.body
  ]);
  if (!analysis.runes) {
    for (const { name, alias } of analysis.exports) {
      component_block.body.push(
        stmt(
          call(
            "$.bind_prop",
            id("$$props"),
            literal2(alias ?? name),
            build_getter(id(name), instance_state)
          )
        )
      );
    }
  }
  if (analysis.css.ast !== null && analysis.inject_styles) {
    const hash2 = literal2(analysis.css.hash);
    const code = literal2(render_stylesheet(analysis.source, analysis, options).code);
    state.hoisted.push(const_builder("$$css", object([init2("hash", hash2), init2("code", code)])));
    component_block.body.unshift(
      stmt(call("$.append_styles", id("$$anchor"), id("$$css")))
    );
  }
  if (analysis.needs_mutation_validation) {
    component_block.body.unshift(
      var_builder("$$ownership_validator", call("$.create_ownership_validator", id("$$props")))
    );
  }
  const should_inject_context = dev || analysis.needs_context || analysis.reactive_statements.size > 0 || component_returned_object.length > 0;
  if (should_inject_context) {
    component_block.body.unshift(stmt(call("$.push", ...push_args)));
    let to_push;
    if (component_returned_object.length > 0) {
      let pop_call = call("$.pop", object(component_returned_object));
      to_push = needs_store_cleanup ? var_builder("$$pop", pop_call) : return_builder(pop_call);
    } else {
      to_push = stmt(call("$.pop"));
    }
    component_block.body.push(to_push);
  }
  if (needs_store_cleanup) {
    component_block.body.push(stmt(call("$$cleanup")));
    if (component_returned_object.length > 0) {
      component_block.body.push(return_builder(id("$$pop")));
    }
  }
  if (analysis.uses_rest_props) {
    const named_props = analysis.exports.map(({ name, alias }) => alias ?? name);
    for (const [name, binding] of analysis.instance.scope.declarations) {
      if (binding.kind === "bindable_prop") named_props.push(binding.prop_alias ?? name);
    }
    component_block.body.unshift(
      const_builder(
        "$$restProps",
        call(
          "$.legacy_rest_props",
          id("$$sanitized_props"),
          array(named_props.map((name) => literal2(name)))
        )
      )
    );
  }
  if (analysis.uses_props || analysis.uses_rest_props) {
    const to_remove = [
      literal2("children"),
      literal2("$$slots"),
      literal2("$$events"),
      literal2("$$legacy")
    ];
    if (analysis.custom_element) {
      to_remove.push(literal2("$$host"));
    }
    component_block.body.unshift(
      const_builder(
        "$$sanitized_props",
        call("$.legacy_rest_props", id("$$props"), array(to_remove))
      )
    );
  }
  if (analysis.uses_slots) {
    component_block.body.unshift(const_builder("$$slots", call("$.sanitize_slots", id("$$props"))));
  }
  let should_inject_props = should_inject_context || analysis.needs_props || analysis.uses_props || analysis.uses_rest_props || analysis.uses_slots || analysis.slot_names.size > 0;
  const imports2 = [];
  let body = [];
  for (const entry of [...module.body, ...state.hoisted]) {
    if (entry.type === "ImportDeclaration") {
      imports2.push(entry);
    } else {
      body.push(entry);
    }
  }
  body = [...imports2, ...state.module_level_snippets, ...body];
  const component = function_declaration(
    id(analysis.name),
    should_inject_props ? [id("$$anchor"), id("$$props")] : [id("$$anchor")],
    component_block
  );
  if (options.hmr) {
    const id2 = id(analysis.name);
    const HMR = id("$.HMR");
    const existing = member(id2, HMR, true);
    const incoming = member(id("module.default"), HMR, true);
    const accept_fn_body = [
      stmt(assignment("=", member(incoming, "source"), member(existing, "source"))),
      stmt(call("$.set", member(existing, "source"), member(incoming, "original")))
    ];
    if (analysis.css.hash) {
      accept_fn_body.unshift(stmt(call("$.cleanup_styles", literal2(analysis.css.hash))));
    }
    const hmr = block([
      stmt(assignment("=", id2, call("$.hmr", id2, thunk(member(existing, "source"))))),
      stmt(call("import.meta.hot.accept", arrow([id("module")], block(accept_fn_body))))
    ]);
    body.push(component, if_builder(id("import.meta.hot"), hmr), export_default(id(analysis.name)));
  } else {
    body.push(export_default(component));
  }
  if (dev) {
    body.unshift(
      stmt(
        assignment("=", member(id(analysis.name), "$.FILENAME", true), literal2(filename))
      )
    );
  }
  if (!analysis.runes) {
    body.unshift(imports([], "svelte/internal/flags/legacy"));
  }
  if (analysis.tracing) {
    body.unshift(imports([], "svelte/internal/flags/tracing"));
  }
  if (options.discloseVersion) {
    body.unshift(imports([], "svelte/internal/disclose-version"));
  }
  if (options.compatibility.componentApi === 4) {
    body.unshift(imports([["createClassComponent", "$$_createClassComponent"]], "svelte/legacy"));
    component_block.body.unshift(
      if_builder(
        id("new.target"),
        return_builder(
          call(
            "$$_createClassComponent",
            // When called with new, the first argument is the constructor options
            object([init2("component", id(analysis.name)), spread(id("$$anchor"))])
          )
        )
      )
    );
  } else if (dev) {
    component_block.body.unshift(stmt(call("$.check_target", id("new.target"))));
  }
  if (analysis.props_id) {
    component_block.body.unshift(const_builder(analysis.props_id, call("$.props_id")));
  }
  if (state.events.size > 0) {
    body.push(
      stmt(call("$.delegate", array(Array.from(state.events).map((name) => literal2(name)))))
    );
  }
  if (analysis.custom_element) {
    const ce = analysis.custom_element;
    const ce_props = typeof ce === "boolean" ? {} : ce.props || {};
    const props_str = [];
    for (const [name, prop_def2] of Object.entries(ce_props)) {
      const binding = analysis.instance.scope.get(name);
      const key2 = (binding == null ? void 0 : binding.prop_alias) ?? name;
      if (!prop_def2.type && ((_a2 = binding == null ? void 0 : binding.initial) == null ? void 0 : _a2.type) === "Literal" && typeof (binding == null ? void 0 : binding.initial.value) === "boolean") {
        prop_def2.type = "Boolean";
      }
      const value = object(
        /** @type {ESTree.Property[]} */
        [
          prop_def2.attribute ? init2("attribute", literal2(prop_def2.attribute)) : void 0,
          prop_def2.reflect ? init2("reflect", true_instance) : void 0,
          prop_def2.type ? init2("type", literal2(prop_def2.type)) : void 0
        ].filter(Boolean)
      );
      props_str.push(init2(key2, value));
    }
    for (const [name, binding] of properties) {
      const key2 = binding.prop_alias ?? name;
      if (ce_props[key2]) continue;
      props_str.push(init2(key2, object([])));
    }
    const slots_str = array([...analysis.slot_names.keys()].map((name) => literal2(name)));
    const accessors_str = array(
      analysis.exports.map(({ name, alias }) => literal2(alias ?? name))
    );
    const use_shadow_dom = typeof ce === "boolean" || ce.shadow !== "none" ? true : false;
    const create_ce = call(
      "$.create_custom_element",
      id(analysis.name),
      object(props_str),
      slots_str,
      accessors_str,
      literal2(use_shadow_dom),
      /** @type {any} */
      typeof ce !== "boolean" ? ce.extend : void 0
    );
    if (typeof ce !== "boolean" && typeof ce.tag === "string") {
      const define2 = stmt(call("customElements.define", literal2(ce.tag), create_ce));
      if (options.hmr) {
        body.push(
          if_builder(binary("==", call("customElements.get", literal2(ce.tag)), null_instance), define2)
        );
      } else {
        body.push(define2);
      }
    } else {
      body.push(stmt(create_ce));
    }
  }
  return {
    type: "Program",
    sourceType: "module",
    body
  };
}
function client_module(analysis, options) {
  const state = {
    analysis,
    options,
    scope: analysis.module.scope,
    scopes: analysis.module.scopes,
    state_fields: /* @__PURE__ */ new Map(),
    transform: {},
    in_constructor: false
  };
  const module = (
    /** @type {ESTree.Program} */
    walk(
      /** @type {AST.SvelteNode} */
      analysis.module.ast,
      state,
      visitors5
    )
  );
  const body = [import_all("$", "svelte/internal/client")];
  if (analysis.tracing) {
    body.push(imports([], "svelte/internal/flags/tracing"));
  }
  return {
    type: "Program",
    sourceType: "module",
    body: [...body, ...module.body]
  };
}

// node_modules/svelte/src/compiler/phases/3-transform/index.js
function transform_component(analysis, source2, options) {
  if (options.generate === false) {
    return {
      js: (
        /** @type {any} */
        null
      ),
      css: null,
      warnings,
      // set afterwards
      metadata: {
        runes: analysis.runes
      },
      ast: (
        /** @type {any} */
        null
      )
      // set afterwards
    };
  }
  const program = options.generate === "server" ? server_component(analysis, options) : client_component(analysis, options);
  const js_source_name = get_source_name(options.filename, options.outputFilename, "input.svelte");
  const js2 = print(program, {
    // include source content; makes it easier/more robust looking up the source map code
    // (else esrap does return null for source and sourceMapContent which may trip up tooling)
    sourceMapContent: source2,
    sourceMapSource: js_source_name
  });
  merge_with_preprocessor_map(js2, options, js_source_name);
  const css = analysis.css.ast && !analysis.inject_styles ? render_stylesheet(source2, analysis, options) : null;
  return {
    js: js2,
    css,
    warnings,
    // set afterwards. TODO apply preprocessor sourcemap
    metadata: {
      runes: analysis.runes
    },
    ast: (
      /** @type {any} */
      null
    )
    // set afterwards
  };
}
function transform_module(analysis, source2, options) {
  if (options.generate === false) {
    return {
      js: (
        /** @type {any} */
        null
      ),
      css: null,
      warnings,
      // set afterwards
      metadata: {
        runes: true
      },
      ast: (
        /** @type {any} */
        null
      )
      // set afterwards
    };
  }
  const program = options.generate === "server" ? server_module(analysis, options) : client_module(analysis, options);
  const basename = options.filename.split(/[/\\]/).at(-1);
  if (program.body.length > 0) {
    program.body[0].leadingComments = [
      {
        type: "Block",
        value: ` ${basename} generated by Svelte v${VERSION} `
      }
    ];
  }
  return {
    js: print(program, {
      // include source content; makes it easier/more robust looking up the source map code
      // (else esrap does return null for source and sourceMapContent which may trip up tooling)
      sourceMapContent: source2,
      sourceMapSource: get_source_name(options.filename, void 0, "input.svelte.js")
    }),
    css: null,
    metadata: {
      runes: true
    },
    warnings,
    // set afterwards
    ast: (
      /** @type {any} */
      null
    )
    // set afterwards
  };
}

// node_modules/svelte/src/compiler/validate-options.js
var _a;
var common = {
  filename: string("(unknown)"),
  // default to process.cwd() where it exists to replicate svelte4 behavior (and make Deno work with this as well)
  // see https://github.com/sveltejs/svelte/blob/b62fc8c8fd2640c9b99168f01b9d958cb2f7574f/packages/svelte/src/compiler/compile/Component.js#L211
  /* eslint-disable */
  rootDir: string(
    typeof process !== "undefined" ? (_a = process.cwd) == null ? void 0 : _a.call(process) : (
      // @ts-expect-error
      typeof Deno !== "undefined" ? (
        // @ts-expect-error
        Deno.cwd()
      ) : void 0
    )
  ),
  /* eslint-enable */
  dev: boolean(false),
  generate: validator("client", (input, keypath) => {
    if (input === "dom" || input === "ssr") {
      warn_once(options_renamed_ssr_dom);
      return input === "dom" ? "client" : "server";
    }
    if (input !== "client" && input !== "server" && input !== false) {
      throw_error2(`${keypath} must be "client", "server" or false`);
    }
    return input;
  }),
  warningFilter: fun(() => true)
};
var validate_module_options = (
  /** @type {Validator<ModuleCompileOptions, ValidatedModuleCompileOptions>} */
  object3({
    ...common
  })
);
var validate_component_options = (
  /** @type {Validator<CompileOptions, ValidatedCompileOptions>} */
  object3({
    ...common,
    accessors: deprecate(options_deprecated_accessors, boolean(false)),
    css: validator("external", (input) => {
      if (input === true || input === false) {
        throw_error2(
          'The boolean options have been removed from the css option. Use "external" instead of false and "injected" instead of true'
        );
      }
      if (input === "none") {
        throw_error2(
          'css: "none" is no longer a valid option. If this was crucial for you, please open an issue on GitHub with your use case.'
        );
      }
      if (input !== "external" && input !== "injected") {
        throw_error2(`css should be either "external" (default, recommended) or "injected"`);
      }
      return input;
    }),
    cssHash: fun(({ css, hash: hash2 }) => {
      return `svelte-${hash2(css)}`;
    }),
    // TODO this is a sourcemap option, would be good to put under a sourcemap namespace
    cssOutputFilename: string(void 0),
    customElement: boolean(false),
    discloseVersion: boolean(true),
    immutable: deprecate(options_deprecated_immutable, boolean(false)),
    legacy: removed(
      "The legacy option has been removed. If you are using this because of legacy.componentApi, use compatibility.componentApi instead"
    ),
    compatibility: object3({
      componentApi: list2([4, 5], 5)
    }),
    loopGuardTimeout: warn_removed(options_removed_loop_guard_timeout),
    name: string(void 0),
    namespace: list2(["html", "mathml", "svg"]),
    modernAst: boolean(false),
    outputFilename: string(void 0),
    preserveComments: boolean(false),
    fragments: list2(["html", "tree"]),
    preserveWhitespace: boolean(false),
    runes: boolean(void 0),
    hmr: boolean(false),
    sourcemap: validator(void 0, (input) => {
      return input;
    }),
    enableSourcemap: warn_removed(options_removed_enable_sourcemap),
    hydratable: warn_removed(options_removed_hydratable),
    format: removed(
      'The format option has been removed in Svelte 4, the compiler only outputs ESM now. Remove "format" from your compiler options. If you did not set this yourself, bump the version of your bundler plugin (vite-plugin-svelte/rollup-plugin-svelte/svelte-loader)'
    ),
    tag: removed(
      'The tag option has been removed in Svelte 5. Use `<svelte:options customElement="tag-name" />` inside the component instead. If that does not solve your use case, please open an issue on GitHub with details.'
    ),
    sveltePath: removed(
      "The sveltePath option has been removed in Svelte 5. If this option was crucial for you, please open an issue on GitHub with your use case."
    ),
    // These two were primarily created for svelte-preprocess (https://github.com/sveltejs/svelte/pull/6194),
    // but with new TypeScript compilation modes strictly separating types it's not necessary anymore
    errorMode: removed(
      "The errorMode option has been removed. If you are using this through svelte-preprocess with TypeScript, use the https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax setting instead"
    ),
    varsReport: removed(
      "The vars option has been removed. If you are using this through svelte-preprocess with TypeScript, use the https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax setting instead"
    )
  })
);
function removed(msg) {
  return (input) => {
    if (input !== void 0) {
      options_removed(null, msg);
    }
    return (
      /** @type {any} */
      void 0
    );
  };
}
var warned2 = /* @__PURE__ */ new Set();
function warn_once(fn) {
  if (!warned2.has(fn)) {
    warned2.add(fn);
    fn(null);
  }
}
function warn_removed(fn) {
  return (input) => {
    if (input !== void 0) warn_once(fn);
    return (
      /** @type {any} */
      void 0
    );
  };
}
function deprecate(fn, validator2) {
  return (input, keypath) => {
    if (input !== void 0) warn_once(fn);
    return validator2(input, keypath);
  };
}
function object3(children, allow_unknown = false) {
  return (input, keypath) => {
    const output = {};
    if (input && typeof input !== "object" || Array.isArray(input)) {
      throw_error2(`${keypath} should be an object`);
    }
    for (const key2 in input) {
      if (!(key2 in children)) {
        if (allow_unknown) {
          output[key2] = input[key2];
        } else {
          options_unrecognised(null, `${keypath ? `${keypath}.${key2}` : key2}`);
        }
      }
    }
    for (const key2 in children) {
      const validator2 = children[key2];
      output[key2] = validator2(input && input[key2], keypath ? `${keypath}.${key2}` : key2);
    }
    return output;
  };
}
function validator(fallback, fn) {
  return (input, keypath) => {
    return input === void 0 ? fallback : fn(input, keypath);
  };
}
function string(fallback, allow_empty = true) {
  return validator(fallback, (input, keypath) => {
    if (typeof input !== "string") {
      throw_error2(`${keypath} should be a string, if specified`);
    }
    if (!allow_empty && input === "") {
      throw_error2(`${keypath} cannot be empty`);
    }
    return input;
  });
}
function boolean(fallback) {
  return validator(fallback, (input, keypath) => {
    if (typeof input !== "boolean") {
      throw_error2(`${keypath} should be true or false, if specified`);
    }
    return input;
  });
}
function list2(options, fallback = options[0]) {
  return validator(fallback, (input, keypath) => {
    if (!options.includes(input)) {
      const msg = options.length > 2 ? `${keypath} should be one of ${options.slice(0, -1).map((input2) => `"${input2}"`).join(", ")} or "${options[options.length - 1]}"` : `${keypath} should be either "${options[0]}" or "${options[1]}"`;
      throw_error2(msg);
    }
    return input;
  });
}
function fun(fallback) {
  return validator(fallback, (input, keypath) => {
    if (typeof input !== "function") {
      throw_error2(`${keypath} should be a function, if specified`);
    }
    return input;
  });
}
function throw_error2(msg) {
  options_invalid_value(null, msg);
}

// node_modules/svelte/src/compiler/preprocess/decode_sourcemap.js
var import_sourcemap_codec3 = __toESM(require_sourcemap_codec_umd(), 1);
function decoded_sourcemap_from_generator(generator) {
  let previous_generated_line = 1;
  const converted_mappings = [[]];
  let result_line = converted_mappings[0];
  let result_segment;
  let mapping;
  const source_idx = generator._sources.toArray().reduce((acc, val, idx) => (acc[val] = idx, acc), {});
  const name_idx = generator._names.toArray().reduce((acc, val, idx) => (acc[val] = idx, acc), {});
  const mappings = generator._mappings.toArray();
  for (let i = 0, len = mappings.length; i < len; i++) {
    mapping = mappings[i];
    if (mapping.generatedLine > previous_generated_line) {
      while (mapping.generatedLine > previous_generated_line) {
        converted_mappings.push([]);
        previous_generated_line++;
      }
      result_line = converted_mappings[mapping.generatedLine - 1];
    } else if (i > 0) {
      const previous_mapping = mappings[i - 1];
      if (
        // sorted by selectivity
        mapping.generatedColumn === previous_mapping.generatedColumn && mapping.originalColumn === previous_mapping.originalColumn && mapping.name === previous_mapping.name && mapping.generatedLine === previous_mapping.generatedLine && mapping.originalLine === previous_mapping.originalLine && mapping.source === previous_mapping.source
      ) {
        continue;
      }
    }
    result_line.push([mapping.generatedColumn]);
    result_segment = result_line[result_line.length - 1];
    if (mapping.source != null) {
      result_segment.push(
        ...[source_idx[mapping.source], mapping.originalLine - 1, mapping.originalColumn]
      );
      if (mapping.name != null) {
        result_segment.push(name_idx[mapping.name]);
      }
    }
  }
  const map = {
    version: generator._version,
    sources: generator._sources.toArray(),
    names: generator._names.toArray(),
    mappings: converted_mappings
  };
  if (generator._file != null) {
    map.file = generator._file;
  }
  return map;
}
function decode_map(processed) {
  let decoded_map = typeof processed.map === "string" ? JSON.parse(processed.map) : processed.map;
  if (typeof decoded_map.mappings === "string") {
    decoded_map.mappings = (0, import_sourcemap_codec3.decode)(decoded_map.mappings);
  }
  if (decoded_map._mappings && decoded_map.constructor.name === "SourceMapGenerator") {
    decoded_map = decoded_sourcemap_from_generator(decoded_map);
  }
  return decoded_map;
}

// node_modules/svelte/src/compiler/preprocess/replace_in_code.js
function slice_source(code_slice, offset2, { file_basename, filename: filename2, get_location }) {
  return {
    source: code_slice,
    get_location: (index) => get_location(index + offset2),
    file_basename,
    filename: filename2
  };
}
function calculate_replacements(re, get_replacement, source2) {
  const replacements3 = [];
  source2.replace(re, (...match) => {
    replacements3.push(
      get_replacement(...match).then((replacement) => {
        const matched_string = match[0];
        const offset2 = match[match.length - 2];
        return { offset: offset2, length: matched_string.length, replacement };
      })
    );
    return "";
  });
  return Promise.all(replacements3);
}
function perform_replacements(replacements3, source2) {
  const out = new MappedCode();
  let last_end = 0;
  for (const { offset: offset2, length, replacement } of replacements3) {
    const unchanged_prefix = MappedCode.from_source(
      slice_source(source2.source.slice(last_end, offset2), last_end, source2)
    );
    out.concat(unchanged_prefix).concat(replacement);
    last_end = offset2 + length;
  }
  const unchanged_suffix = MappedCode.from_source(
    slice_source(source2.source.slice(last_end), last_end, source2)
  );
  return out.concat(unchanged_suffix);
}
async function replace_in_code(regex, get_replacement, location) {
  const replacements3 = await calculate_replacements(regex, get_replacement, location.source);
  return perform_replacements(replacements3, location);
}

// node_modules/svelte/src/compiler/preprocess/index.js
var PreprocessResult = class {
  /**
   * @param {string} source
   * @param {string} [filename]
   */
  constructor(source2, filename2) {
    /** @type {string} */
    __publicField(this, "source");
    /** @type {string | undefined} The filename passed as-is to preprocess */
    __publicField(this, "filename");
    // sourcemap_list is sorted in reverse order from last map (index 0) to first map (index -1)
    // so we use sourcemap_list.unshift() to add new maps
    // https://github.com/ampproject/remapping#multiple-transformations-of-a-file
    /**
     * @default []
     * @type {Array<DecodedSourceMap | RawSourceMap>}
     */
    __publicField(this, "sourcemap_list", []);
    /**
     * @default []
     * @type {string[]}
     */
    __publicField(this, "dependencies", []);
    /**
     * @type {string | null} last part of the filename, as used for `sources` in sourcemaps
     */
    __publicField(this, "file_basename");
    /**
     * @type {ReturnType<typeof getLocator>}
     */
    __publicField(this, "get_location");
    this.source = source2;
    this.filename = filename2;
    this.update_source({ string: source2 });
    this.file_basename = filename2 == null ? null : get_basename(filename2);
  }
  /**
   * @param {SourceUpdate} opts
   */
  update_source({ string: source2, map, dependencies }) {
    if (source2 != null) {
      this.source = source2;
      this.get_location = getLocator(source2);
    }
    if (map) {
      this.sourcemap_list.unshift(map);
    }
    if (dependencies) {
      this.dependencies.push(...dependencies);
    }
  }
  /**
   * @returns {Processed}
   */
  to_processed() {
    const map = combine_sourcemaps(this.file_basename, this.sourcemap_list);
    return {
      // TODO return separated output, in future version where svelte.compile supports it:
      // style: { code: styleCode, map: styleMap },
      // script { code: scriptCode, map: scriptMap },
      // markup { code: markupCode, map: markupMap },
      code: this.source,
      dependencies: [...new Set(this.dependencies)],
      // @ts-expect-error TODO there might be a bug in hiding here
      map,
      toString: () => this.source
    };
  }
};
function processed_content_to_code(processed, location, file_basename) {
  let decoded_map = void 0;
  if (processed.map) {
    decoded_map = decode_map(processed);
    if (decoded_map == null ? void 0 : decoded_map.sources) {
      const source_index = decoded_map.sources.indexOf(file_basename);
      if (source_index !== -1) {
        sourcemap_add_offset(decoded_map, location, source_index);
      }
    }
  }
  return MappedCode.from_processed(processed.code, decoded_map);
}
function processed_tag_to_code(processed, tag_name, original_attributes, generated_attributes, source2) {
  const { file_basename, get_location } = source2;
  const build_mapped_code = (code, offset2) => MappedCode.from_source(slice_source(code, offset2, source2));
  const original_tag_open = `<${tag_name}${original_attributes}>`;
  const tag_open = `<${tag_name}${generated_attributes}>`;
  let tag_open_code;
  if (original_tag_open.length !== tag_open.length) {
    const mappings = [
      [
        // start of tag
        [0, 0, 0, 0],
        // end of tag start
        [`<${tag_name}`.length, 0, 0, `<${tag_name}`.length]
      ]
    ];
    const line = tag_open.split("\n").length - 1;
    const column = tag_open.length - (line === 0 ? 0 : tag_open.lastIndexOf("\n")) - 1;
    while (mappings.length <= line) {
      mappings.push([[0, 0, 0, `<${tag_name}`.length]]);
    }
    mappings[line].push([
      column,
      0,
      original_tag_open.split("\n").length - 1,
      original_tag_open.length - original_tag_open.lastIndexOf("\n") - 1
    ]);
    const map = {
      version: 3,
      names: [],
      sources: [file_basename],
      mappings
    };
    sourcemap_add_offset(map, get_location(0), 0);
    tag_open_code = MappedCode.from_processed(tag_open, map);
  } else {
    tag_open_code = build_mapped_code(tag_open, 0);
  }
  const tag_close = `</${tag_name}>`;
  const tag_close_code = build_mapped_code(
    tag_close,
    original_tag_open.length + source2.source.length
  );
  parse_attached_sourcemap(processed, tag_name);
  const content_code = processed_content_to_code(
    processed,
    get_location(original_tag_open.length),
    file_basename
  );
  return tag_open_code.concat(content_code).concat(tag_close_code);
}
var attribute_pattern = /([\w-$]+\b)(?:=(?:"([^"]*)"|'([^']*)'|(\S+)))?/g;
function parse_tag_attributes(str) {
  const attrs = {};
  let match;
  while ((match = attribute_pattern.exec(str)) !== null) {
    const name = match[1];
    const value = match[2] || match[3] || match[4];
    attrs[name] = !value || value;
  }
  return attrs;
}
function stringify_tag_attributes(attributes) {
  if (!attributes) return;
  let value = Object.entries(attributes).map(([key2, value2]) => value2 === true ? key2 : `${key2}="${value2}"`).join(" ");
  if (value) {
    value = " " + value;
  }
  return value;
}
var regex_style_tags = /<!--[^]*?-->|<style((?:\s+[^=>'"/\s]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"/\s]+)*\s*)(?:\/>|>([\S\s]*?)<\/style>)/g;
var regex_script_tags = /<!--[^]*?-->|<script((?:\s+[^=>'"/\s]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"/\s]+)*\s*)(?:\/>|>([\S\s]*?)<\/script>)/g;
async function process_tag(tag_name, preprocessor, source2) {
  const { filename: filename2, source: markup } = source2;
  const tag_regex = tag_name === "style" ? regex_style_tags : regex_script_tags;
  const dependencies = [];
  async function process_single_tag(tag_with_content, attributes = "", content = "", tag_offset) {
    const no_change = () => MappedCode.from_source(slice_source(tag_with_content, tag_offset, source2));
    if (!attributes && !content) return no_change();
    const processed = await preprocessor({
      content: content || "",
      attributes: parse_tag_attributes(attributes || ""),
      markup,
      filename: filename2
    });
    if (!processed) return no_change();
    if (processed.dependencies) dependencies.push(...processed.dependencies);
    if (!processed.map && processed.code === content) return no_change();
    return processed_tag_to_code(
      processed,
      tag_name,
      attributes,
      stringify_tag_attributes(processed.attributes) ?? attributes,
      slice_source(content, tag_offset, source2)
    );
  }
  const { string: string2, map } = await replace_in_code(tag_regex, process_single_tag, source2);
  return { string: string2, map, dependencies };
}
async function process_markup(process9, source2) {
  const processed = await process9({
    content: source2.source,
    filename: source2.filename
  });
  if (processed) {
    return {
      string: processed.code,
      map: processed.map ? (
        // TODO: can we use decode_sourcemap?
        typeof processed.map === "string" ? JSON.parse(processed.map) : processed.map
      ) : void 0,
      dependencies: processed.dependencies
    };
  } else {
    return {};
  }
}
async function preprocess(source2, preprocessor, options) {
  const filename2 = options && options.filename || /** @type {any} */
  preprocessor.filename;
  const preprocessors = preprocessor ? Array.isArray(preprocessor) ? preprocessor : [preprocessor] : [];
  const result = new PreprocessResult(source2, filename2);
  for (const preprocessor2 of preprocessors) {
    if (preprocessor2.markup) {
      result.update_source(await process_markup(preprocessor2.markup, result));
    }
    if (preprocessor2.script) {
      result.update_source(await process_tag("script", preprocessor2.script, result));
    }
    if (preprocessor2.style) {
      result.update_source(await process_tag("style", preprocessor2.style, result));
    }
  }
  return result.to_processed();
}

// node_modules/svelte/src/compiler/index.js
function compile(source2, options) {
  var _a2, _b;
  source2 = remove_bom(source2);
  reset_warning_filter(options.warningFilter);
  const validated = validate_component_options(options, "");
  reset2(source2, validated);
  let parsed = parse5(source2);
  const { customElement: customElementOptions, ...parsed_options } = parsed.options || {};
  const combined_options = {
    ...validated,
    ...parsed_options,
    customElementOptions
  };
  if (parsed.metadata.ts) {
    parsed = {
      ...parsed,
      fragment: parsed.fragment && remove_typescript_nodes(parsed.fragment),
      instance: parsed.instance && remove_typescript_nodes(parsed.instance),
      module: parsed.module && remove_typescript_nodes(parsed.module)
    };
    if ((_a2 = combined_options.customElementOptions) == null ? void 0 : _a2.extend) {
      combined_options.customElementOptions.extend = remove_typescript_nodes(
        (_b = combined_options.customElementOptions) == null ? void 0 : _b.extend
      );
    }
  }
  const analysis = analyze_component(parsed, source2, combined_options);
  const result = transform_component(analysis, source2, combined_options);
  result.ast = to_public_ast(source2, parsed, options.modernAst);
  return result;
}
function compileModule(source2, options) {
  source2 = remove_bom(source2);
  reset_warning_filter(options.warningFilter);
  const validated = validate_module_options(options, "");
  reset2(source2, validated);
  const analysis = analyze_module(parse4(source2, false), validated);
  return transform_module(analysis, source2, validated);
}
function to_public_ast(source2, ast, modern) {
  var _a2;
  if (modern) {
    const clean = (node) => {
      delete node.metadata;
    };
    (_a2 = ast.options) == null ? void 0 : _a2.attributes.forEach((attribute) => {
      clean(attribute);
      clean(attribute.value);
      if (Array.isArray(attribute.value)) {
        attribute.value.forEach(clean);
      }
    });
    return walk(ast, null, {
      _(node, { next: next2 }) {
        clean(node);
        next2();
      }
    });
  }
  return convert(source2, ast);
}
function remove_bom(source2) {
  if (source2.charCodeAt(0) === 65279) {
    return source2.slice(1);
  }
  return source2;
}

// node_modules/@sveltejs/vite-plugin-svelte/src/utils/hash.js
var import_node_crypto = __toESM(require_node_crypto(), 1);
var hashes = /* @__PURE__ */ Object.create(null);
var hash_length = 12;
function safeBase64Hash(input) {
  if (hashes[input]) {
    return hashes[input];
  }
  const md5 = import_node_crypto.default.createHash("md5");
  md5.update(input);
  const hash2 = toSafe(md5.digest("base64")).slice(0, hash_length);
  hashes[input] = hash2;
  return hash2;
}
var replacements2 = {
  "+": "-",
  "/": "_",
  "=": ""
};
var replaceRE = new RegExp(`[${Object.keys(replacements2).join("")}]`, "g");
function toSafe(base64) {
  return base64.replace(replaceRE, (x) => replacements2[x]);
}

// node_modules/@sveltejs/vite-plugin-svelte/src/utils/preprocess.js
var import_node_path2 = __toESM(require_node_path(), 1);
function createInjectScopeEverythingRulePreprocessorGroup() {
  return {
    name: "inject-scope-everything-rule",
    style({ content, filename: filename2 }) {
      const s = new MagicString(content);
      s.append(" *{}");
      return {
        code: s.toString(),
        map: s.generateDecodedMap({
          source: filename2 ? import_node_path2.default.basename(filename2) : void 0,
          hires: true
        })
      };
    }
  };
}
function buildExtraPreprocessors(options, config) {
  var _a2;
  const prependPreprocessors = [];
  const appendPreprocessors = [];
  const pluginsWithPreprocessorsDeprecated = config.plugins.filter((p) => p == null ? void 0 : p.sveltePreprocess);
  if (pluginsWithPreprocessorsDeprecated.length > 0) {
    log.warn(
      `The following plugins use the deprecated 'plugin.sveltePreprocess' field. Please contact their maintainers and ask them to move it to 'plugin.api.sveltePreprocess': ${pluginsWithPreprocessorsDeprecated.map((p) => p.name).join(", ")}`
    );
    pluginsWithPreprocessorsDeprecated.forEach((p) => {
      if (!p.api) {
        p.api = {};
      }
      if (p.api.sveltePreprocess === void 0) {
        p.api.sveltePreprocess = p.sveltePreprocess;
      } else {
        log.error(
          `ignoring plugin.sveltePreprocess of ${p.name} because it already defined plugin.api.sveltePreprocess.`
        );
      }
    });
  }
  const pluginsWithPreprocessors = config.plugins.filter((p) => {
    var _a3;
    return (_a3 = p == null ? void 0 : p.api) == null ? void 0 : _a3.sveltePreprocess;
  });
  const ignored = [];
  const included = [];
  for (const p of pluginsWithPreprocessors) {
    if (options.ignorePluginPreprocessors === true || Array.isArray(options.ignorePluginPreprocessors) && ((_a2 = options.ignorePluginPreprocessors) == null ? void 0 : _a2.includes(p.name))) {
      ignored.push(p);
    } else {
      included.push(p);
    }
  }
  if (ignored.length > 0) {
    log.debug(
      `Ignoring svelte preprocessors defined by these vite plugins: ${ignored.map((p) => p.name).join(", ")}`,
      void 0,
      "preprocess"
    );
  }
  if (included.length > 0) {
    log.debug(
      `Adding svelte preprocessors defined by these vite plugins: ${included.map((p) => p.name).join(", ")}`,
      void 0,
      "preprocess"
    );
    appendPreprocessors.push(...pluginsWithPreprocessors.map((p) => p.api.sveltePreprocess));
  }
  return { prependPreprocessors, appendPreprocessors };
}
function addExtraPreprocessors(options, config) {
  const { prependPreprocessors, appendPreprocessors } = buildExtraPreprocessors(options, config);
  if (prependPreprocessors.length > 0 || appendPreprocessors.length > 0) {
    if (!options.preprocess) {
      options.preprocess = [...prependPreprocessors, ...appendPreprocessors];
    } else if (Array.isArray(options.preprocess)) {
      options.preprocess.unshift(...prependPreprocessors);
      options.preprocess.push(...appendPreprocessors);
    } else {
      options.preprocess = [...prependPreprocessors, options.preprocess, ...appendPreprocessors];
    }
  }
}
function checkPreprocessDependencies(filename2, dependencies) {
  const warnings2 = [];
  const selfIdx = [];
  const normalizedFullFilename = normalizePath$3(filename2);
  const normalizedDeps = dependencies.map(normalizePath$3);
  for (let i = 0; i < normalizedDeps.length; i++) {
    if (normalizedDeps[i] === normalizedFullFilename) {
      selfIdx.push(i);
    }
  }
  const hasSelfDependency = selfIdx.length > 0;
  if (hasSelfDependency) {
    warnings2.push({
      code: "vite-plugin-svelte-preprocess-depends-on-self",
      message: "svelte.preprocess returned this file as a dependency of itself. This can be caused by an invalid configuration or importing generated code that depends on .svelte files (eg. tailwind base css)",
      filename: filename2
    });
  }
  if (dependencies.length > 10) {
    warnings2.push({
      code: "vite-plugin-svelte-preprocess-many-dependencies",
      message: `svelte.preprocess depends on more than 10 external files which can cause slow builds and poor DX, try to reduce them. Found: ${dependencies.join(
        ", "
      )}`,
      filename: filename2
    });
  }
  return {
    dependencies: hasSelfDependency ? dependencies.filter((_, i) => !selfIdx.includes(i)) : dependencies,
    warnings: warnings2
  };
}

// node_modules/@sveltejs/vite-plugin-svelte/src/utils/sourcemaps.js
var import_node_path3 = __toESM(require_node_path(), 1);
var import_node_process2 = __toESM(require_node_process(), 1);
var IS_WINDOWS = import_node_process2.default.platform === "win32";
function mapToRelative(map, filename2) {
  if (!map) {
    return;
  }
  const sourceRoot = map.sourceRoot;
  const dirname2 = import_node_path3.default.dirname(filename2);
  const toRelative = (s) => {
    if (!s) {
      return s;
    }
    let sourcePath;
    if (s.startsWith("file:///")) {
      sourcePath = s.slice(IS_WINDOWS ? 8 : 7);
    } else if (sourceRoot) {
      const sep = sourceRoot[sourceRoot.length - 1] === "/" || s[0] === "/" ? "" : "/";
      sourcePath = `${sourceRoot}${sep}${s}`;
    } else {
      sourcePath = s;
    }
    return import_node_path3.default.isAbsolute(sourcePath) ? import_node_path3.default.relative(dirname2, sourcePath) : sourcePath;
  };
  if (map.file) {
    map.file = import_node_path3.default.basename(filename2);
  }
  if (map.sources) {
    map.sources = map.sources.map(toRelative);
  }
  if (map.sourceRoot) {
    delete map.sourceRoot;
  }
}
function removeLangSuffix(map, suffix) {
  if (!map) {
    return;
  }
  const removeSuffix = (s) => (s == null ? void 0 : s.endsWith(suffix)) ? s.slice(0, -1 * suffix.length) : s;
  if (map.file) {
    map.file = removeSuffix(map.file);
  }
  if (map.sources) {
    map.sources = map.sources.map(removeSuffix);
  }
}

// node_modules/@sveltejs/vite-plugin-svelte/src/utils/compile.js
var scriptLangRE = /<!--[^]*?-->|<script\s+(?:[^>]*|(?:[^=>'"/]+=(?:"[^"]*"|'[^']*'|[^>\s]+)\s+)*)lang=(["'])?([^"' >]+)\1[^>]*>/g;
function createCompileSvelte() {
  let stats;
  const devStylePreprocessor = createInjectScopeEverythingRulePreprocessorGroup();
  return async function compileSvelte2(svelteRequest, code, options) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    const { filename: filename2, normalizedFilename, cssId, ssr, raw } = svelteRequest;
    const { emitCss = true } = options;
    const dependencies = [];
    const warnings2 = [];
    if (options.stats) {
      if (options.isBuild) {
        if (!stats) {
          stats = options.stats.startCollection(`${ssr ? "ssr" : "dom"} compile`, {
            logInProgress: () => false
          });
        }
      } else {
        if (ssr && !stats) {
          stats = options.stats.startCollection("ssr compile");
        }
        if (!ssr && stats) {
          stats.finish();
          stats = void 0;
        }
      }
    }
    const compileOptions = {
      ...options.compilerOptions,
      filename: filename2,
      generate: ssr ? "server" : "client"
    };
    if (compileOptions.hmr && options.emitCss) {
      const hash2 = `s-${safeBase64Hash(normalizedFilename)}`;
      compileOptions.cssHash = () => hash2;
    }
    let preprocessed;
    let preprocessors = options.preprocess;
    if (!options.isBuild && options.emitCss && compileOptions.hmr) {
      if (!Array.isArray(preprocessors)) {
        preprocessors = preprocessors ? [preprocessors, devStylePreprocessor] : [devStylePreprocessor];
      } else {
        preprocessors = preprocessors.concat(devStylePreprocessor);
      }
    }
    if (preprocessors) {
      try {
        preprocessed = await preprocess(code, preprocessors, { filename: filename2 });
      } catch (e2) {
        e2.message = `Error while preprocessing ${filename2}${e2.message ? ` - ${e2.message}` : ""}`;
        throw e2;
      }
      if ((_a2 = preprocessed.dependencies) == null ? void 0 : _a2.length) {
        const checked = checkPreprocessDependencies(filename2, preprocessed.dependencies);
        if (checked.warnings.length) {
          warnings2.push(...checked.warnings);
        }
        if (checked.dependencies.length) {
          dependencies.push(...checked.dependencies);
        }
      }
      if (preprocessed.map) compileOptions.sourcemap = preprocessed.map;
    }
    if (typeof (preprocessed == null ? void 0 : preprocessed.map) === "object") {
      mapToRelative(preprocessed == null ? void 0 : preprocessed.map, filename2);
    }
    if (raw && svelteRequest.query.type === "preprocessed") {
      return (
        /** @type {import('../types/compile.d.ts').CompileData} */
        {
          preprocessed: preprocessed ?? { code }
        }
      );
    }
    const finalCode = preprocessed ? preprocessed.code : code;
    const dynamicCompileOptions = await ((_b = options == null ? void 0 : options.dynamicCompileOptions) == null ? void 0 : _b.call(options, {
      filename: filename2,
      code: finalCode,
      compileOptions
    }));
    if (dynamicCompileOptions && log.debug.enabled) {
      log.debug(
        `dynamic compile options for  ${filename2}: ${JSON.stringify(dynamicCompileOptions)}`,
        void 0,
        "compile"
      );
    }
    const finalCompileOptions = dynamicCompileOptions ? {
      ...compileOptions,
      ...dynamicCompileOptions
    } : compileOptions;
    const endStat = stats == null ? void 0 : stats.start(filename2);
    let compiled;
    try {
      compiled = compile(finalCode, { ...finalCompileOptions, filename: filename2 });
      if (((_c = options.server) == null ? void 0 : _c.config.experimental.hmrPartialAccept) && compiled.js.code.includes("import.meta.hot.accept(")) {
        compiled.js.code = compiled.js.code.replaceAll(
          "import.meta.hot.accept(",
          'import.meta.hot.acceptExports(["default"],'
        );
      }
    } catch (e2) {
      enhanceCompileError(e2, code, preprocessors);
      throw e2;
    }
    if (endStat) {
      endStat();
    }
    mapToRelative((_d = compiled.js) == null ? void 0 : _d.map, filename2);
    mapToRelative((_e = compiled.css) == null ? void 0 : _e.map, filename2);
    if (warnings2.length) {
      if (!compiled.warnings) {
        compiled.warnings = [];
      }
      compiled.warnings.push(...warnings2);
    }
    if (!raw) {
      const hasCss = ((_h = (_g = (_f = compiled.css) == null ? void 0 : _f.code) == null ? void 0 : _g.trim()) == null ? void 0 : _h.length) ?? 0 > 0;
      if (emitCss && hasCss) {
        compiled.js.code += `
import ${JSON.stringify(cssId)};
`;
      }
    }
    let lang = "js";
    for (const match of code.matchAll(scriptLangRE)) {
      if (match[2]) {
        lang = match[2];
        break;
      }
    }
    return {
      filename: filename2,
      normalizedFilename,
      lang,
      compiled,
      ssr,
      dependencies,
      preprocessed: preprocessed ?? { code }
    };
  };
}

// node_modules/@sveltejs/vite-plugin-svelte/src/utils/id.js
var import_node_fs2 = __toESM(require_node_fs(), 1);
var import_node_path4 = __toESM(require_node_path(), 1);
var import_node_process3 = __toESM(require_node_process(), 1);

// node_modules/@sveltejs/vite-plugin-svelte/src/utils/constants.js
var import_node_module = __toESM(require_node_module(), 1);
var VITE_RESOLVE_MAIN_FIELDS = ["browser", "module", "jsnext:main", "jsnext"];
var SVELTE_RESOLVE_MAIN_FIELDS = ["svelte"];
var SVELTE_IMPORTS = Object.entries(
  (0, import_node_module.createRequire)(import.meta.url)("svelte/package.json").exports
).map(([name, config]) => {
  if (typeof config === "object" && Object.keys(config).length === 1 && config.types) {
    return "";
  }
  if (name === "./package.json" || name === "./compiler") {
    return "";
  }
  return name.replace(/^\./, "svelte");
}).filter((s) => s.length > 0);
var SVELTE_EXPORT_CONDITIONS = ["svelte"];
var FAQ_LINK_MISSING_EXPORTS_CONDITION = "https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/faq.md#missing-exports-condition";
var DEFAULT_SVELTE_EXT = [".svelte"];
var DEFAULT_SVELTE_MODULE_INFIX = [".svelte."];
var DEFAULT_SVELTE_MODULE_EXT = [".js", ".ts"];

// node_modules/@sveltejs/vite-plugin-svelte/src/utils/id.js
var VITE_FS_PREFIX = "/@fs/";
var IS_WINDOWS2 = import_node_process3.default.platform === "win32";
var SUPPORTED_COMPILER_OPTIONS = ["generate", "dev", "css", "customElement", "immutable"];
var TYPES_WITH_COMPILER_OPTIONS = ["style", "script", "all"];
function splitId(id2) {
  const parts = id2.split("?", 2);
  const filename2 = parts[0];
  const rawQuery = parts[1];
  return { filename: filename2, rawQuery };
}
function parseToSvelteRequest(id2, filename2, rawQuery, root, timestamp, ssr) {
  const query = parseRequestQuery(rawQuery);
  const rawOrDirect = !!(query.raw || query.direct);
  if (query.url || !query.svelte && rawOrDirect) {
    return;
  }
  const raw = rawOrDirect;
  const normalizedFilename = normalize(filename2, root);
  const cssId = createVirtualImportId(filename2, root, "style");
  return {
    id: id2,
    filename: filename2,
    normalizedFilename,
    cssId,
    query,
    timestamp,
    ssr,
    raw
  };
}
function createVirtualImportId(filename2, root, type) {
  const parts = ["svelte", `type=${type}`];
  if (type === "style") {
    parts.push("lang.css");
  }
  if (existsInRoot(filename2, root)) {
    filename2 = root + filename2;
  } else if (filename2.startsWith(VITE_FS_PREFIX)) {
    filename2 = IS_WINDOWS2 ? filename2.slice(VITE_FS_PREFIX.length) : filename2.slice(VITE_FS_PREFIX.length - 1);
  }
  return `${filename2}?${parts.join("&")}`;
}
function parseRequestQuery(rawQuery) {
  const query = Object.fromEntries(new URLSearchParams(rawQuery));
  for (const key2 in query) {
    if (query[key2] === "") {
      query[key2] = true;
    }
  }
  const compilerOptions = query.compilerOptions;
  if (compilerOptions) {
    if (!((query.raw || query.direct) && TYPES_WITH_COMPILER_OPTIONS.includes(query.type))) {
      throw new Error(
        `Invalid compilerOptions in query ${rawQuery}. CompilerOptions are only supported for raw or direct queries with type in "${TYPES_WITH_COMPILER_OPTIONS.join(
          ", "
        )}" e.g. '?svelte&raw&type=script&compilerOptions={"generate":"server","dev":false}`
      );
    }
    try {
      const parsed = JSON.parse(compilerOptions);
      const invalid = Object.keys(parsed).filter(
        (key2) => !SUPPORTED_COMPILER_OPTIONS.includes(key2)
      );
      if (invalid.length) {
        throw new Error(
          `Invalid compilerOptions in query ${rawQuery}: ${invalid.join(
            ", "
          )}. Supported: ${SUPPORTED_COMPILER_OPTIONS.join(", ")}`
        );
      }
      query.compilerOptions = parsed;
    } catch (e2) {
      log.error("failed to parse request query compilerOptions", e2);
      throw e2;
    }
  }
  return (
    /** @type {import('../types/id.d.ts').RequestQuery}*/
    query
  );
}
function normalize(filename2, normalizedRoot) {
  return stripRoot(normalizePath$3(filename2), normalizedRoot);
}
function existsInRoot(filename2, root) {
  if (filename2.startsWith(VITE_FS_PREFIX)) {
    return false;
  }
  return import_node_fs2.default.existsSync(root + filename2);
}
function stripRoot(normalizedFilename, normalizedRoot) {
  return normalizedFilename.startsWith(normalizedRoot + "/") ? normalizedFilename.slice(normalizedRoot.length) : normalizedFilename;
}
function buildFilter(include, exclude, extensions) {
  const rollupFilter = createFilter(include, exclude);
  return (filename2) => rollupFilter(filename2) && extensions.some((ext) => filename2.endsWith(ext));
}
function buildModuleFilter(include, exclude, infixes, extensions) {
  const rollupFilter = createFilter(include, exclude);
  return (filename2) => {
    const basename = import_node_path4.default.basename(filename2);
    return rollupFilter(filename2) && infixes.some((infix) => basename.includes(infix)) && extensions.some((ext) => basename.endsWith(ext));
  };
}
function buildIdParser(options) {
  const { include, exclude, extensions, root } = options;
  const normalizedRoot = normalizePath$3(root);
  const filter = buildFilter(include, exclude, extensions ?? []);
  return (id2, ssr, timestamp = Date.now()) => {
    const { filename: filename2, rawQuery } = splitId(id2);
    if (filter(filename2)) {
      return parseToSvelteRequest(id2, filename2, rawQuery, normalizedRoot, timestamp, ssr);
    }
  };
}
function buildModuleIdParser(options) {
  var _a2;
  const {
    include,
    exclude,
    infixes = DEFAULT_SVELTE_MODULE_INFIX,
    extensions = DEFAULT_SVELTE_MODULE_EXT
  } = ((_a2 = options == null ? void 0 : options.experimental) == null ? void 0 : _a2.compileModule) ?? {};
  const root = options.root;
  const normalizedRoot = normalizePath$3(root);
  const filter = buildModuleFilter(include, exclude, infixes, extensions);
  return (id2, ssr, timestamp = Date.now()) => {
    const { filename: filename2, rawQuery } = splitId(id2);
    if (filter(filename2)) {
      return parseToSvelteModuleRequest(id2, filename2, rawQuery, normalizedRoot, timestamp, ssr);
    }
  };
}
function parseToSvelteModuleRequest(id2, filename2, rawQuery, root, timestamp, ssr) {
  const query = parseRequestQuery(rawQuery);
  if (query.url || query.raw || query.direct) {
    return;
  }
  const normalizedFilename = normalize(filename2, root);
  return {
    id: id2,
    filename: filename2,
    normalizedFilename,
    query,
    timestamp,
    ssr
  };
}

// node_modules/@sveltejs/vite-plugin-svelte/src/utils/options.js
var import_node_process5 = __toESM(require_node_process(), 1);

// node_modules/@sveltejs/vite-plugin-svelte/src/utils/load-svelte-config.js
var import_node_module2 = __toESM(require_node_module(), 1);
var import_node_path5 = __toESM(require_node_path(), 1);
var import_node_process4 = __toESM(require_node_process(), 1);
var import_node_fs3 = __toESM(require_node_fs(), 1);
var import_node_url2 = __toESM(require_node_url(), 1);
var esmRequire;
var knownSvelteConfigNames = [
  "svelte.config.js",
  "svelte.config.cjs",
  "svelte.config.mjs"
];
async function dynamicImportDefault(filePath, timestamp) {
  return await import(filePath + "?t=" + timestamp).then((m) => m.default);
}
async function loadSvelteConfig(viteConfig, inlineOptions) {
  if ((inlineOptions == null ? void 0 : inlineOptions.configFile) === false) {
    return;
  }
  const configFile = findConfigToLoad(viteConfig, inlineOptions);
  if (configFile) {
    let err;
    if (configFile.endsWith(".js") || configFile.endsWith(".mjs")) {
      try {
        const result = await dynamicImportDefault(
          (0, import_node_url2.pathToFileURL)(configFile).href,
          import_node_fs3.default.statSync(configFile).mtimeMs
        );
        if (result != null) {
          return {
            ...result,
            configFile
          };
        } else {
          throw new Error(`invalid export in ${configFile}`);
        }
      } catch (e2) {
        log.error(`failed to import config ${configFile}`, e2);
        err = e2;
      }
    }
    if (!configFile.endsWith(".mjs")) {
      try {
        const _require = import.meta.url ? esmRequire ?? (esmRequire = (0, import_node_module2.createRequire)(import.meta.url)) : (
          // eslint-disable-next-line no-undef
          __require
        );
        delete _require.cache[_require.resolve(configFile)];
        const result = _require(configFile);
        if (result != null) {
          return {
            ...result,
            configFile
          };
        } else {
          throw new Error(`invalid export in ${configFile}`);
        }
      } catch (e2) {
        log.error(`failed to require config ${configFile}`, e2);
        if (!err) {
          err = e2;
        }
      }
    }
    throw err;
  }
}
function findConfigToLoad(viteConfig, inlineOptions) {
  const root = (viteConfig == null ? void 0 : viteConfig.root) || import_node_process4.default.cwd();
  if (inlineOptions == null ? void 0 : inlineOptions.configFile) {
    const abolutePath = import_node_path5.default.isAbsolute(inlineOptions.configFile) ? inlineOptions.configFile : import_node_path5.default.resolve(root, inlineOptions.configFile);
    if (!import_node_fs3.default.existsSync(abolutePath)) {
      throw new Error(`failed to find svelte config file ${abolutePath}.`);
    }
    return abolutePath;
  } else {
    const existingKnownConfigFiles = knownSvelteConfigNames.map((candidate) => import_node_path5.default.resolve(root, candidate)).filter((file) => import_node_fs3.default.existsSync(file));
    if (existingKnownConfigFiles.length === 0) {
      log.debug(`no svelte config found at ${root}`, void 0, "config");
      return;
    } else if (existingKnownConfigFiles.length > 1) {
      log.warn(
        `found more than one svelte config file, using ${existingKnownConfigFiles[0]}. you should only have one!`,
        existingKnownConfigFiles
      );
    }
    return existingKnownConfigFiles[0];
  }
}

// node_modules/@sveltejs/vite-plugin-svelte/src/utils/options.js
var import_node_path8 = __toESM(require_node_path(), 1);

// node_modules/@sveltejs/vite-plugin-svelte/src/utils/esbuild.js
var import_node_fs4 = __toESM(require_node_fs(), 1);
var facadeEsbuildSveltePluginName = "vite-plugin-svelte:facade";
var facadeEsbuildSvelteModulePluginName = "vite-plugin-svelte-module:facade";
function esbuildSveltePlugin(options) {
  return {
    name: "vite-plugin-svelte:optimize-svelte",
    setup(build) {
      var _a2;
      if ((_a2 = build.initialOptions.plugins) == null ? void 0 : _a2.some((v) => v.name === "vite:dep-scan")) return;
      const filter = /\.svelte(?:\?.*)?$/;
      let statsCollection;
      build.onStart(() => {
        var _a3;
        statsCollection = (_a3 = options.stats) == null ? void 0 : _a3.startCollection("prebundle library components", {
          logResult: (c2) => c2.stats.length > 1
        });
      });
      build.onLoad({ filter }, async ({ path: filename2 }) => {
        const code = (0, import_node_fs4.readFileSync)(filename2, "utf8");
        try {
          const contents = await compileSvelte(options, { filename: filename2, code }, statsCollection);
          return { contents };
        } catch (e2) {
          return { errors: [toESBuildError(e2, options)] };
        }
      });
      build.onEnd(() => {
        statsCollection == null ? void 0 : statsCollection.finish();
      });
    }
  };
}
async function compileSvelte(options, { filename: filename2, code }, statsCollection) {
  var _a2;
  let css = options.compilerOptions.css;
  if (css !== "injected") {
    css = "injected";
  }
  const compileOptions = {
    dev: true,
    // default to dev: true because prebundling is only used in dev
    ...options.compilerOptions,
    css,
    filename: filename2,
    generate: "client"
  };
  if (compileOptions.hmr && options.emitCss) {
    const hash2 = `s-${safeBase64Hash(normalize(filename2, options.root))}`;
    compileOptions.cssHash = () => hash2;
  }
  let preprocessed;
  if (options.preprocess) {
    try {
      preprocessed = await preprocess(code, options.preprocess, { filename: filename2 });
    } catch (e2) {
      e2.message = `Error while preprocessing ${filename2}${e2.message ? ` - ${e2.message}` : ""}`;
      throw e2;
    }
    if (preprocessed.map) compileOptions.sourcemap = preprocessed.map;
  }
  const finalCode = preprocessed ? preprocessed.code : code;
  const dynamicCompileOptions = await ((_a2 = options == null ? void 0 : options.dynamicCompileOptions) == null ? void 0 : _a2.call(options, {
    filename: filename2,
    code: finalCode,
    compileOptions
  }));
  if (dynamicCompileOptions && log.debug.enabled) {
    log.debug(
      `dynamic compile options for  ${filename2}: ${JSON.stringify(dynamicCompileOptions)}`,
      void 0,
      "compile"
    );
  }
  const finalCompileOptions = dynamicCompileOptions ? {
    ...compileOptions,
    ...dynamicCompileOptions
  } : compileOptions;
  const endStat = statsCollection == null ? void 0 : statsCollection.start(filename2);
  const compiled = compile(finalCode, finalCompileOptions);
  if (endStat) {
    endStat();
  }
  return compiled.js.map ? compiled.js.code + "//# sourceMappingURL=" + compiled.js.map.toUrl() : compiled.js.code;
}
function esbuildSvelteModulePlugin(options) {
  return {
    name: "vite-plugin-svelte-module:optimize-svelte",
    setup(build) {
      var _a2;
      if ((_a2 = build.initialOptions.plugins) == null ? void 0 : _a2.some((v) => v.name === "vite:dep-scan")) return;
      const filter = /\.svelte\.[jt]s(?:\?.*)?$/;
      let statsCollection;
      build.onStart(() => {
        var _a3;
        statsCollection = (_a3 = options.stats) == null ? void 0 : _a3.startCollection("prebundle library modules", {
          logResult: (c2) => c2.stats.length > 1
        });
      });
      build.onLoad({ filter }, async ({ path: filename2 }) => {
        const code = (0, import_node_fs4.readFileSync)(filename2, "utf8");
        try {
          const contents = await compileSvelteModule(options, { filename: filename2, code }, statsCollection);
          return { contents };
        } catch (e2) {
          return { errors: [toESBuildError(e2, options)] };
        }
      });
      build.onEnd(() => {
        statsCollection == null ? void 0 : statsCollection.finish();
      });
    }
  };
}
async function compileSvelteModule(options, { filename: filename2, code }, statsCollection) {
  var _a2;
  const endStat = statsCollection == null ? void 0 : statsCollection.start(filename2);
  const compiled = compileModule(code, {
    dev: ((_a2 = options.compilerOptions) == null ? void 0 : _a2.dev) ?? true,
    // default to dev: true because prebundling is only used in dev
    filename: filename2,
    generate: "client"
  });
  if (endStat) {
    endStat();
  }
  return compiled.js.map ? compiled.js.code + "//# sourceMappingURL=" + compiled.js.map.toUrl() : compiled.js.code;
}

// node_modules/@sveltejs/vite-plugin-svelte/src/utils/options.js
var import_deepmerge = __toESM(require_cjs(), 1);

// node_modules/vitefu/src/index.js
var import_promises = __toESM(require_promises());
var import_node_fs5 = __toESM(require_node_fs());
var import_node_module3 = __toESM(require_node_module());
var import_node_path6 = __toESM(require_node_path());
var import_sync = __toESM(require_sync());
var pnp;
if (process.versions.pnp) {
  try {
    pnp = (0, import_node_module3.createRequire)(import.meta.url)("pnpapi");
  } catch {
  }
}
async function crawlFrameworkPkgs(options) {
  var _a2, _b, _c, _d, _e, _f, _g, _h;
  const pkgJsonPath = await findClosestPkgJsonPath(options.root);
  if (!pkgJsonPath) {
    return {
      optimizeDeps: { include: [], exclude: [] },
      ssr: { noExternal: [], external: [] }
    };
  }
  const pkgJson = await readJson(pkgJsonPath).catch((e2) => {
    throw new Error(`Unable to read ${pkgJsonPath}`, { cause: e2 });
  });
  let optimizeDepsInclude = [];
  let optimizeDepsExclude = [];
  let ssrNoExternal = [];
  let ssrExternal = [];
  await crawl(pkgJsonPath, pkgJson);
  if (options.viteUserConfig) {
    const _optimizeDepsExclude = (_b = (_a2 = options.viteUserConfig) == null ? void 0 : _a2.optimizeDeps) == null ? void 0 : _b.exclude;
    if (_optimizeDepsExclude) {
      optimizeDepsInclude = optimizeDepsInclude.filter(
        (dep) => !(0, import_sync.isDepExcluded)(dep, _optimizeDepsExclude)
      );
    }
    const _optimizeDepsInclude = (_d = (_c = options.viteUserConfig) == null ? void 0 : _c.optimizeDeps) == null ? void 0 : _d.include;
    if (_optimizeDepsInclude) {
      optimizeDepsExclude = optimizeDepsExclude.filter(
        (dep) => !(0, import_sync.isDepIncluded)(dep, _optimizeDepsInclude)
      );
    }
    const _ssrExternal = (_f = (_e = options.viteUserConfig) == null ? void 0 : _e.ssr) == null ? void 0 : _f.external;
    if (_ssrExternal) {
      ssrNoExternal = ssrNoExternal.filter(
        (dep) => !(0, import_sync.isDepExternaled)(dep, _ssrExternal)
      );
    }
    const _ssrNoExternal = (_h = (_g = options.viteUserConfig) == null ? void 0 : _g.ssr) == null ? void 0 : _h.noExternal;
    if (_ssrNoExternal) {
      ssrExternal = ssrExternal.filter(
        (dep) => !(0, import_sync.isDepNoExternaled)(dep, _ssrNoExternal)
      );
    }
  }
  return {
    optimizeDeps: {
      include: optimizeDepsInclude,
      exclude: optimizeDepsExclude
    },
    ssr: {
      noExternal: ssrNoExternal,
      external: ssrExternal
    }
  };
  async function crawl(pkgJsonPath2, pkgJson2, parentDepNames = []) {
    const isRoot = parentDepNames.length === 0;
    let deps = [
      ...Object.keys(pkgJson2.dependencies || {}),
      ...isRoot ? Object.keys(pkgJson2.devDependencies || {}) : []
    ];
    deps = deps.filter((dep) => {
      var _a3, _b2;
      if (parentDepNames.includes(dep)) {
        return false;
      }
      const isFrameworkPkg = (_a3 = options.isFrameworkPkgByName) == null ? void 0 : _a3.call(options, dep);
      const isSemiFrameworkPkg = (_b2 = options.isSemiFrameworkPkgByName) == null ? void 0 : _b2.call(options, dep);
      if (isFrameworkPkg) {
        optimizeDepsExclude.push(dep);
        ssrNoExternal.push(dep);
      } else if (isSemiFrameworkPkg) {
        ssrNoExternal.push(dep);
      }
      if (isFrameworkPkg === false || isSemiFrameworkPkg === false) {
        return false;
      } else {
        return true;
      }
    });
    const promises = deps.map(async (dep) => {
      var _a3, _b2;
      const depPkgJsonPath = await findDepPkgJsonPath(dep, pkgJsonPath2);
      if (!depPkgJsonPath) return;
      const depPkgJson = await readJson(depPkgJsonPath).catch(() => {
      });
      if (!depPkgJson) return;
      const cachedIsFrameworkPkg = ssrNoExternal.includes(dep);
      if (cachedIsFrameworkPkg) {
        return crawl(depPkgJsonPath, depPkgJson, parentDepNames.concat(dep));
      }
      const isFrameworkPkg = (_a3 = options.isFrameworkPkgByJson) == null ? void 0 : _a3.call(options, depPkgJson);
      const isSemiFrameworkPkg = (_b2 = options.isSemiFrameworkPkgByJson) == null ? void 0 : _b2.call(options, depPkgJson);
      if (isFrameworkPkg || isSemiFrameworkPkg) {
        if (isFrameworkPkg) {
          optimizeDepsExclude.push(dep);
          ssrNoExternal.push(dep);
        } else if (isSemiFrameworkPkg) {
          ssrNoExternal.push(dep);
        }
        return crawl(depPkgJsonPath, depPkgJson, parentDepNames.concat(dep));
      }
      if (!isRoot) {
        if (await pkgNeedsOptimization(depPkgJson, depPkgJsonPath)) {
          optimizeDepsInclude.push(parentDepNames.concat(dep).join(" > "));
        }
        if (!options.isBuild && !ssrExternal.includes(dep)) {
          ssrExternal.push(dep);
        }
      }
    });
    await Promise.all(promises);
  }
}
async function findDepPkgJsonPath(dep, parent) {
  if (pnp) {
    try {
      const depRoot = pnp.resolveToUnqualified(dep, parent);
      if (!depRoot) return void 0;
      return import_node_path6.default.join(depRoot, "package.json");
    } catch {
      return void 0;
    }
  }
  let root = parent;
  while (root) {
    const pkg = import_node_path6.default.join(root, "node_modules", dep, "package.json");
    try {
      await import_promises.default.access(pkg);
      return import_node_fs5.default.realpathSync(pkg);
    } catch {
    }
    const nextRoot = import_node_path6.default.dirname(root);
    if (nextRoot === root) break;
    root = nextRoot;
  }
  return void 0;
}
async function findClosestPkgJsonPath(dir, predicate = void 0) {
  if (dir.endsWith("package.json")) {
    dir = import_node_path6.default.dirname(dir);
  }
  while (dir) {
    const pkg = import_node_path6.default.join(dir, "package.json");
    try {
      const stat = await import_promises.default.stat(pkg);
      if (stat.isFile() && (!predicate || await predicate(pkg))) {
        return pkg;
      }
    } catch {
    }
    const nextDir = import_node_path6.default.dirname(dir);
    if (nextDir === dir) break;
    dir = nextDir;
  }
  return void 0;
}
async function pkgNeedsOptimization(pkgJson, pkgJsonPath) {
  if (pkgJson.module || pkgJson.exports) return false;
  if (pkgJson.main) {
    const entryExt = import_node_path6.default.extname(pkgJson.main);
    return !entryExt || entryExt === ".js" || entryExt === ".cjs";
  }
  try {
    await import_promises.default.access(import_node_path6.default.join(import_node_path6.default.dirname(pkgJsonPath), "index.js"));
    return true;
  } catch {
    return false;
  }
}
async function readJson(findDepPkgJsonPath2) {
  return JSON.parse(await import_promises.default.readFile(findDepPkgJsonPath2, "utf8"));
}

// node_modules/@sveltejs/vite-plugin-svelte/src/utils/dependencies.js
var import_node_path7 = __toESM(require_node_path(), 1);
var import_promises2 = __toESM(require_promises(), 1);
var COMMON_DEPENDENCIES_WITHOUT_SVELTE_FIELD = [
  "@lukeed/uuid",
  "@playwright/test",
  "@sveltejs/kit",
  "@sveltejs/package",
  "@sveltejs/vite-plugin-svelte",
  "autoprefixer",
  "cookie",
  "dotenv",
  "esbuild",
  "eslint",
  "jest",
  "mdsvex",
  "playwright",
  "postcss",
  "prettier",
  "svelte",
  "svelte2tsx",
  "svelte-check",
  "svelte-preprocess",
  "tslib",
  "typescript",
  "vite",
  "vitest",
  "__vite-browser-external"
  // see https://github.com/sveltejs/vite-plugin-svelte/issues/362
];
var COMMON_PREFIXES_WITHOUT_SVELTE_FIELD = [
  "@fontsource/",
  "@postcss-plugins/",
  "@rollup/",
  "@sveltejs/adapter-",
  "@types/",
  "@typescript-eslint/",
  "eslint-",
  "jest-",
  "postcss-plugin-",
  "prettier-plugin-",
  "rollup-plugin-",
  "vite-plugin-"
];
function isCommonDepWithoutSvelteField(dependency) {
  return COMMON_DEPENDENCIES_WITHOUT_SVELTE_FIELD.includes(dependency) || COMMON_PREFIXES_WITHOUT_SVELTE_FIELD.some(
    (prefix2) => prefix2.startsWith("@") ? dependency.startsWith(prefix2) : dependency.substring(dependency.lastIndexOf("/") + 1).startsWith(prefix2)
    // check prefix omitting @scope/
  );
}

// node_modules/@sveltejs/vite-plugin-svelte/src/utils/vite-plugin-svelte-stats.js
var import_node_perf_hooks = __toESM(require_node_perf_hooks(), 1);
var defaultCollectionOptions = {
  // log after 500ms and more than one file processed
  logInProgress: (c2, now) => now - c2.collectionStart > 500 && c2.stats.length > 1,
  // always log results
  logResult: () => true
};
function humanDuration(n2) {
  return n2 < 100 ? `${n2.toFixed(1)}ms` : `${(n2 / 1e3).toFixed(2)}s`;
}
function formatPackageStats(pkgStats) {
  const statLines = pkgStats.map((pkgStat) => {
    const duration = pkgStat.duration;
    const avg = duration / pkgStat.files;
    return [pkgStat.pkg, `${pkgStat.files}`, humanDuration(duration), humanDuration(avg)];
  });
  statLines.unshift(["package", "files", "time", "avg"]);
  const columnWidths = statLines.reduce(
    (widths, row) => {
      for (let i = 0; i < row.length; i++) {
        const cell = row[i];
        if (widths[i] < cell.length) {
          widths[i] = cell.length;
        }
      }
      return widths;
    },
    statLines[0].map(() => 0)
  );
  const table = statLines.map(
    (row) => row.map((cell, i) => {
      if (i === 0) {
        return cell.padEnd(columnWidths[i], " ");
      } else {
        return cell.padStart(columnWidths[i], " ");
      }
    }).join("	")
  ).join("\n");
  return table;
}
var _cache, _collections, _VitePluginSvelteStats_instances, finish_fn, aggregateStatsResult_fn;
var VitePluginSvelteStats = class {
  /**
   * @param {import('./vite-plugin-svelte-cache.js').VitePluginSvelteCache} cache
   */
  constructor(cache) {
    __privateAdd(this, _VitePluginSvelteStats_instances);
    // package directory -> package name
    /** @type {import('./vite-plugin-svelte-cache.js').VitePluginSvelteCache} */
    __privateAdd(this, _cache);
    /** @type {import('../types/vite-plugin-svelte-stats.d.ts').StatCollection[]} */
    __privateAdd(this, _collections, []);
    __privateSet(this, _cache, cache);
  }
  /**
   * @param {string} name
   * @param {Partial<import('../types/vite-plugin-svelte-stats.d.ts').CollectionOptions>} [opts]
   * @returns {import('../types/vite-plugin-svelte-stats.d.ts').StatCollection}
   */
  startCollection(name, opts) {
    const options = {
      ...defaultCollectionOptions,
      ...opts
    };
    const stats = [];
    const collectionStart = import_node_perf_hooks.performance.now();
    const _this = this;
    let hasLoggedProgress = false;
    const collection = {
      name,
      options,
      stats,
      collectionStart,
      finished: false,
      start(file) {
        if (collection.finished) {
          throw new Error("called after finish() has been used");
        }
        file = normalizePath$3(file);
        const start = import_node_perf_hooks.performance.now();
        const stat = { file, start, end: start };
        return () => {
          const now = import_node_perf_hooks.performance.now();
          stat.end = now;
          stats.push(stat);
          if (!hasLoggedProgress && options.logInProgress(collection, now)) {
            hasLoggedProgress = true;
            log.debug(`${name} in progress ...`, void 0, "stats");
          }
        };
      },
      async finish() {
        var _a2;
        await __privateMethod(_a2 = _this, _VitePluginSvelteStats_instances, finish_fn).call(_a2, collection);
      }
    };
    __privateGet(_this, _collections).push(collection);
    return collection;
  }
  async finishAll() {
    await Promise.all(__privateGet(this, _collections).map((c2) => c2.finish()));
  }
};
_cache = new WeakMap();
_collections = new WeakMap();
_VitePluginSvelteStats_instances = new WeakSet();
finish_fn = async function(collection) {
  try {
    collection.finished = true;
    const now = import_node_perf_hooks.performance.now();
    collection.duration = now - collection.collectionStart;
    const logResult = collection.options.logResult(collection);
    if (logResult) {
      await __privateMethod(this, _VitePluginSvelteStats_instances, aggregateStatsResult_fn).call(this, collection);
      log.debug(
        `${collection.name} done.
${formatPackageStats(
          /** @type {import('../types/vite-plugin-svelte-stats.d.ts').PackageStats[]}*/
          collection.packageStats
        )}`,
        void 0,
        "stats"
      );
    }
    const index = __privateGet(this, _collections).indexOf(collection);
    __privateGet(this, _collections).splice(index, 1);
    collection.stats.length = 0;
    collection.stats = [];
    if (collection.packageStats) {
      collection.packageStats.length = 0;
      collection.packageStats = [];
    }
    collection.start = () => () => {
    };
    collection.finish = () => {
    };
  } catch (e2) {
    log.debug.once(`failed to finish stats for ${collection.name}
`, e2, "stats");
  }
};
aggregateStatsResult_fn = async function(collection) {
  const stats = collection.stats;
  for (const stat of stats) {
    stat.pkg = (await __privateGet(this, _cache).getPackageInfo(stat.file)).name;
  }
  const grouped = {};
  stats.forEach((stat) => {
    const pkg = (
      /** @type {string} */
      stat.pkg
    );
    let group = grouped[pkg];
    if (!group) {
      group = grouped[pkg] = {
        files: 0,
        duration: 0,
        pkg
      };
    }
    group.files += 1;
    group.duration += stat.end - stat.start;
  });
  const groups = Object.values(grouped);
  groups.sort((a, b) => b.duration - a.duration);
  collection.packageStats = groups;
};

// node_modules/@sveltejs/vite-plugin-svelte/src/utils/options.js
var allowedPluginOptions = /* @__PURE__ */ new Set([
  "include",
  "exclude",
  "emitCss",
  "hot",
  "ignorePluginPreprocessors",
  "disableDependencyReinclusion",
  "prebundleSvelteLibraries",
  "inspector",
  "dynamicCompileOptions",
  "experimental"
]);
var knownRootOptions = /* @__PURE__ */ new Set(["extensions", "compilerOptions", "preprocess", "onwarn"]);
var allowedInlineOptions = /* @__PURE__ */ new Set(["configFile", ...allowedPluginOptions, ...knownRootOptions]);
function validateInlineOptions(inlineOptions) {
  const invalidKeys = Object.keys(inlineOptions || {}).filter(
    (key2) => !allowedInlineOptions.has(key2)
  );
  if (invalidKeys.length) {
    log.warn(`invalid plugin options "${invalidKeys.join(", ")}" in inline config`, inlineOptions);
  }
}
function convertPluginOptions(config) {
  if (!config) {
    return;
  }
  const invalidRootOptions = Object.keys(config).filter((key2) => allowedPluginOptions.has(key2));
  if (invalidRootOptions.length > 0) {
    throw new Error(
      `Invalid options in svelte config. Move the following options into 'vitePlugin:{...}': ${invalidRootOptions.join(
        ", "
      )}`
    );
  }
  if (!config.vitePlugin) {
    return config;
  }
  const pluginOptions = config.vitePlugin;
  const pluginOptionKeys = Object.keys(pluginOptions);
  const rootOptionsInPluginOptions = pluginOptionKeys.filter((key2) => knownRootOptions.has(key2));
  if (rootOptionsInPluginOptions.length > 0) {
    throw new Error(
      `Invalid options in svelte config under vitePlugin:{...}', move them to the config root : ${rootOptionsInPluginOptions.join(
        ", "
      )}`
    );
  }
  const duplicateOptions = pluginOptionKeys.filter(
    (key2) => Object.prototype.hasOwnProperty.call(config, key2)
  );
  if (duplicateOptions.length > 0) {
    throw new Error(
      `Invalid duplicate options in svelte config under vitePlugin:{...}', they are defined in root too and must only exist once: ${duplicateOptions.join(
        ", "
      )}`
    );
  }
  const unknownPluginOptions = pluginOptionKeys.filter((key2) => !allowedPluginOptions.has(key2));
  if (unknownPluginOptions.length > 0) {
    log.warn(
      `ignoring unknown plugin options in svelte config under vitePlugin:{...}: ${unknownPluginOptions.join(
        ", "
      )}`
    );
    unknownPluginOptions.forEach((unkownOption) => {
      delete pluginOptions[unkownOption];
    });
  }
  const result = {
    ...config,
    ...pluginOptions
  };
  delete result.vitePlugin;
  return result;
}
async function preResolveOptions(inlineOptions, viteUserConfig, viteEnv) {
  if (!inlineOptions) {
    inlineOptions = {};
  }
  const viteConfigWithResolvedRoot = {
    ...viteUserConfig,
    root: resolveViteRoot(viteUserConfig)
  };
  const isBuild = viteEnv.command === "build";
  const defaultOptions2 = {
    extensions: DEFAULT_SVELTE_EXT,
    emitCss: true,
    prebundleSvelteLibraries: !isBuild
  };
  const svelteConfig = convertPluginOptions(
    await loadSvelteConfig(viteConfigWithResolvedRoot, inlineOptions)
  );
  const extraOptions = {
    root: viteConfigWithResolvedRoot.root,
    isBuild,
    isServe: viteEnv.command === "serve",
    isDebug: import_node_process5.default.env.DEBUG != null
  };
  const merged = (
    /** @type {import('../types/options.d.ts').PreResolvedOptions} */
    mergeConfigs(defaultOptions2, svelteConfig, inlineOptions, extraOptions)
  );
  if (svelteConfig == null ? void 0 : svelteConfig.configFile) {
    merged.configFile = svelteConfig.configFile;
  }
  return merged;
}
function mergeConfigs(...configs) {
  let result = {};
  for (const config of configs.filter((x) => x != null)) {
    result = (0, import_deepmerge.default)(
      result,
      /** @type {Partial<T>} */
      config,
      {
        // replace arrays
        arrayMerge: (target, source2) => source2 ?? target
      }
    );
  }
  return (
    /** @type {T} */
    result
  );
}
function resolveOptions(preResolveOptions2, viteConfig, cache) {
  const css = preResolveOptions2.emitCss ? "external" : "injected";
  const defaultOptions2 = {
    compilerOptions: {
      css,
      dev: !viteConfig.isProduction,
      hmr: !viteConfig.isProduction && !preResolveOptions2.isBuild && viteConfig.server && viteConfig.server.hmr !== false
    }
  };
  const extraOptions = {
    root: viteConfig.root,
    isProduction: viteConfig.isProduction
  };
  const merged = (
    /** @type {import('../types/options.d.ts').ResolvedOptions}*/
    mergeConfigs(defaultOptions2, preResolveOptions2, extraOptions)
  );
  removeIgnoredOptions(merged);
  handleDeprecatedOptions(merged);
  addExtraPreprocessors(merged, viteConfig);
  enforceOptionsForHmr(merged, viteConfig);
  enforceOptionsForProduction(merged);
  if (log.debug.enabled && isDebugNamespaceEnabled("stats")) {
    merged.stats = new VitePluginSvelteStats(cache);
  }
  return merged;
}
function enforceOptionsForHmr(options, viteConfig) {
  var _a2;
  if (options.hot) {
    log.warn(
      "svelte 5 has hmr integrated in core. Please remove the vitePlugin.hot option and use compilerOptions.hmr instead"
    );
    delete options.hot;
    options.compilerOptions.hmr = true;
  }
  if (options.compilerOptions.hmr && ((_a2 = viteConfig.server) == null ? void 0 : _a2.hmr) === false) {
    log.warn(
      "vite config server.hmr is false but compilerOptions.hmr is true. Forcing compilerOptions.hmr to false as it would not work."
    );
    options.compilerOptions.hmr = false;
  }
}
function enforceOptionsForProduction(options) {
  if (options.isProduction) {
    if (options.compilerOptions.hmr) {
      log.warn(
        "you are building for production but compilerOptions.hmr is true, forcing it to false"
      );
      options.compilerOptions.hmr = false;
    }
    if (options.compilerOptions.dev) {
      log.warn(
        "you are building for production but compilerOptions.dev is true, forcing it to false"
      );
      options.compilerOptions.dev = false;
    }
  }
}
function removeIgnoredOptions(options) {
  const ignoredCompilerOptions = ["generate", "format", "filename"];
  if (options.compilerOptions.hmr && options.emitCss) {
    ignoredCompilerOptions.push("cssHash");
  }
  const passedCompilerOptions = Object.keys(options.compilerOptions || {});
  const passedIgnored = passedCompilerOptions.filter((o) => ignoredCompilerOptions.includes(o));
  if (passedIgnored.length) {
    log.warn(
      `The following Svelte compilerOptions are controlled by vite-plugin-svelte and essential to its functionality. User-specified values are ignored. Please remove them from your configuration: ${passedIgnored.join(
        ", "
      )}`
    );
    passedIgnored.forEach((ignored) => {
      delete options.compilerOptions[ignored];
    });
  }
}
function handleDeprecatedOptions(options) {
  const experimental = (
    /** @type {Record<string, any>} */
    options.experimental
  );
  if (experimental) {
    for (const promoted of ["prebundleSvelteLibraries", "inspector", "dynamicCompileOptions"]) {
      if (experimental[promoted]) {
        options[promoted] = experimental[promoted];
        delete experimental[promoted];
        log.warn(
          `Option "experimental.${promoted}" is no longer experimental and has moved to "${promoted}". Please update your Svelte or Vite config.`
        );
      }
    }
    if (experimental.generateMissingPreprocessorSourcemaps) {
      log.warn("experimental.generateMissingPreprocessorSourcemaps has been removed.");
    }
  }
}
function resolveViteRoot(viteConfig) {
  return normalizePath$3(viteConfig.root ? import_node_path8.default.resolve(viteConfig.root) : import_node_process5.default.cwd());
}
async function buildExtraViteConfig(options, config) {
  var _a2;
  if (!config.resolve) {
    config.resolve = {};
  }
  config.resolve.mainFields = [
    ...SVELTE_RESOLVE_MAIN_FIELDS,
    ...config.resolve.mainFields ?? VITE_RESOLVE_MAIN_FIELDS
  ];
  const extraViteConfig = {
    resolve: {
      dedupe: [...SVELTE_IMPORTS],
      conditions: [...SVELTE_EXPORT_CONDITIONS]
    }
    // this option is still awaiting a PR in vite to be supported
    // see https://github.com/sveltejs/vite-plugin-svelte/issues/60
    // knownJsSrcExtensions: options.extensions
  };
  const extraSvelteConfig = buildExtraConfigForSvelte(config);
  const extraDepsConfig = await buildExtraConfigForDependencies(options, config);
  extraViteConfig.optimizeDeps = {
    include: [
      ...extraSvelteConfig.optimizeDeps.include,
      ...extraDepsConfig.optimizeDeps.include.filter(
        (dep) => !(0, import_sync.isDepExcluded)(dep, extraSvelteConfig.optimizeDeps.exclude)
      )
    ],
    exclude: [
      ...extraSvelteConfig.optimizeDeps.exclude,
      ...extraDepsConfig.optimizeDeps.exclude.filter(
        (dep) => !(0, import_sync.isDepIncluded)(dep, extraSvelteConfig.optimizeDeps.include)
      )
    ]
  };
  extraViteConfig.ssr = {
    external: [
      ...extraSvelteConfig.ssr.external,
      ...extraDepsConfig.ssr.external.filter(
        (dep) => !(0, import_sync.isDepNoExternaled)(dep, extraSvelteConfig.ssr.noExternal)
      )
    ],
    noExternal: [
      ...extraSvelteConfig.ssr.noExternal,
      ...extraDepsConfig.ssr.noExternal.filter(
        (dep) => !(0, import_sync.isDepExternaled)(dep, extraSvelteConfig.ssr.external)
      )
    ]
  };
  if (options.prebundleSvelteLibraries) {
    extraViteConfig.optimizeDeps = {
      ...extraViteConfig.optimizeDeps,
      // Experimental Vite API to allow these extensions to be scanned and prebundled
      extensions: options.extensions ?? [".svelte"],
      // Add esbuild plugin to prebundle Svelte files.
      // Currently a placeholder as more information is needed after Vite config is resolved,
      // the real Svelte plugin is added in `patchResolvedViteConfig()`
      esbuildOptions: {
        plugins: [
          { name: facadeEsbuildSveltePluginName, setup: () => {
          } },
          { name: facadeEsbuildSvelteModulePluginName, setup: () => {
          } }
        ]
      }
    };
  }
  if (((_a2 = config.experimental) == null ? void 0 : _a2.hmrPartialAccept) !== false) {
    log.debug('enabling "experimental.hmrPartialAccept" in vite config', void 0, "config");
    extraViteConfig.experimental = { hmrPartialAccept: true };
  }
  validateViteConfig(extraViteConfig, config, options);
  return extraViteConfig;
}
function validateViteConfig(extraViteConfig, config, options) {
  var _a2;
  const { prebundleSvelteLibraries, isBuild } = options;
  if (prebundleSvelteLibraries) {
    const isEnabled = (option) => option !== true && option !== (isBuild ? "build" : "dev");
    const logWarning = (name, value, recommendation) => log.warn.once(
      `Incompatible options: \`prebundleSvelteLibraries: true\` and vite \`${name}: ${JSON.stringify(
        value
      )}\` ${isBuild ? "during build." : "."} ${recommendation}`
    );
    const viteOptimizeDepsDisabled = ((_a2 = config.optimizeDeps) == null ? void 0 : _a2.disabled) ?? "build";
    const isOptimizeDepsEnabled = isEnabled(viteOptimizeDepsDisabled);
    if (!isBuild && !isOptimizeDepsEnabled) {
      logWarning(
        "optimizeDeps.disabled",
        viteOptimizeDepsDisabled,
        'Forcing `optimizeDeps.disabled: "build"`. Disable prebundleSvelteLibraries or update your vite config to enable optimizeDeps during dev.'
      );
      if (!extraViteConfig.optimizeDeps) {
        extraViteConfig.optimizeDeps = {};
      }
      extraViteConfig.optimizeDeps.disabled = "build";
    } else if (isBuild && isOptimizeDepsEnabled) {
      logWarning(
        "optimizeDeps.disabled",
        viteOptimizeDepsDisabled,
        "Disable optimizeDeps or prebundleSvelteLibraries for build if you experience errors."
      );
    }
  }
}
async function buildExtraConfigForDependencies(options, config) {
  var _a2, _b;
  const packagesWithoutSvelteExportsCondition = /* @__PURE__ */ new Set();
  const depsConfig = await crawlFrameworkPkgs({
    root: options.root,
    isBuild: options.isBuild,
    viteUserConfig: config,
    isFrameworkPkgByJson(pkgJson) {
      let hasSvelteCondition = false;
      if (typeof pkgJson.exports === "object") {
        JSON.stringify(pkgJson.exports, (key2, value) => {
          if (SVELTE_EXPORT_CONDITIONS.includes(key2)) {
            hasSvelteCondition = true;
          }
          return value;
        });
      }
      const hasSvelteField = !!pkgJson.svelte;
      if (hasSvelteField && !hasSvelteCondition) {
        packagesWithoutSvelteExportsCondition.add(`${pkgJson.name}@${pkgJson.version}`);
      }
      return hasSvelteCondition || hasSvelteField;
    },
    isSemiFrameworkPkgByJson(pkgJson) {
      var _a3, _b2;
      return !!((_a3 = pkgJson.dependencies) == null ? void 0 : _a3.svelte) || !!((_b2 = pkgJson.peerDependencies) == null ? void 0 : _b2.svelte);
    },
    isFrameworkPkgByName(pkgName) {
      const isNotSveltePackage = isCommonDepWithoutSvelteField(pkgName);
      if (isNotSveltePackage) {
        return false;
      } else {
        return void 0;
      }
    }
  });
  if (!((_a2 = options.experimental) == null ? void 0 : _a2.disableSvelteResolveWarnings) && (packagesWithoutSvelteExportsCondition == null ? void 0 : packagesWithoutSvelteExportsCondition.size) > 0) {
    log.warn(
      `WARNING: The following packages have a svelte field in their package.json but no exports condition for svelte.

${[
        ...packagesWithoutSvelteExportsCondition
      ].join("\n")}

Please see ${FAQ_LINK_MISSING_EXPORTS_CONDITION} for details.`
    );
  }
  log.debug("extra config for dependencies generated by vitefu", depsConfig, "config");
  if (options.prebundleSvelteLibraries) {
    depsConfig.optimizeDeps.exclude = [];
    const userExclude = (_b = config.optimizeDeps) == null ? void 0 : _b.exclude;
    depsConfig.optimizeDeps.include = !userExclude ? [] : depsConfig.optimizeDeps.include.filter((dep) => {
      return dep.includes(">") && dep.split(">").slice(0, -1).some((d) => (0, import_sync.isDepExcluded)(d.trim(), userExclude));
    });
  }
  if (options.disableDependencyReinclusion === true) {
    depsConfig.optimizeDeps.include = depsConfig.optimizeDeps.include.filter(
      (dep) => !dep.includes(">")
    );
  } else if (Array.isArray(options.disableDependencyReinclusion)) {
    const disabledDeps = options.disableDependencyReinclusion;
    depsConfig.optimizeDeps.include = depsConfig.optimizeDeps.include.filter((dep) => {
      if (!dep.includes(">")) return true;
      const trimDep = dep.replace(/\s+/g, "");
      return disabledDeps.some((disabled) => trimDep.includes(`${disabled}>`));
    });
  }
  log.debug("post-processed extra config for dependencies", depsConfig, "config");
  return depsConfig;
}
function buildExtraConfigForSvelte(config) {
  var _a2, _b;
  const include = [];
  const exclude = [];
  if (!(0, import_sync.isDepExcluded)("svelte", ((_a2 = config.optimizeDeps) == null ? void 0 : _a2.exclude) ?? [])) {
    const svelteImportsToInclude = SVELTE_IMPORTS.filter(
      (si) => !(si.endsWith("/server") || si.includes("/server/"))
    );
    log.debug(
      `adding bare svelte packages to optimizeDeps.include: ${svelteImportsToInclude.join(", ")} `,
      void 0,
      "config"
    );
    include.push(...svelteImportsToInclude);
  } else {
    log.debug(
      '"svelte" is excluded in optimizeDeps.exclude, skipped adding it to include.',
      void 0,
      "config"
    );
  }
  const noExternal = [];
  const external = [];
  if (!(0, import_sync.isDepExternaled)("svelte", ((_b = config.ssr) == null ? void 0 : _b.external) ?? [])) {
    noExternal.push("svelte", /^svelte\//);
  }
  return { optimizeDeps: { include, exclude }, ssr: { noExternal, external } };
}
function patchResolvedViteConfig(viteConfig, options) {
  var _a2, _b, _c, _d;
  if (options.preprocess) {
    for (const preprocessor of arraify2(options.preprocess)) {
      if (preprocessor.style && "__resolvedConfig" in preprocessor.style) {
        preprocessor.style.__resolvedConfig = viteConfig;
      }
    }
  }
  const facadeEsbuildSveltePlugin = (_b = (_a2 = viteConfig.optimizeDeps.esbuildOptions) == null ? void 0 : _a2.plugins) == null ? void 0 : _b.find(
    (plugin) => plugin.name === facadeEsbuildSveltePluginName
  );
  if (facadeEsbuildSveltePlugin) {
    Object.assign(facadeEsbuildSveltePlugin, esbuildSveltePlugin(options));
  }
  const facadeEsbuildSvelteModulePlugin = (_d = (_c = viteConfig.optimizeDeps.esbuildOptions) == null ? void 0 : _c.plugins) == null ? void 0 : _d.find(
    (plugin) => plugin.name === facadeEsbuildSvelteModulePluginName
  );
  if (facadeEsbuildSvelteModulePlugin) {
    Object.assign(facadeEsbuildSvelteModulePlugin, esbuildSvelteModulePlugin(options));
  }
}
function arraify2(value) {
  return Array.isArray(value) ? value : [value];
}

// node_modules/@sveltejs/vite-plugin-svelte/src/utils/watch.js
var import_node_fs6 = __toESM(require_node_fs(), 1);
var import_node_path9 = __toESM(require_node_path(), 1);
function setupWatchers(options, cache, requestParser) {
  const { server, configFile: svelteConfigFile } = options;
  if (!server) {
    return;
  }
  const { watcher, ws } = server;
  const { root, server: serverConfig } = server.config;
  const emitChangeEventOnDependants = (filename2) => {
    const dependants = cache.getDependants(filename2);
    dependants.forEach((dependant) => {
      if (import_node_fs6.default.existsSync(dependant)) {
        log.debug(
          `emitting virtual change event for "${dependant}" because dependency "${filename2}" changed`,
          void 0,
          "hmr"
        );
        watcher.emit("change", dependant);
      }
    });
  };
  const removeUnlinkedFromCache = (filename2) => {
    const svelteRequest = requestParser(filename2, false);
    if (svelteRequest) {
      const removedFromCache = cache.remove(svelteRequest);
      if (removedFromCache) {
        log.debug(`cleared VitePluginSvelteCache for deleted file ${filename2}`, void 0, "hmr");
      }
    }
  };
  const triggerViteRestart = (filename2) => {
    if (serverConfig.middlewareMode) {
      const message = "Svelte config change detected, restart your dev process to apply the changes.";
      log.info(message, filename2);
      ws.send({
        type: "error",
        err: { message, stack: "", plugin: "vite-plugin-svelte", id: filename2 }
      });
    } else {
      log.info(`svelte config changed: restarting vite server. - file: ${filename2}`);
      server.restart();
    }
  };
  const listenerCollection = {
    add: [],
    change: [emitChangeEventOnDependants],
    unlink: [removeUnlinkedFromCache, emitChangeEventOnDependants]
  };
  if (svelteConfigFile !== false) {
    const possibleSvelteConfigs = knownSvelteConfigNames.map((cfg) => import_node_path9.default.join(root, cfg));
    const restartOnConfigAdd = (filename2) => {
      if (possibleSvelteConfigs.includes(filename2)) {
        triggerViteRestart(filename2);
      }
    };
    const restartOnConfigChange = (filename2) => {
      if (filename2 === svelteConfigFile) {
        triggerViteRestart(filename2);
      }
    };
    if (svelteConfigFile) {
      listenerCollection.change.push(restartOnConfigChange);
      listenerCollection.unlink.push(restartOnConfigChange);
    } else {
      listenerCollection.add.push(restartOnConfigAdd);
    }
  }
  Object.entries(listenerCollection).forEach(([evt, listeners]) => {
    if (listeners.length > 0) {
      watcher.on(evt, (filename2) => listeners.forEach((listener) => listener(filename2)));
    }
  });
}
function ensureWatchedFile(watcher, file, root) {
  if (file && // only need to watch if out of root
  !file.startsWith(root + "/") && // some rollup plugins use null bytes for private resolved Ids
  !file.includes("\0") && import_node_fs6.default.existsSync(file)) {
    watcher.add(import_node_path9.default.resolve(file));
  }
}

// node_modules/@sveltejs/vite-plugin-svelte/src/utils/optimizer.js
var import_node_fs7 = __toESM(require_node_fs(), 1);
var import_node_path10 = __toESM(require_node_path(), 1);
var PREBUNDLE_SENSITIVE_OPTIONS = [
  "compilerOptions",
  "configFile",
  "experimental",
  "extensions",
  "ignorePluginPreprocessors",
  "preprocess"
];
async function saveSvelteMetadata(cacheDir, options) {
  const svelteMetadata = generateSvelteMetadata(options);
  const svelteMetadataPath = import_node_path10.default.resolve(cacheDir, "_svelte_metadata.json");
  const currentSvelteMetadata = JSON.stringify(svelteMetadata, (_, value) => {
    return typeof value === "function" ? value.toString() : value;
  });
  let existingSvelteMetadata;
  try {
    existingSvelteMetadata = await import_node_fs7.promises.readFile(svelteMetadataPath, "utf8");
  } catch {
  }
  await import_node_fs7.promises.mkdir(cacheDir, { recursive: true });
  await import_node_fs7.promises.writeFile(svelteMetadataPath, currentSvelteMetadata);
  return currentSvelteMetadata !== existingSvelteMetadata;
}
function generateSvelteMetadata(options) {
  const metadata = {};
  for (const key2 of PREBUNDLE_SENSITIVE_OPTIONS) {
    metadata[key2] = options[key2];
  }
  return metadata;
}

// node_modules/@sveltejs/vite-plugin-svelte/src/utils/vite-plugin-svelte-cache.js
var import_node_fs8 = __toESM(require_node_fs(), 1);
var import_node_path11 = __toESM(require_node_path(), 1);
var _css, _js, _dependencies, _dependants, _errors, _packageInfos, _VitePluginSvelteCache_instances, updateCSS_fn, updateJS_fn, updateDependencies_fn;
var VitePluginSvelteCache = class {
  constructor() {
    __privateAdd(this, _VitePluginSvelteCache_instances);
    /** @type {Map<string, import('../types/compile.d.ts').Code | null>} */
    __privateAdd(this, _css, /* @__PURE__ */ new Map());
    /** @type {Map<string, import('../types/compile.d.ts').Code | null>} */
    __privateAdd(this, _js, /* @__PURE__ */ new Map());
    /** @type {Map<string, string[]>} */
    __privateAdd(this, _dependencies, /* @__PURE__ */ new Map());
    /** @type {Map<string, Set<string>>} */
    __privateAdd(this, _dependants, /* @__PURE__ */ new Map());
    /** @type {Map<string, any>} */
    __privateAdd(this, _errors, /* @__PURE__ */ new Map());
    /** @type {PackageInfo[]} */
    __privateAdd(this, _packageInfos, []);
  }
  /**
   * @param {import('../types/compile.d.ts').CompileData} compileData
   */
  update(compileData) {
    __privateGet(this, _errors).delete(compileData.normalizedFilename);
    __privateMethod(this, _VitePluginSvelteCache_instances, updateCSS_fn).call(this, compileData);
    __privateMethod(this, _VitePluginSvelteCache_instances, updateJS_fn).call(this, compileData);
    __privateMethod(this, _VitePluginSvelteCache_instances, updateDependencies_fn).call(this, compileData);
  }
  /**
   * @param {import('../types/id.d.ts').SvelteRequest} svelteRequest
   * @returns {boolean}
   */
  has(svelteRequest) {
    const id2 = svelteRequest.normalizedFilename;
    return __privateGet(this, _errors).has(id2) || __privateGet(this, _js).has(id2) || __privateGet(this, _css).has(id2);
  }
  /**
   * @param {import('../types/id.d.ts').SvelteRequest} svelteRequest
   * @param {any} error
   */
  setError(svelteRequest, error) {
    this.remove(svelteRequest, true);
    __privateGet(this, _errors).set(svelteRequest.normalizedFilename, error);
  }
  /**
   * @param {import('../types/id.d.ts').SvelteRequest} svelteRequest
   * @param {boolean} [keepDependencies]
   * @returns {boolean}
   */
  remove(svelteRequest, keepDependencies = false) {
    const id2 = svelteRequest.normalizedFilename;
    let removed2 = false;
    if (__privateGet(this, _errors).delete(id2)) {
      removed2 = true;
    }
    if (__privateGet(this, _js).delete(id2)) {
      removed2 = true;
    }
    if (__privateGet(this, _css).delete(id2)) {
      removed2 = true;
    }
    if (!keepDependencies) {
      const dependencies = __privateGet(this, _dependencies).get(id2);
      if (dependencies) {
        removed2 = true;
        dependencies.forEach((d) => {
          const dependants = __privateGet(this, _dependants).get(d);
          if (dependants && dependants.has(svelteRequest.filename)) {
            dependants.delete(svelteRequest.filename);
          }
        });
        __privateGet(this, _dependencies).delete(id2);
      }
    }
    return removed2;
  }
  /**
   * @param {import('../types/id.d.ts').SvelteRequest} svelteRequest
   * @returns {import('../types/compile.d.ts').Code | undefined | null}
   */
  getCSS(svelteRequest) {
    return __privateGet(this, _css).get(svelteRequest.normalizedFilename);
  }
  /**
   * @param {import('../types/id.d.ts').SvelteRequest} svelteRequest
   * @returns {import('../types/compile.d.ts').Code | undefined | null}
   */
  getJS(svelteRequest) {
    if (!svelteRequest.ssr) {
      return __privateGet(this, _js).get(svelteRequest.normalizedFilename);
    }
  }
  /**
   * @param {import('../types/id.d.ts').SvelteRequest} svelteRequest
   * @returns {any}
   */
  getError(svelteRequest) {
    return __privateGet(this, _errors).get(svelteRequest.normalizedFilename);
  }
  /**
   * @param {string} path
   * @returns {string[]}
   */
  getDependants(path11) {
    const dependants = __privateGet(this, _dependants).get(path11);
    return dependants ? [...dependants] : [];
  }
  /**
   * @param {string} file
   * @returns {Promise<PackageInfo>}
   */
  async getPackageInfo(file) {
    let info = __privateGet(this, _packageInfos).find((pi) => file.startsWith(pi.path));
    if (!info) {
      info = await findPackageInfo(file);
      __privateGet(this, _packageInfos).push(info);
    }
    return info;
  }
};
_css = new WeakMap();
_js = new WeakMap();
_dependencies = new WeakMap();
_dependants = new WeakMap();
_errors = new WeakMap();
_packageInfos = new WeakMap();
_VitePluginSvelteCache_instances = new WeakSet();
/**
 * @param {import('../types/compile.d.ts').CompileData} compileData
 */
updateCSS_fn = function(compileData) {
  __privateGet(this, _css).set(compileData.normalizedFilename, compileData.compiled.css);
};
/**
 * @param {import('../types/compile.d.ts').CompileData} compileData
 */
updateJS_fn = function(compileData) {
  if (!compileData.ssr) {
    __privateGet(this, _js).set(compileData.normalizedFilename, compileData.compiled.js);
  }
};
/**
 * @param {import('../types/compile.d.ts').CompileData} compileData
 */
updateDependencies_fn = function(compileData) {
  const id2 = compileData.normalizedFilename;
  const prevDependencies = __privateGet(this, _dependencies).get(id2) || [];
  const dependencies = compileData.dependencies;
  __privateGet(this, _dependencies).set(id2, dependencies);
  const removed2 = prevDependencies.filter((d) => !dependencies.includes(d));
  const added = dependencies.filter((d) => !prevDependencies.includes(d));
  added.forEach((d) => {
    if (!__privateGet(this, _dependants).has(d)) {
      __privateGet(this, _dependants).set(d, /* @__PURE__ */ new Set());
    }
    __privateGet(this, _dependants).get(d).add(compileData.filename);
  });
  removed2.forEach((d) => {
    __privateGet(this, _dependants).get(d).delete(compileData.filename);
  });
};
async function findPackageInfo(file) {
  const info = {
    name: "$unknown",
    version: "0.0.0-unknown",
    path: "$unknown"
  };
  let path11 = await findClosestPkgJsonPath(file, (pkgPath) => {
    const pkg = JSON.parse((0, import_node_fs8.readFileSync)(pkgPath, "utf-8"));
    if (pkg.name != null) {
      info.name = pkg.name;
      if (pkg.version != null) {
        info.version = pkg.version;
      }
      info.svelte = pkg.svelte;
      return true;
    }
    return false;
  });
  path11 = normalizePath$3((0, import_node_path11.dirname)(path11 ?? file)) + "/";
  info.path = path11;
  return info;
}

// node_modules/@sveltejs/vite-plugin-svelte/src/utils/load-raw.js
var import_node_fs9 = __toESM(require_node_fs(), 1);
async function loadRaw(svelteRequest, compileSvelte2, options) {
  var _a2, _b;
  const { id: id2, filename: filename2, query } = svelteRequest;
  let compileData;
  const source2 = import_node_fs9.default.readFileSync(filename2, "utf-8");
  try {
    svelteRequest.ssr = ((_a2 = query.compilerOptions) == null ? void 0 : _a2.generate) === "server";
    compileData = await compileSvelte2(svelteRequest, source2, {
      ...options,
      // don't use dynamic vite-plugin-svelte defaults here to ensure stable result between ssr,dev and build
      compilerOptions: {
        dev: false,
        css: "external",
        hmr: false,
        ...svelteRequest.query.compilerOptions
      },
      emitCss: true
    });
  } catch (e2) {
    throw toRollupError(e2, options);
  }
  let result;
  if (query.type === "style") {
    result = compileData.compiled.css ?? { code: "", map: null };
  } else if (query.type === "script") {
    result = compileData.compiled.js;
  } else if (query.type === "preprocessed") {
    result = compileData.preprocessed;
  } else if (query.type === "all" && query.raw) {
    return allToRawExports(compileData, source2);
  } else {
    throw new Error(
      `invalid "type=${query.type}" in ${id2}. supported are script, style, preprocessed, all`
    );
  }
  if (query.direct) {
    const supportedDirectTypes = ["script", "style"];
    if (!supportedDirectTypes.includes(query.type)) {
      throw new Error(
        `invalid "type=${query.type}" combined with direct in ${id2}. supported are: ${supportedDirectTypes.join(", ")}`
      );
    }
    log.debug(`load returns direct result for ${id2}`, void 0, "load");
    let directOutput = result.code;
    if (query.sourcemap && ((_b = result.map) == null ? void 0 : _b.toUrl)) {
      const map = `sourceMappingURL=${result.map.toUrl()}`;
      if (query.type === "style") {
        directOutput += `

/*# ${map} */
`;
      } else if (query.type === "script") {
        directOutput += `

//# ${map}
`;
      }
    }
    return directOutput;
  } else if (query.raw) {
    log.debug(`load returns raw result for ${id2}`, void 0, "load");
    return toRawExports(result);
  } else {
    throw new Error(`invalid raw mode in ${id2}, supported are raw, direct`);
  }
}
function allToRawExports(compileData, source2) {
  const exports = {
    ...compileData,
    ...compileData.compiled,
    source: source2
  };
  delete exports.compiled;
  delete exports.filename;
  return toRawExports(exports);
}
function toRawExports(object4) {
  let exports = Object.entries(object4).filter(([_key, value]) => typeof value !== "function").sort(([a], [b]) => a < b ? -1 : a === b ? 0 : 1).map(([key2, value]) => `export const ${key2}=${JSON.stringify(value)}`).join("\n") + "\n";
  if (Object.prototype.hasOwnProperty.call(object4, "code")) {
    exports += "export default code\n";
  }
  return exports;
}

// node_modules/@sveltejs/vite-plugin-svelte/src/preprocess.js
var import_node_process6 = __toESM(require_node_process(), 1);
var supportedScriptLangs = ["ts"];
var lang_sep = ".vite-preprocess";
function vitePreprocess(opts) {
  const preprocessor = { name: "vite-preprocess" };
  if ((opts == null ? void 0 : opts.script) === true) {
    preprocessor.script = viteScript().script;
  }
  if ((opts == null ? void 0 : opts.style) !== false) {
    const styleOpts = typeof (opts == null ? void 0 : opts.style) == "object" ? opts == null ? void 0 : opts.style : void 0;
    preprocessor.style = viteStyle(styleOpts).style;
  }
  return preprocessor;
}
function viteScript() {
  return {
    async script({ attributes, content, filename: filename2 = "" }) {
      const lang = (
        /** @type {string} */
        attributes.lang
      );
      if (!supportedScriptLangs.includes(lang)) return;
      const { code, map } = await transformWithEsbuild(content, filename2, {
        loader: (
          /** @type {import('vite').ESBuildOptions['loader']} */
          lang
        ),
        target: "esnext",
        tsconfigRaw: {
          compilerOptions: {
            // svelte typescript needs this flag to work with type imports
            importsNotUsedAsValues: "preserve",
            preserveValueImports: true
          }
        }
      });
      mapToRelative(map, filename2);
      return {
        code,
        map
      };
    }
  };
}
function viteStyle(config = {}) {
  let cssTransform;
  const style = async ({ attributes, content, filename: filename2 = "" }) => {
    const ext = attributes.lang ? `.${attributes.lang}` : ".css";
    if (attributes.lang && !isCSSRequest(ext)) return;
    if (!cssTransform) {
      cssTransform = createCssTransform(style, config).then((t) => cssTransform = t);
    }
    const transform = await cssTransform;
    const suffix = `${lang_sep}${ext}`;
    const moduleId = `${filename2}${suffix}`;
    const { code, map, deps } = await transform(content, moduleId);
    removeLangSuffix(map, suffix);
    mapToRelative(map, filename2);
    const dependencies = deps ? Array.from(deps).filter((d) => !d.endsWith(suffix)) : void 0;
    return {
      code,
      map: map ?? void 0,
      dependencies
    };
  };
  style.__resolvedConfig = null;
  return { style };
}
async function createCssTransform(style, config) {
  let resolvedConfig;
  if (style.__resolvedConfig) {
    resolvedConfig = style.__resolvedConfig;
  } else if (isResolvedConfig(config)) {
    resolvedConfig = config;
  } else {
    const useBuild = !import_node_process6.default.env.NODE_ENV || import_node_process6.default.env.NODE_ENV === "production";
    const command = useBuild ? "build" : "serve";
    const defaultMode = useBuild ? "production" : "development";
    resolvedConfig = await resolveConfig(config, command, defaultMode, defaultMode, false);
  }
  return async (code, filename2) => {
    return preprocessCSS(code, filename2, resolvedConfig);
  };
}
function isResolvedConfig(config) {
  return !!config.inlineConfig;
}

// node_modules/@sveltejs/vite-plugin-svelte/src/index.js
function svelte(inlineOptions) {
  if (import_node_process7.default.env.DEBUG != null) {
    log.setLevel("debug");
  }
  validateInlineOptions(inlineOptions);
  const cache = new VitePluginSvelteCache();
  let requestParser;
  let moduleRequestParser;
  let options;
  let viteConfig;
  let compileSvelte2;
  const api = {};
  const plugins = [
    {
      name: "vite-plugin-svelte",
      // make sure our resolver runs before vite internal resolver to resolve svelte field correctly
      enforce: "pre",
      api,
      async config(config, configEnv) {
        if (import_node_process7.default.env.DEBUG) {
          log.setLevel("debug");
        } else if (config.logLevel) {
          log.setLevel(config.logLevel);
        }
        options = await preResolveOptions(inlineOptions, config, configEnv);
        const extraViteConfig = await buildExtraViteConfig(options, config);
        log.debug("additional vite config", extraViteConfig, "config");
        return extraViteConfig;
      },
      async configResolved(config) {
        options = resolveOptions(options, config, cache);
        patchResolvedViteConfig(config, options);
        requestParser = buildIdParser(options);
        compileSvelte2 = createCompileSvelte();
        viteConfig = config;
        api.options = options;
        log.debug("resolved options", options, "config");
      },
      async buildStart() {
        if (!options.prebundleSvelteLibraries) return;
        const isSvelteMetadataChanged = await saveSvelteMetadata(viteConfig.cacheDir, options);
        if (isSvelteMetadataChanged) {
          viteConfig.optimizeDeps.force = true;
        }
      },
      configureServer(server) {
        options.server = server;
        setupWatchers(options, cache, requestParser);
      },
      async load(id2, opts) {
        const ssr = !!(opts == null ? void 0 : opts.ssr);
        const svelteRequest = requestParser(id2, !!ssr);
        if (svelteRequest) {
          const { filename: filename2, query, raw } = svelteRequest;
          if (raw) {
            const code = await loadRaw(svelteRequest, compileSvelte2, options);
            return {
              code,
              map: {
                mappings: ""
              }
            };
          } else {
            if (query.svelte && query.type === "style") {
              const css = cache.getCSS(svelteRequest);
              if (css) {
                return css;
              }
            }
            if (viteConfig.assetsInclude(filename2)) {
              log.debug(`load returns raw content for ${filename2}`, void 0, "load");
              return import_node_fs10.default.readFileSync(filename2, "utf-8");
            }
          }
        }
      },
      async resolveId(importee, importer, opts) {
        const ssr = !!(opts == null ? void 0 : opts.ssr);
        const svelteRequest = requestParser(importee, ssr);
        if (svelteRequest == null ? void 0 : svelteRequest.query.svelte) {
          if (svelteRequest.query.type === "style" && !svelteRequest.raw) {
            log.debug(
              `resolveId resolved virtual css module ${svelteRequest.cssId}`,
              void 0,
              "resolve"
            );
            return svelteRequest.cssId;
          }
        }
      },
      async transform(code, id2, opts) {
        var _a2;
        const ssr = !!(opts == null ? void 0 : opts.ssr);
        const svelteRequest = requestParser(id2, ssr);
        if (!svelteRequest || svelteRequest.query.type === "style" || svelteRequest.raw) {
          return;
        }
        let compileData;
        try {
          compileData = await compileSvelte2(svelteRequest, code, options);
        } catch (e2) {
          cache.setError(svelteRequest, e2);
          throw toRollupError(e2, options);
        }
        logCompilerWarnings(svelteRequest, compileData.compiled.warnings, options);
        cache.update(compileData);
        if ((_a2 = compileData.dependencies) == null ? void 0 : _a2.length) {
          if (options.server) {
            for (const dep of compileData.dependencies) {
              ensureWatchedFile(options.server.watcher, dep, options.root);
            }
          } else if (options.isBuild && viteConfig.build.watch) {
            for (const dep of compileData.dependencies) {
              this.addWatchFile(dep);
            }
          }
        }
        return {
          ...compileData.compiled.js,
          meta: {
            vite: {
              lang: compileData.lang
            }
          }
        };
      },
      handleHotUpdate(ctx) {
        if (!options.compilerOptions.hmr || !options.emitCss) {
          return;
        }
        const svelteRequest = requestParser(ctx.file, false, ctx.timestamp);
        if (svelteRequest) {
          return handleHotUpdate(compileSvelte2, ctx, svelteRequest, cache, options);
        }
      },
      async buildEnd() {
        var _a2;
        await ((_a2 = options.stats) == null ? void 0 : _a2.finishAll());
      }
    },
    {
      name: "vite-plugin-svelte-module",
      enforce: "post",
      async configResolved() {
        moduleRequestParser = buildModuleIdParser(options);
      },
      async transform(code, id2, opts) {
        const ssr = !!(opts == null ? void 0 : opts.ssr);
        const moduleRequest = moduleRequestParser(id2, ssr);
        if (!moduleRequest) {
          return;
        }
        try {
          const compileResult = compileModule(code, {
            dev: !viteConfig.isProduction,
            generate: ssr ? "server" : "client",
            filename: moduleRequest.filename
          });
          logCompilerWarnings(moduleRequest, compileResult.warnings, options);
          return compileResult.js;
        } catch (e2) {
          throw toRollupError(e2, options);
        }
      }
    },
    svelteInspector()
  ];
  return plugins;
}
export {
  loadSvelteConfig,
  svelte,
  vitePreprocess
};
//# sourceMappingURL=@sveltejs_vite-plugin-svelte.js.map
